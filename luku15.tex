\chapter{NP-ongelmat}

\index{NP-ongelma}

Olemme tässä kirjassa tutustuneet moniin algoritmeihin,
jotka toimivat tehokkaasti.
Kuitenkin on myös suuri määrä ongelmia, joiden ratkaisemiseen ei tällä
hetkellä tunneta mitään tehokasta algoritmia.
Jos vastaamme tulee tällainen ongelma, hyvät neuvot ovat kalliit.

Vaikeiden ongelmien yhteydessä esiintyy usein kirjainyhdistelmä NP.
Erityisen tunnettu on kysymys P vs. NP,
jonka ratkaisijalle on luvattu miljoonan dollarin potti.
Hankalalta tuntuvasta ongelmasta saatetaan arvella, että
se on NP-täydellinen tai NP-vaikea.
Nyt on aika selvittää, mitä nämä käsitteet oikeastaan tarkoittavat.

\section{Vaativuusluokat}

\index{vaativuusluokka}

Laskennallisia ongelmia luokitellaan \emph{vaativuusluokkiin}
(\emph{complexity class}),
joista jokaisessa on joukko ongelmia,
joiden ratkaisemisen vaikeudessa on jotain yhteistä.
Tunnetuimmat vaativuusluokat ovat P ja NP.

\index{päätösongelma}

Keskitymme tässä luvussa \emph{päätösongelmiin}
(\emph{decision problem}), joissa algoritmin tulee
antaa aina vastaus ''kyllä'' tai ''ei''.
Esimerkiksi ongelma 
''onko verkossa polkua solmusta $a$ solmuun $b$?'' on päätösongelma.
Tulemme huomaamaan, että voimme muotoilla monenlaisia ongelmia
päätösongelmina eikä tämä rajoita juurikaan, mitä ongelmia voimme tarkastella.

\subsection{Luokka P}

\index{P-luokka}
\index{polynominen algoritmi}

Luokka P sisältää päätösongelmat, joiden ratkaisemiseen on
olemassa \emph{polynominen} algoritmi eli algoritmi, jonka aikavaativuus
on enintään $O(n^k)$, missä $k$ on vakio.
Lähes kaikki tässä kirjassa esitetyt algoritmit
ovat olleet polynomisia.
Tuttuja polynomisia aikavaativuuksia ovat esimerkiksi
$O(1)$, $O(\log n)$ $O(n)$, $O(n \log n)$, $O(n^2)$ ja $O(n^3)$.

Esimerkiksi ongelma ''onko verkossa polkua solmusta $a$ solmuun $b$?''
kuuluu luokkaan P, koska voimme ratkaista sen monellakin tavalla
polynomisessa ajassa.
Voimme vaikkapa aloittaa syvyyshaun solmusta $a$ ja tarkastaa,
pääsemmekö solmuun $b$.
Tuloksena on algoritmi, joka toimii lineaarisessa ajassa,
joten ongelma kuuluu luokkaan P.

Luokan P tarkoituksena on kuvata ongelmia, jotka voimme
ratkaista jossain mielessä \emph{tehokkaasti}.
Tässä tehokkuuden määritelmä on varsin karkea:
pidämme algoritmia tehokkaana, jos sillä on mikä tahansa
polynominen aikavaativuus.
Onko $O(n^{100})$-aikainen algoritmi siis tehokas?
Ei, mutta käytännössä vakio $k$ on yleensä pieni ja
polynominen aikavaativuus on osoittautunut
toimivaksi tehokkuuden mittariksi.

\subsection{Luokka NP}

\index{NP-luokka}
\index{todiste}

Luokka NP sisältää päätösongelmat, joissa jokaisessa
''kyllä''-tapauksessa on olemassa
\emph{todiste}, jonka avulla voimme
\emph{tarkastaa} polynomisessa ajassa, että vastaus
todellakin on ''kyllä''.
Todiste on merkkijono, jonka koko on polynominen
suhteessa syötteeseen,
ja se antaa meille lisätietoa siitä,
minkä takia ''kyllä''-vastaus pitää paikkansa syötteelle.

Esimerkki luokkaan NP kuuluvasta ongelmasta on
''onko verkossa polkua solmusta $a$ solmuun $b$,
joka kulkee tasan kerran jokaisen verkon solmun kautta?''.
Tämän ongelman ratkaisemiseen ei tunneta polynomista algoritmia,
mutta jokaisessa ''kyllä''-tapauksessa on olemassa todiste:
halutunlainen polku solmusta $a$ solmuun $b$.
Voimme tarkastaa helposti polynomisessa ajassa,
että todisteen kuvaamalla polulla on vaaditut ominaisuudet.

Jos vastaus syötteeseen on ''ei'', tähän ei tarvitse
liittyä mitään todistetta.
Usein olisikin hankalaa antaa todiste siitä, että jotain
asiaa \emph{ei} ole olemassa.
Esimerkiksi jos etsimme verkosta tietynlaista polkua,
on helppoa todistaa polun olemassaolo,
koska voimme vain näyttää kyseisen polun,
mutta ei ole vastaavaa keinoa todistaa, että polkua ei ole olemassa.

Huomaa, että kaikki luokan P ongelmat kuuluvat myös
luokkaan NP. Tämä johtuu siitä, että luokan P ongelmissa
voimme tarkastaa ''kyllä''-vastauksen
\emph{tyhjän} todisteen avulla: voimme saman tien ratkaista
koko ongelman alusta alkaen polynomisessa ajassa.

\subsection{P vs. NP}

\index{P vs. NP}

Äkkiseltään voisi kuvitella, että luokassa NP täytyy olla
enemmän ongelmia kuin luokassa P.
Luokassa NP meidän riittää vain tarkastaa ''kyllä''-vastauksen
todiste, mikä tuntuu helpommalta kuin muodostaa ongelman ratkaisu tyhjästä (kuva \ref{fig:pvsnpp}).
Monet uskovatkin, että luokka NP on suurempi kuin luokka P,
mutta kukaan ei ole onnistunut todistamaan asiaa.

Tietojenkäsittelytieteen merkittävä avoin kysymys on,
päteekö $\textrm{P}=\textrm{NP}$ vai $\textrm{P} \neq \textrm{NP}$.
Monet tutkijat ovat tarttuneet haasteeseen
70-luvulta lähtien, mutta tähän mennessä kaikki ovat epäonnistuneet.
Ongelman ratkaisija saisi maineen ja kunnian lisäksi
myös tuntuvan rahallisen korvauksen, koska
Clay-instituutti on luvannut miljoonan dollarin palkinnon
sille, joka todistaa, että $\textrm{P}=\textrm{NP}$ tai $\textrm{P} \neq \textrm{NP}$.
Voi olla kuitenkin, että tämä on yksi \emph{vaikeimmista}
tavoista ansaita miljoona dollaria.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);

\node at (8.5,2) {vs.};
\end{scope}
\begin{scope}[xshift=10cm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);

\path[draw,thick,->,red,line width=2pt] (1) -- (3);
\path[draw,thick,->,red,line width=2pt] (3) -- (4);
\path[draw,thick,->,red,line width=2pt] (4) -- (2);
\path[draw,thick,->,red,line width=2pt] (2) -- (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{P vs. NP: Voisiko olla yhtä helppoa muodostaa ratkaisu tyhjästä
kuin tarkastaa, onko annettu ratkaisu oikein?}
\label{fig:pvsnpp}
\end{figure}

Jos pätee $\textrm{P} \neq \textrm{NP}$, kuten uskotaan,
vaikeutena on keksiä keino todistaa, että jotakin
luokan NP ongelmaa on mahdotonta ratkaista
polynomisessa ajassa.
Tämän todistaminen on vaikeaa, koska meidän pitää näyttää,
että tehokasta algoritmia ei ole olemassa,
vaikka laatisimme algoritmin miten tahansa.
Vaikka moni on koettanut tuloksetta ratkoa
tunnettuja NP-ongelmia, kysymys saattaa silti olla siitä,
että tehokas algoritmi olisi olemassa mutta kukaan ei
vain ole vielä löytänyt sitä.

\subsection{Muita luokkia}

\index{PSPACE-luokka}

P ja NP ovat tunnetuimmat vaativuusluokat,
mutta niiden lisäksi on suuri määrä muitakin luokkia.
Yksi tällainen luokka on PSPACE,
joka sisältää ongelmat, joiden ratkaisuun riittää
polynominen määrä \emph{muistia}.
PSPACE sisältää kaikki luokan NP ongelmat,
mutta siinä on myös ongelmia,
joiden ei tiedetä kuuluvan luokkaan NP.

\index{BPP-luokka}
\index{ZPP-luokka}

Luokat BPP ja ZPP puolestaan liittyvät satunnaisuuteen.
Luokka BPP sisältää ongelmat, joiden ratkaisuun on polynomiaikainen algoritmi,
joka antaa oikean vastauksen ainakin todennäköisyydellä 2/3.
Luokka ZPP taas sisältää ongelmat, joiden ratkaisuun on algoritmi,
jonka suoritusajan \emph{odotusarvo} on polynominen.
Sekä BPP että ZPP sisältävät luokan P, jonka ongelmat
voi ratkaista polynomisessa ajassa ilman satunnaisuuttakin.

Vaativuusluokkien suhteet toisiinsa tunnetaan yleensä ottaen huonosti.
Vaikka kysymys P vs. NP on saanut eniten huomiota,
myös vastaavat kysymykset esimerkiksi luokkien PSPACE, BPP ja ZPP
kohdalla ovat avoimia ongelmia.
Kukaan ei tiedä, onko näissä luokissa loppujen lopuksi mitään ongelmaa,
joka ei kuuluisi myös luokkaan P.

\section{NP-täydellisyys}

\index{NP-täydellinen ongelma}

Sanomme, että ongelma on \emph{NP-täydellinen} (\emph{NP-complete}),
jos se kuuluu luokkaan NP ja mikä tahansa luokan NP
ongelma voidaan \emph{palauttaa} siihen polynomisessa ajassa.
NP-täydelliset ongelmat ovat luokan NP vaikeimpia ongelmia:
jos voisimme ratkaista jonkin NP-täydellisen ongelman tehokkaasti,
voisimme ratkaista minkä tahansa luokan NP ongelman tehokkaasti.

Kiinnostava ilmiö on, että lähes kaikki tunnetut luokan NP
ongelmat joko kuuluvat myös luokkaan P tai ovat NP-täydellisiä.
Nykyään tunnetaankin tuhansia erilaisia NP-täydellisiä ongelmia.
Jos keksisimme mihin tahansa niistä polynomisessa ajassa toimivan
ratkaisun, olisimme samalla onnistuneet todistamaan,
että $\textrm{P}=\textrm{NP}$.

\subsection{SAT-ongelma}

\index{SAT-ongelma}

Ensimmäinen löydetty NP-täydellinen ongelma oli
SAT-ongelma, jossa annettuna on konjunktiivisessa
normaalimuodossa oleva looginen kaava ja haluamme
selvittää, voimmeko valita muuttujien arvot niin,
että kaava on tosi.
Konjunktiivinen normaalimuoto tarkoittaa,
että kaava koostuu lausekkeista, jotka on yhdistetty
ja-operaatiolla ($\land$), ja jokainen lauseke muodostuu
muuttujista ja niiden negaatioista, jotka on yhdistetty
tai-operaatiolla ($\lor$).

Esimerkiksi kaava
\[(\neg x_1 \lor x_3) \land (x_1 \lor x_2 \lor x_3) \land (\neg x_2 \lor \neg x_3)\]
on mahdollista saada todeksi, koska voimme esimerkiksi asettaa
muuttujat $x_1$ ja $x_2$ epätosiksi ja muuttujan $x_3$ todeksi.
Vastaavasti kaava
\[(x_1 \lor x_2) \land (\neg x_1 \lor x_2) \land (x_1 \lor \neg x_2) \land (\neg x_1 \lor \neg x_2) \]
ei ole tosi, vaikka valitsisimme muuttujien arvot miten tahansa.

Kun haluamme osoittaa, että SAT on NP-täydellinen ongelma,
meidän täytyy näyttää, että se kuuluu luokkaan NP ja mikä
tahansa luokan NP ongelma voidaan palauttaa siihen.
Luokkaan NP kuuluminen on helppoa nähdä:
''kyllä''-tapauksessa todiste on kullekin muuttujalle valittu arvo.
Huomattavasti vaikeampaa on osoittaa, että \emph{jokainen} luokan
NP ongelma voidaan palauttaa SAT-ongelmaan polynomisessa ajassa.

Tässä kirjassa emme käsittele todistusta yksityiskohtaisesti,
mutta voimme kuitenkin kuvailla sen perusideaa.
Tarkastellaan tiettyä luokan NP ongelmaa,
joka meidän täytyy pystyä palauttamaan SAT-ongelmaan.
Koska ongelma voi olla mikä tahansa luokkaan NP kuuluva, tiedämme siitä vain,
että on olemassa algoritmi, joka tarkastaa
polynomisessa ajassa ''kyllä''-tapauksen todisteen.
Tämä vastaa sitä, että on olemassa \emph{epädeterministinen} Turingin kone,
joka rakentaa ja tarkastaa tällaisen todisteen polynomisessa ajassa.
Nyt kun haluamme tarkastaa annetusta syötteestä, onko vastaus siihen ''kyllä'',
voimme muodostaa konjunktiivisessa normaalimuodossa olevan loogisen kaavan,
joka luonnehtii Turingin koneen laskentaa, kun koneelle annetaan kyseinen syöte.
Voimme muodostaa kaavan niin, että sen voi saada todeksi tarkalleen silloin,
kun vastaus syötteeseen on ''kyllä''.
Niinpä olemme onnistuneet palauttamaan alkuperäisen ongelman SAT-ongelmaan.

\subsection{Ongelmien palautukset}

\index{palautus}

Kun tiedämme, että SAT-ongelma on NP-täydellinen,
voimme osoittaa muita ongelmia NP-täydellisiksi palautusten avulla.
Ideana on, että jos ongelma $A$ on NP-täydellinen ja
voimme palauttaa sen polynomisessa ajassa ongelmaksi $B$,
myös ongelma $B$ on NP-täydellinen.

\subsubsection{Palautus SAT $\rightarrow$ 3SAT}

\index{3SAT-ongelma}

Aloitamme osoittamalla, että 3SAT-ongelma on NP-täydellinen.
3SAT-on\-gelma on SAT-ongelman erikoistapaus, jossa jokaisessa
$\land$-merkeillä yhdistetyssä lausekkeessa on tarkalleen kolme muuttujaa.
Esimerkiksi kaava
\[(x_1 \lor x_2 \lor x_3) \land (\neg x_1 \lor x_2 \lor \neg x_3)\]
on kelvollinen 3SAT-ongelman syöte.
Jotta saamme palautettua SAT-ongel\-man 3SAT-ongelmaan,
meidän on näytettävä, että voimme muuttaa polynomisessa ajassa
minkä tahansa SAT-ongelman syötteen 3SAT-ongelman syötteeksi,
jonka totuusarvo on sama.

Ideana on muokata jokaista SAT-ongelman syötteen lauseketta niin, 
että tuloksena on yksi tai useampia kolmen muuttujan lausekkeita.
Merkitään $k$:lla lausekkeen muuttujien määrää.
Jos $k=1$ tai $k=2$, toistamme viimeistä muuttujaa uudestaan,
jotta saamme lausekkeeseen kolme muuttujaa.
Esimerkiksi jos lauseke on $(x_1)$, muutamme sen muotoon
$(x_1 \lor x_1 \lor x_1)$, ja jos lauseke on $(x_1 \lor x_2)$, muutamme
sen muotoon $(x_1 \lor x_2 \lor x_2)$.
Jos $k=3$, meidän ei tarvitse tehdä mitään, koska lausekkeessa
on valmiiksi kolme muuttujaa. Jos sitten $k>3$,
jaamme lausekkeen osiin, jotka ketjutetaan uusien apumuuttujien avulla.
Ketjun jokaisessa kohdassa vasemman lausekkeen viimeinen
muuttuja on $a_i$ ja oikean lausekkeen ensimmäinen muuttuja on $\neg a_i$.
Tämä takaa, että ainakin yksi alkuperäinen muuttuja saa oikean arvon.
Esimerkiksi jos lauseke on $(x_1 \lor x_2 \lor x_3 \lor x_4 \lor x_5)$,
muutamme sen kolmeksi lausekkeeksi $(x_1 \lor x_2 \lor a_1)$,
$(\neg a_1 \lor x_3 \lor a_2)$ ja $(\neg a_2 \lor x_4 \lor x_5)$.

Tämä palautus osoittaa, että 3SAT on NP-täydellinen ongelma,
eli SAT-ongelman oleellinen vaikeus syntyy jo siitä, että lausekkeissa
voi olla kolme muuttujaa\footnote{Entä ongelma 2SAT, jossa jokaisessa lausekkeessa
on kaksi muuttujaa? Tämä \emph{ei} ole NP-täydellinen ongelma,
vaan kuuluu luokkaan P.}.
Palautuksen hyötynä on myös se, että myöhemmissä todistuksissa
meidän on helpompaa käsitellä kolmen muuttujan lausekkeita
kuin vaihtelevan pituisia lausekkeita.

\subsubsection{Palautus 3SAT $\rightarrow$ solmupeite}

\index{solmupeite}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle, fill=lightgray] (2) at (4,3) {$2$};
\node[draw, circle, fill=lightgray] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle, fill=lightgray] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
\caption{Solmut $\{2,3,5\}$ muodostavat solmupeitteen.}
\label{fig:solpei}
\end{figure}

Seuraavaksi osoitamme, että on NP-täydellinen ongelma tarkastaa,
onko verkossa \emph{solmupeitettä} (\emph{vertex cover}), jossa on $k$ solmua.
Solmupeite on verkon solmujen osa\-joukko, joka on valittu niin,
että jokaisessa kaaressa ainakin toinen pääte\-solmu kuuluu
solmupeitteeseen.
Esimerkiksi kuvassa \ref{fig:solpei} on verkko ja sen solmupeite,
johon kuuluu kolme solmua.

Kun haluamme palauttaa 3SAT-ongelman solmupeiteongelmaan,
meidän täytyy näyttää, että voimme tulkita minkä tahansa
3SAT-ongelman tapauksen verkon solmupeitteen etsimisenä.
Meidän tulee keksiä systemaattinen tapa
muuttaa looginen kaava verkoksi,
jonka $k$ solmun solmupeite vastaa sitä, että kaava on totta.

Oletamme, että kaavassa esiintyy $n$ muuttujaa $x_1,x_2,\dots,x_n$
ja siinä on $m$ lauseketta.
Muodostamme verkon, jossa on ensinnäkin $n$ solmuparia,
jotka vastaavat kaavan muuttujia.
Kussakin solmuparissa on muuttujat $x_i$ ja $\neg x_i$,
joiden välillä on kaari.
Lisäksi verkossa on $m$ kolmen solmun ryhmää,
jotka vastaavat lausekkeita.
Jokaisessa ryhmässä kaikki solmut ovat yhteydessä toisiinsa,
minkä lisäksi kukin solmu on yhteydessä sitä vastaavaan solmuun pareissa.
Esimerkiksi kaavaa
\[(x_1 \lor \neg x_2 \lor x_3) \land (\neg x_1 \lor \neg x_3 \lor x_4),\]
vastaa kuvan \ref{fig:solko1} mukainen verkko.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (a1) at (0,0) {$x_1$};
\node[draw, circle] (a2) at (2,0) {$x_2$};
\node[draw, circle] (a3) at (4,0) {$x_3$};
\node[draw, circle] (a4) at (6,0) {$x_4$};
\node[draw, circle] (b1) at (0,-2) {\phantom{$x_1$}};
\node[draw, circle] (b2) at (2,-2) {\phantom{$x_2$}};
\node[draw, circle] (b3) at (4,-2) {\phantom{$x_3$}};
\node[draw, circle] (b4) at (6,-2) {\phantom{$x_4$}};
\node at (0,-2) {$\neg x_1$};
\node at (2,-2) {$\neg x_2$};
\node at (4,-2) {$\neg x_3$};
\node at (6,-2) {$\neg x_4$};

\node[draw, circle] (c1) at (10.5,0) {$x_1$};
\node[draw, circle] (c2) at (9,-2) {\phantom{$x_2$}};
\node[draw, circle] (c3) at (12,-2) {$x_3$};
\node at (9,-2) {$\neg x_2$};

\node[draw, circle] (d1) at (16.5,0) {\phantom{$x_1$}};
\node[draw, circle] (d2) at (15,-2) {\phantom{$x_3$}};
\node[draw, circle] (d3) at (18,-2) {$x_4$};
\node at (16.5,0) {$\neg x_1$};
\node at (15,-2) {$\neg x_3$};

\path[draw,thick,-] (a1) -- (b1);
\path[draw,thick,-] (a2) -- (b2);
\path[draw,thick,-] (a3) -- (b3);
\path[draw,thick,-] (a4) -- (b4);

\path[draw,thick,-] (c1) -- (c2);
\path[draw,thick,-] (c2) -- (c3);
\path[draw,thick,-] (c3) -- (c1);
\path[draw,thick,-] (d1) -- (d2);
\path[draw,thick,-] (d2) -- (d3);
\path[draw,thick,-] (d3) -- (d1);

\path[draw,thick,-] (a1) edge [bend left=25] (c1);
\path[draw,thick,-] (b2) edge [bend right=30] (c2);
\path[draw,thick,-] (b3) edge [bend right=30] (d2);

\path[draw,thick,-] (a3) .. controls (5,1) and (12,3.00) .. (c3);
\path[draw,thick,-] (a4) .. controls (7,1) and (18,4.00) .. (d3);
\path[draw,thick,-] (b1) .. controls (5,-5) and (17,-5.00) .. (d1);
\end{tikzpicture}
\end{center}
\caption{Kaava $(x_1 \lor \neg x_2 \lor x_3) \land (\neg x_1 \lor \neg x_3 \lor x_4)$ verkkona.}
\label{fig:solko1}
\end{figure}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle,fill=lightgray] (a1) at (0,0) {$x_1$};
\node[draw, circle,fill=lightgray] (a2) at (2,0) {$x_2$};
\node[draw, circle] (a3) at (4,0) {$x_3$};
\node[draw, circle,fill=lightgray] (a4) at (6,0) {$x_4$};
\node[draw, circle] (b1) at (0,-2) {\phantom{$x_1$}};
\node[draw, circle] (b2) at (2,-2) {\phantom{$x_2$}};
\node[draw, circle,fill=lightgray] (b3) at (4,-2) {\phantom{$x_3$}};
\node[draw, circle] (b4) at (6,-2) {\phantom{$x_4$}};
\node at (0,-2) {$\neg x_1$};
\node at (2,-2) {$\neg x_2$};
\node at (4,-2) {$\neg x_3$};
\node at (6,-2) {$\neg x_4$};

\node[draw, circle] (c1) at (10.5,0) {$x_1$};
\node[draw, circle,fill=lightgray] (c2) at (9,-2) {\phantom{$x_2$}};
\node[draw, circle,fill=lightgray] (c3) at (12,-2) {$x_3$};
\node at (9,-2) {$\neg x_2$};

\node[draw, circle,fill=lightgray] (d1) at (16.5,0) {\phantom{$x_1$}};
\node[draw, circle,fill=lightgray] (d2) at (15,-2) {\phantom{$x_3$}};
\node[draw, circle] (d3) at (18,-2) {$x_4$};
\node at (16.5,0) {$\neg x_1$};
\node at (15,-2) {$\neg x_3$};

\path[draw,thick,-] (a1) -- (b1);
\path[draw,thick,-] (a2) -- (b2);
\path[draw,thick,-] (a3) -- (b3);
\path[draw,thick,-] (a4) -- (b4);

\path[draw,thick,-] (c1) -- (c2);
\path[draw,thick,-] (c2) -- (c3);
\path[draw,thick,-] (c3) -- (c1);
\path[draw,thick,-] (d1) -- (d2);
\path[draw,thick,-] (d2) -- (d3);
\path[draw,thick,-] (d3) -- (d1);

\path[draw,thick,-] (a1) edge [bend left=25] (c1);
\path[draw,thick,-] (b2) edge [bend right=30] (c2);
\path[draw,thick,-] (b3) edge [bend right=30] (d2);

\path[draw,thick,-] (a3) .. controls (5,1) and (12,3.00) .. (c3);
\path[draw,thick,-] (a4) .. controls (7,1) and (18,4.00) .. (d3);
\path[draw,thick,-] (b1) .. controls (5,-5) and (17,-5.00) .. (d1);
\end{tikzpicture}
\end{center}
\caption{Ratkaisu, jossa $x_1$, $x_2$ ja $x_4$ ovat tosia ja $x_3$ on epätosi.}
\label{fig:solko2}
\end{figure}

Osoittautuu, että voimme saada kaavan todeksi tarkalleen silloin,
kun verkossa on solmupeite, jossa on enintään $k=n+2m$ solmua.
Tällaiseen peitteeseen kuuluu toinen solmu jokaisesta
parista $x_i$ ja $\neg x_i$. Tämä määrittää, miten muuttujien
arvot asetetaan.
Lisäksi peitteeseen kuuluu kaksi solmua jokaisesta kolmen solmun ryhmästä.
Koska ryhmässä on yksi solmu, joka ei kuulu peitteeseen,
kyseisen solmun täytyy olla yhteydessä kaarella peitteeseen kuuluvaan solmuun.
Tämä varmistaa, että jokaisessa lausekkeessa ainakin yksi kolmesta
muuttujasta on asetettu oikein.
Kuva \ref{fig:solko2} näyttää esimerkin solmupeitteestä,
joka saa kaavan todeksi.
Tämä vastaa ratkaisua, jossa $x_1$, $x_2$ ja $x_4$ ovat tosia
ja $x_3$ on epätosi.

Olemme siis onnistuneet palauttamaan 3SAT-ongelman solmupeiteongelmaksi
niin, että verkon koko on polynominen suhteessa kaavan pituuteen,
joten solmupeiteongelma on NP-täydellinen.

\subsection{Lisää ongelmia}

Palautusten avulla on onnistuttu löytämään tuhansia NP-täydellisiä ongelmia.
Esimerkiksi myös seuraavat ongelmat ovat NP-täydellisiä:

\index{klikki}
\index{väritys}
\index{Hamiltonin polku}

\begin{itemize}
\item onko verkossa $k$-kokoista \emph{klikkiä} (\emph{clique})
eli $k$ solmun joukkoa,
jossa jokaisen kahden solmun välillä on kaari?
\item voimmeko värittää verkon solmut kolmella värillä niin,
että jokaisen kaaren päätesolmut ovat eri värisiä?
\item onko verkossa polkua, joka kulkee tasan kerran jokaisen
verkon solmun kautta (eli \emph{Hamiltonin polkua} (\emph{Hamiltonian path}))?
\item voiko annetuista $n$ luvusta valita osajoukon, jonka summa on $x$?
\item onko olemassa $k$-merkkistä merkkijonoa,
jonka alijonoja ovat kaikki annetut merkkijonot?
\end{itemize}

\index{isomorfiset verkot}

Entä millainen olisi luokan NP ongelma, joka ei kuulu luokkaan P
eikä ole NP-täydellinen?
Kukaan ei tiedä, onko tällaista ongelmaa olemassa,
koska ei edes tiedetä, ovatko P ja NP eri luokat.
Yksi ehdokas tällaiseksi ongelmaksi on kuitenkin ongelma,
jossa haluamme tarkastaa,
ovatko kaksi verkkoa \emph{isomorfiset} eli
onko verkkojen rakenne samanlainen,
jos solmut asetetaan vastaamaan toisiaan sopivalla tavalla.
Esimerkiksi kuvassa \ref{fig:veriso} olevat verkot ovat isomorfiset,
koska voimme valita solmuille vastaavuudet $(1,c)$, $(2,a)$, $(3,d)$ ja $(4,b)$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\begin{scope}
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (2.5,0) {$2$};
\node[draw, circle] (3) at (5,0) {$3$};
\node[draw, circle] (4) at (7.5,0) {$4$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (2) -- (3);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (1) edge [bend right=35] (3);
\path[draw,thick,-] (2) edge [bend left=35] (4);
\end{scope}
\begin{scope}[xshift=12cm,yshift=1.25cm]
\node[draw, circle, minimum size=7.5mm] (1) at (0,0) {$a$};
\node[draw, circle, minimum size=7.5mm] (2) at (2.5,0) {$b$};
\node[draw, circle, minimum size=7.5mm] (3) at (0,-2.5) {$c$};
\node[draw, circle, minimum size=7.5mm] (4) at (2.5,-2.5) {$d$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (4) -- (3);
\path[draw,thick,-] (3) -- (1);
\path[draw,thick,-] (1) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kaksi verkkoa, jotka ovat isomorfiset.}
\label{fig:veriso}
\end{figure}

Verkkojen isomorfisuuden ongelma kuuluu luokkaan NP,
koska on helppoa tarkastaa, onko verkoilla sama rakenne,
jos tiedämme solmujen vastaavuudet.
Ongelmaan ei kuitenkaan tunneta polynomiaikaista algoritmia,
joten sen ei tiedetä kuuluvan luokkaan P.
Toisaalta emme myöskään osaa tehdä mitään palautusta,
joka osoittaisi ongelman olevan NP-täydellinen.

\subsection{Optimointiongelmat}

\index{optimointiongelma}

Käytännössä haluamme usein ratkaista päätösongelman
sijasta \emph{optimointiongelman} (\emph{optimization problem}): haluamme etsiä pienimmän
tai suurimman mahdollisen ratkaisun.
Esimerkiksi emme halua tarkastaa, onko verkossa
enintään $k$ solmun solmupeitettä (päätösongelma),
vaan haluamme etsiä \emph{pienimmän} solmupeitteen (optimointiongelma).
Osoittautuu kuitenkin, että päätösongelmat ja optimointiongelmat
ovat loppujen lopuksi hyvin lähellä toisiaan.

Oletetaan, että meillä on keino tarkastaa tehokkaasti,
onko verkossa $k$ solmun solmupeitettä.
Miten voimme menetellä, jos haluammekin etsiä pienimmän
solmupeitteen?
Ratkaisuna on käyttää \emph{binäärihakua}:
etsimme pienimmän arvon $x$, jolle pätee,
että verkossa on $x$ solmun solmupeite.
Tämä tarkoittaa, että verkon pienin solmupeite
sisältää $x$ solmua.
Koska käytämme binäärihakua, meidän riittää ratkaista
päätösongelma vain logaritminen mää\-rä kertoja,
joten saamme ratkaistua optimointiongelman lähes yhtä
tehokkaasti kuin päätösongelman.

\index{NP-vaikea ongelma}

Sanomme, että ongelma on \emph{NP-vaikea} (\emph{NP-hard}), jos voimme palauttaa
kaikki luokan NP ongelmat siihen mutta ongelman ei
tarvitse kuulua luokkaan NP.
Jos ongelma on NP-vaikea, se on siis ainakin yhtä vaikea
kuin luokan NP vaikeimmat ongelmat.
Tyypillisiä NP-vaikeita ongelmia ovat NP-täydellisten
päätösongelmien optimointiversiot,
koska voimme palauttaa niihin NP-täy\-dellisiä ongelmia
mutta ne eivät kuulu luokkaan NP.

Käytännössä termejä ei käytetä aina näin täsmällisesti
ja optimointiongelmaa saatetaan sanoa NP-täydelliseksi,
vaikka se oikeastaan on NP-vaikea.
Voimme myös vain puhua yleisesti NP-ongelmista,
kun tarkoitamme NP-täydellisiä ja NP-vaikeita ongelmia.

\section{Ongelmien ratkaiseminen}

Jos saamme ratkaistavaksemme NP-vaikean ongelman,
tilanne ei näytä hy\-vältä, koska edessämme on silloin ongelma,
johon ei tunneta mitään tehokasta algoritmia.
Emme voi toivoa, että osaisimme ratkaista tehokkaasti ongelmaa,
jota kukaan muukaan ei ole osannut.
Peli ei ole kuitenkaan välttämättä vielä menetetty,
vaan voimme koettaa lähestyä ongelmaa monella tavalla.

Tarkastellaan seuraavaksi ongelmaa, jossa meille annetaan $n$
kokonaislukua ja haluamme jakaa luvut kahteen ryhmään niin,
että ryhmien summat ovat mahdollisimman lähellä toisiaan.
Esimerkiksi jos $n=5$ ja luvut ovat $[1,2,4,5,7]$,
paras ratkaisu on muodostaa ryhmät $[1,2,7]$ ja $[4,5]$,
joiden summat ovat $1+2+7=10$ ja $4+5=9$.
Tällöin summien ero on 1,
eikä ole olemassa ratkaisua, jossa ero olisi 0.

Tämä ongelma on NP-vaikea, joten kukaan ei tiedä tehokasta
algoritmia sen ratkaisemiseen.
Seuraavaksi käymme läpi joukon tapoja, joiden avulla
voimme kuitenkin yrittää ratkaista ongelmaa.

\subsubsection{Raaka voima}

Vaikka ongelma olisi NP-vaikea, voimme silti ratkaista sen
pieniä tapauksia.
Tässä tehtävässä voimme tehdä algoritmin,
joka käy läpi kaikki tavat jakaa luvut kahteen ryhmään
ja valitsee parhaan vaihtoehdon.
Tämä vastaa sitä, että käymme läpi kaikki tavat valita
toiseen ryhmään tulevat luvut
eli kaikki lukujen osajoukot.

Koska $n$ luvusta voi muodostaa $2^n$ osajoukkoa,
tällainen algoritmi vie aikaa $O(2^n)$.
Voimme toteuttaa algoritmin esimerkiksi rekursiolla
samaan tapaan kuin teimme luvussa 1.
Tuloksena oleva algoritmi on käyttökelpoinen, jos $n$ on niin pieni,
että ehdimme käydä kaikki osajoukot läpi.
Käytännössä voimme ratkaista tehokkaasti tapauksia,
joissa $n$ on enintään noin 20.

\subsubsection{Heuristiikat}

\index{heuristiikka}

Yksi mahdollisuus selviytyä vaikeasta ongelmasta on tyytyä
optimaalisen ratkaisun sijasta johonkin \emph{melko hyvään} ratkaisuun,
joka ei välttämättä ole optimaalinen.
Saamme tällaisen ratkaisun aikaan keksimällä jonkin
\emph{heuristiikan} (\emph{heuristic}), joka muodostaa ratkaisun.
Heuristiikka on jokin järkevä sääntö, jonka avulla
algoritmi rakentaa ratkaisua eteenpäin askel kerrallaan.

Tässä tehtävässä yksinkertainen heuristiikka on
käydä luvut läpi suurimmasta pienimpään ja sijoittaa
luku aina ryhmään, jonka summa on sillä hetkellä pienempi.
Jos kummankin ryhmän summa on yhtä suuri,
sijoitamme luvun ensimmäiseen ryhmään.
Tämä on järkevä heuristiikka, koska näin saamme monessa tapauksessa
jaettua lukuja melko tasaisesti ryhmiin.

Esimerkiksi jos luvut ovat $[1,2,4,5,7]$, sijoitamme ensin
luvun 7 ensim\-mäiseen ryhmään, sitten luvut 5 ja 4 toiseen ryhmään
ja lopuksi luvut 2 ja 1 ensimmäiseen ryhmään.
Saamme muodostettua näin ryhmät $[1,2,7]$ ja $[4,5]$,
joiden summien ero on 1 eli ratkaisu on optimaalinen.

Tällainen algoritmi ei kuitenkaan tuota aina optimaalista ratkaisua.
Kun tunnemme algoritmin toiminnan, voimme keksiä tilanteita,
joissa se antaa huonomman ratkaisun.
Tällainen tapaus on esimerkiksi $[2,2,2,3,3]$.
Heuristiikkaa käyttävä algoritmi tuottaa ryhmät $[2,3]$ ja $[2,2,3]$,
joiden summien ero on 2.
Kuitenkin optimaalinen ratkaisu olisi muodostaa ryhmät
$[2,2,2]$ ja $[3,3]$, joiden summien ero on 0.

\subsubsection{Satunnaisuus}

\index{satunnainen algoritmi}

Voimme hyödyntää ongelman ratkaisemisessa myös
\emph{satunnaisuutta}.
Voimme tehdä algoritmin, joka tekee satunnaisia valintoja,
ja lisäksi toistaa algoritmia monta kertaa ja valita
parhaan ratkaisun.

Esimerkiksi voimme parantaa äskeistä heuristista algoritmia niin,
että se sekoittaa alussa lukujen järjestyksen. Tämän jälkeen voimme toistaa
algoritmia vaikkapa miljoona kertaa ja valita parhaan ratkaisun.
Tämä voi parantaa merkittävästi algoritmin toimintaa, ja on
vaikeampaa keksiä tapauksia, joissa algoritmi toimii huonosti.

\subsubsection{Rajoittaminen}

\index{pseudopolynominen algoritmi}

Joskus voimme saada aikaan tehokkaan algoritmin,
kun rajoitamme sopivalla tavalla tehtävää.
Esimerkiksi tässä tehtävässä on mahdollista luoda
tehokas dynaamisen ohjelmoinnin ratkaisu,
kunhan oletamme, että luvut ovat sopivan pieniä kokonaislukuja.

Ideana on tarkastella osaongelmia muotoa
''voimmeko valita $a$ ensimmäisestä luvusta osajoukon,
jonka lukujen summa on $b$?''
Jos luvut ovat pieniä, niin myös summat ovat pieniä,
joten voimme ratkaista kaikki tällaiset osaongelmat rekursiivisesti.
Tämän jälkeen riittää etsiä mahdollinen jako, jossa $a=n$
ja $b$ on mahdollisimman lähellä lukujen summan puoliväliä.

Tällainen ratkaisu vie aikaa $O(ns)$, missä $s$ on lukujen summa.
Sanomme, että algoritmi on \emph{pseudopolynominen},
koska sen aikavaativuus on polynominen mutta riippuu lukuarvojen suuruudesta.
Yleisessä tapauksessa syötteenä annetut luvut voivat
kuitenkin olla suuria kokonaislukuja,
jolloin emme voi käyttää tällaista ratkaisua.
