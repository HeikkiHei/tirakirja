\chapter{Tehokkuus}

\section{Aikavaativuus}

Voimme arvioida algoritmin tehokkuutta laskemalla,
montako kertaa siinä olevia komentoja suoritetaan.
Tavoitteena on arvioida tehokkuutta suhteessa
syötteen kokoon $n$.
Esimerkiksi jos syötteenä on taulukko,
$n$ on taulukon koko,
ja jos syötteenä on merkkijono,
$n$ on merkkijonon pituus.

Tarkastellaan esimerkkinä seuraavaa algoritmia,
joka laskee, montako kertaa luku $x$ esiintyy
$n$-kokoisessa taulukossa.

\begin{code}[numbers=left]
int maara = 0;
for (int i = 0; i < n; i++) {
    if (luvut[i] == x) {
        maara++;
    }
}
\end{code}

Tässä algoritmissa oleelliset komennot ovat riveillä
1, 3 ja 4.
Rivin 1 komento suoritetaan vain kerran algoritmin alussa.
Rivin 3 komento suoritetaan $n$ kertaa jokaisella silmukan
kierroksella.
Rivin 4 komento taas suoritetaan $0 \dots n$
kertaa riippuen siitä, kuinka usein
luku $x$ esiintyy taulukossa.
Algoritmissa suoritetaan siis vähintään $n+1$ ja enintään $2n+1$
komentoa.

Näin tarkka analyysi ei ole kuitenkaan yleensä tarpeen,
vaan meille riittää usein määrittää karkea ajankäytön yläraja.
Sanomme, että algoritmi toimii ajassa $O(f(n))$ eli sen
\emph{aikavaativuus} on $O(f(n))$, jos se suorittaa
enintään $c f(n)$ komentoa aina silloin kun $n \ge n_0$,
missä $c$ ja $n_0$ ovat vakioita.
Esimerkiksi yllä oleva algoritmi toimii ajassa $O(n)$,
koska se suorittaa selkeästi enintään $3n$ komentoa
kaikilla $n$:n arvoilla.

Aikavaativuden mukavana puolena on, että yleensä voimme
määrittää aikavaativuuden hyvin helposti algoritmin
rakenteesta. Tutustumme seuraavaksi laskusääntöihin,
joiden avulla tämä on mahdollista.

\subsection{Laskusääntöjä}

Jos algoritmissa ei ole silmukoita vaan vain
yksittäisiä komentoja, sen aikavaativuus on $O(1)$.
Näin on esimerkiksi seuraavassa algoritmissa.

\begin{code}
c = a+b;
b = a;
if (a > b) a++;
\end{code}

Merkitsemme \texttt{...} koodia,
jonka aikavaativuus on $O(1)$.
Jos algoritmissa on yksi silmukka,
joka suorittaa $n$ askelta,
sen aikavaativuus on $O(n)$:

\begin{code}
for (int i = 0; i < n; i++) {
    ...
}
\end{code}

Jos tällaisia silmukoita on kaksi sisäkkäin,
aikavaativuus on $O(n^2)$:

\begin{code}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        ...
    }
}
\end{code}

Yleisemmin jos algoritmissa on vastaavalla tavalla
$k$ sisäkkäistä silmukkaa,
sen aikavaativuus on $O(n^k)$.

Huomaa, että vakiokertoimet ja matalammat termit eivät vaikuta aikavaativuuteen.
Esimerkiksi seuraavia koodeja suoritetaan $2n$ ja $n-1$ kertaa,
mutta kummankin koodin aikavaativuus on $O(n)$.

\begin{code}
for (int i = 0; i < 2*n; i++) {
    ...
}
\end{code}

\begin{code}
for (int i = 0; i < n-1; i++) {
    ...
}
\end{code}

Jos algoritmissa on peräkkäisiä osuuksia, kokonaisaikavaativuus on suurin
yksittäinen aikavaativuus. Esimerkiksi seuraavan algoritmin aikavaativuus on $O(n^2)$,
koska sen osuudet ovat $O(n)$, $O(n^2)$ ja $O(n)$.

\begin{code}
for (int i = 0; i < n; i++) {
    ...
}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        ...
    }
}
for (int i = 0; i < n; i++) {
    ...
}
\end{code}

Joskus aikavaativuus riippuu useammasta tekijästä,
jolloin kaavassa on monta muuttujaa.
Esimerkiksi seuraavan koodin aikavaativuus on $O(nm)$:

\begin{code}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        ...
    }
}
\end{code}

\subsection{Yleisiä aikavaativuuksia}

Tietyt aikavaativuudet esiintyvät usein algoritmien analyysissa.
Seuraavaksi käymme läpi joukon tällaisia aikavaativuuksia.

\subsubsection{$O(1)$ (vakioaikainen)}

Vakioaikainen algoritmi suorittaa vain kiinteän määrän komentoja.
Tyypillinen vakioaikainen algoritmi on kaava, joka laskee
suoraan vastauksen. Esimerkiksi seuraava algoritmi laskee
summan $1+2+\dots+n$ vakioajassa:

\begin{code}
summa = n*(n+1)/2;
\end{code}

\subsubsection{$O(\log n)$ (logaritminen)}

Logaritminen algoritmi puolittaa usein syötteen koon
joka askeleella. Tyypillinen esimerkki logaritmisesta algoritmista
on binäärihaku, joka etsii alkiota järjestetystä taulukosta.

\begin{code}
int a = 0;
int b = n-1;
while (a <= b) {
    int c = (a+b)/2;
    if (taulu[c] == x) break;
    if (taulu[c] < x) a = c+1;
    else b = c-1;
}
\end{code}

\subsubsection{$O(n)$ (lineaarinen)}

Lineaarinen algoritmi voi käydä läpi syötteen kiinteän määrän kertoja.
Esimerkiksi seuraava algoritmi laskee taulukon lukujen summan $O(n)$-ajassa.

\begin{code}
int summa = 0;
for (int i = 0; i < n; i++) {
    summa += taulu[i];
}
\end{code}

\subsubsection{$O(n \log n)$ (järjestäminen)}

Aikavaativuus $O(n \log n)$ viittaa usein siihen,
että algoritmi järjestää taulukon,
koska tehokkaat algoritmit taulukon järjestämiseen
vievät aikaa $O(n \log n)$.
Esimerkiksi seuraava algoritmi laskee ajassa
$O(n \log n)$, montako eri alkiota taulukko sisältää.

\begin{code}
Arrays.sort(taulu);
int maara = 1;
for (int i = 1; i < n; i++) {
    if (taulu[i] != taulu[i-1]) maara++;
}
\end{code}

\subsubsection{$O(n^2)$ (neliöllinen)}

Neliöllinen algoritmi voi käydä läpi kaikki tavat valita
kaksi alkiota taulukosta.
Esimerkiksi seuraava $O(n^2)$-algoritmi tutkii, onko taulukossa
kahta lukua, joiden summa on $x$.

\begin{code}
boolean ok = false;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        if (taulu[i]+taulu[j] == x) ok = true;
    }
}
\end{code}

\subsubsection{$O(n^3)$ (kuutiollinen)}

Kuutiollinen algoritmi voi käydä läpi kaikki tavat valita
kolme alkiota taulukosta.
Esimerkiksi seuraava $O(n^3)$-algoritmi tutkii, onko taulukossa
kolmea lukua, joiden summa on $x$.

\begin{code}
boolean ok = false;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        for (int k = j+1; k < n; k++) {
            if (taulu[i]+taulu[j]+taulu[k] == x) ok = true;
        }
    }
}
\end{code}

\subsubsection{$O(2^n)$ (osajoukot)}

Aikavaativuus $O(2^n)$ viittaa usein siihen,
että algoritmi käy läpi syötteen alkioiden osajoukot.
Esimerkiksi alkioiden $\{1,2,3\}$ osajoukot ovat
$\emptyset$, $\{1\}$, $\{2\}$, $\{3\}$, $\{1,2\}$, $\{1,3\}$, $\{2,3\}$ ja $\{1,2,3\}$

\subsubsection{$O(n!)$ (permutaatiot)}

Aikavaativuus $O(n!)$ viittaa usein siihen,
että algoritmi käy läpi syötteen alkioiden permutaatiot.
Esimerkiksi alkioiden $\{1,2,3\}$ permutaatiot ovat
$(1,2,3)$, $(1,3,2)$, $(2,1,3)$, $(2,3,1)$, $(3,1,2)$ ja $(3,2,1)$.

\subsection{Tehokkuuden arviointi}

Mitä hyötyä on määrittää algoritmin aikavaativuus?
Hyötynä on, että se kertoo meille pika-arvion siitä,
kuinka \emph{hyvä} algoritmi on eli miten suuria syötteitä
sillä voi käsitellä tehokkaasti.
Kun meille kertyy kokemusta algoritmien suunnittelusta,
meille alkaa muodostua selkeä kuva,
mitä eri aikavaativuudet tarkoittavat käytännössä.

Aikavaativuutta voi ajatella samalla tavalla kuin vaikkapa
hotellin tähti\-luokitusta: se kertoo tiiviissä tilassa,
minkä tasoisesta algoritmista on kyse,
eikä meidän tarvitse perehtyä tarkemmin
algoritmin toimintaan.
Esimerkiksi jos kuulemme, että jonkin algoritmin aikavaativuus on $O(n \log n)$,
tiedämme heti, että kyseessä on mainio tehokas algoritmi,
jota voi käyttää myös suurten syötteiden käsittelyyn.

\begin{table}
\center
\begin{tabular}{rrr}
aikavaativuus & syötteen koko \\
\hline
$O(n)$ & $10^6$ & \\
$O(n \log n)$ & $10^5$ & \\
$O(n^2)$ & 2500 & \\
$O(n^3)$ & 250 & \\
$O(2^n)$ & 20 & \\
$O(n!)$ & 10 & \\
\end{tabular}
\caption{Kuinka suuren syötteen algoritmi voi käsitellä sekunnissa?}
\label{tab:algteh}
\end{table}

Yksi kiinnostava näkökulma algoritmin tehokkuuteen on,
miten suuren syötteen algoritmi voi käsitellä sekunnissa.
Taulukossa \ref{tab:algteh} on joitakin hyödyl\-lisiä arvioita
olettaen, että algoritmi suoritetaan tavallisella modernilla tietokoneella.
Esimerkiksi jos meillä on $O(n^2)$-algoritmi, voimme käsitellä sillä
tehokkaasti taulukon, jossa on muutamia tuhansia alkioita.
Jos tavoitteemme on käsitellä tehokkaasti suuria syötteitä,
meidän tulisi pyrkiä löytämään $O(n)$- tai $O(n \log n)$-aikainen
algoritmi.

Huomaa kuitenkin, että nämä luvut ovat vain arvioita ja algoritmin
todelliseen ajankäyttöön vaikuttavat monet asiat.
Saman algoritmin hyvä toteutus saattaa olla
kymmenen kertaa nopeampi kuin huono toteutus,
vaikka aikavaativuudet olisivat samat.
Tässä kirjassa analysoimme algoritmeja sekä aikavaativuuksien
avulla että mittaamalla todellisia suoritusaikoja.

\section{Esimerkki}

Seuraavaksi käymme läpi esimerkin, jossa vertailemme kahta
erilaista algoritmia samaan tehtävään.
Ensimmäinen algoritmi on suoraviivainen raa'an voiman
algoritmi, joka toimii ajassa $O(n^2)$.
Toinen algoritmi taas on tehokas algoritmi,
joka toimii ajassa $O(n)$.

Tehtävämme on seuraava: Annettuna on bittijono, jossa on $n$ bittiä.
Tehtävämme on laskea, monellako tavalla voimme valita kaksi kohtaa
niin, että vasen bitti on 0 ja oikea bitti on 1.
Esimerkiksi bittijonossa 01001 tapoja on neljä:
\underline{01}001, \underline{0}100\underline{1},
01\underline{0}0\underline{1} ja 010\underline{01}.

\subsubsection{$O(n^2)$-ratkaisu}

Suoraviivainen tapa ratkaista tehtävä on käydä läpi kaikki
mahdolliset tavat valita vasen ja oikea kohta ja laskea,
monessako tavassa vasen bitti on 0 ja oikea bitti on 1.
Seuraava metodi \texttt{laskeParit} toteuttaa tällaisen algoritmin.
Sille annetaan parametrina taulukko \texttt{bitit},
joka sisältää $n$ bittiä, ja metodi palauttaa vastauksena
tapojen määrän.

\begin{code}
public long laskeParit(int[] bitit) {
    int n = bitit.length;
    long tulos = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (bitit[i] == 0 && bitit[j] == 1) tulos++;
        }
    }
    return tulos;
}
\end{code}

Algoritmin aikavaativuus on $O(n^2)$, koska siinä on kaksi
sisäkkäistä silmukkaa, jotka käyvät läpi syötteen.

\subsubsection{$O(n)$-ratkaisu}

Kuinka voisimme ratkaista tehtävän tehokkaammin?
Meidän tulisi käytän\-nössä keksiä tapa, jolla saisimme
pois toisen silmukan koodista.

Tässä auttaa lähestyä ongelmaa hieman toisesta
näkökulmasta: kun olemme tietyssä kohdassa bittijonoa,
monellako tavalla voimme muodostaa parin,
jonka oikea bitti on nykyisessä kohdassamme?
Jos olemme bitin 0 kohdalla, pareja ei ole yhtään,
mutta jos bittinä on 1, voimme valita minkä tahansa
vasemmalla puolella olevan bitin 0 pariin.

Tämän havainnon ansiosta meidän riittää käydä läpi
bittijono kerran vasemmalta oikealle ja pitää kirjaa,
montako nollabittiä olemme nähneet.
Sitten jokaisen ykkösbitin kohdalla kasvatamme
vastausta tällä nollabittien määrällä.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
public long laskeParit(int[] bitit) {
    int n = bitit.length;
    long tulos = 0;
    int nollat = 0;
    for (int i = 0; i < n; i++) {
        if (bitit[i] == 0) nollat++;
        if (bitit[i] == 1) tulos++;
    }
    return tulos;
}
\end{code}

Algoritmissa on vain yksi silmukka, joka käy syötteen läpi,
joten sen aikavaativuus on $O(n)$.

\subsubsection{Algoritmien vertailua}

\section{Lisää algoritmien analysoinnista}

Aikavaativuuksissa käyttämämme $O$-merkintä on yksi monista merkinnöistä,
joiden avulla voimme arvioida funktioiden kasvunopeutta.
Algoritmien analysoinnissa tärkeimmät merkinnät ovat:

\begin{itemize}
\item \emph{Yläraja}: Funktio $g(n)$ on luokkaa $O(f(n))$, jos on olemassa vakiot $c$ ja $n_0$
niin, että $g(n) \le c f(n)$ aina kun $n \ge n_0$.
\item \emph{Alaraja}: Funktio $g(n)$ on luokkaa $\Omega(f(n))$, jos on olemassa vakiot $c$ ja $n_0$
niin, että $g(n) \ge c f(n)$ aina kun $n \ge n_0$.
\item \emph{Tarkka arvio}: Funktio $g(n)$ on luokkaa $\Theta(f(n))$, jos se on sekä luokkaa $O(f(n))$
että luokkaa $\Omega(f(n))$.
\end{itemize}

Kun sanomme, että algoritmi toimii ajassa $O(f(n))$, tarkoitamme, että se suorittaa
\emph{pahimmassa tapauksessa} enintään $O(f(n))$ komentoa.
Tämä on yleensä hyvä tapa ilmoittaa algoritmin tehokkuus,
koska silloin annamme takuun siitä, että algoritmin ajankäytöllä on tietty yläraja,
vaikka syöte olisi valittu mahdollisimman hankalaksi.

Tarkastellaan esimerkkinä seuraavaa algoritmia, joka laskee
taulukon lukujen summan:

\begin{code}
int summa = 0;
for (int i = 0; i < n; i++) {
    summa += taulu[i];
}
\end{code}

Tämä algoritmi toimii samalla tavalla riippumatta taulukon sisällöstä,
koska se käy aina läpi koko taulukon.
Niinpä yläraja ajankäytölle on $O(n)$ ja alaraja ajankäytölle on $\Omega(n)$,
joten voimme sanoa, että algoritmi vie aikaa $\Theta(n)$ sekä pahimmassa
että parhaassa tapauksessa.

Tarkastellaan sitten seuraavaa algoritmia, joka selvittää,
onko taulukossa alkiota $x$:

\begin{code}
ok = false;
for (int i = 0; i < n; i++) {
    if (taulu[i] == x) {
        ok = true;
        break;
    }
}
\end{code}

Tässä algoritmin pahin ja paraus tapaus eroavat.
Ajankäytön yläraja on $O(n)$, koska algoritmi joutuu käymään
läpi kaikki taulukon alkiot silloin, kun alkio $x$
ei esiinny taulukossa.
Toisaalta ajankäytön alaraja on $\Omega(1)$,
koska jos alkio $x$ on taulukon ensimmäinen alkio,
algoritmi pysähtyy heti taulukon alussa.
Voimme myös sanoa, että algoritmi suorittaa pahimmassa
tapauksessa $\Theta(n)$ komentoa ja parhaassa tapauksessa
$\Theta(1)$ komentoa.

Huomaa, että $O$-merkinnän antama yläraja voi olla mikä tahansa yläraja.
On siis oikein sanoa esimerkiksi, että taulukon lukujen summan
laskeva algoritmi vie aikaa $O(n^2)$, vaikka on olemassa parempi yläraja $O(n)$.
Miksi sitten käytämme $O$-merkintää, vaikka voisimme ilmaista tarkan
ajankäytön $\Theta$-merkinnällä?
Tämä on vakiintunut ja käytännössä toimiva tapa.
Olisi hyvin harhaanjohtavaa antaa yläraja $O(n^2)$,
jos näemme suoraan, että aikaa kuluu vain $O(n)$.

Asiaa voi ajatella niin, että $O$-merkintää käytetään algoritmin
markkinoinnissa. Jos annamme liian suuren ylärajan, algoritmista
tulee väärä käsitys.
Vertauksena jos myymme urheiluautoa, jonka huippunopeus on 250 km/h,
on sinänsä paikkansa pitävä väite, että autolla pystyy ajamaan 100 km/h.
Meidän ei kuitenkaan kannata ilmoittaa tällaista rajaa,
vaan kertoa, että autolla pystyy ajamaan 250 km/h.

Merkintöjä $O$, $\Omega$ ja $\Theta$ voi käyttää
kaikenlaisissa yhteyksissä, ei vain algoritmin ajankäytön arvoinnissa.
Esimerkiksi voimme sanoa, että algoritmi suorittaa silmukkaa $O(\log n)$ kierrosta
taulukossa on $O(n^2)$ alkiota.
