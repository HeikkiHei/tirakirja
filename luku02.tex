\chapter{Tehokkuus}

\section{Aikavaativuus}

Voimme arvioida algoritmin tehokkuutta laskemalla,
montako kertaa siinä olevia komentoja suoritetaan.
Tavoitteena on arvioida tehokkuutta suhteessa
syötteen kokoon $n$.
Esimerkiksi jos syötteenä on taulukko,
$n$ on taulukon koko,
ja jos syötteenä on merkkijono,
$n$ on merkkijonon pituus.

Tarkastellaan esimerkkinä seuraavaa algoritmia,
joka laskee, montako kertaa luku $x$ esiintyy
$n$-kokoisessa taulukossa.

\begin{code}[numbers=left]
int maara = 0;
for (int i = 0; i < n; i++) {
    if (luvut[i] == x) {
        maara++;
    }
}
\end{code}

Tässä algoritmissa oleelliset komennot ovat riveillä
1, 3 ja 4.
Rivin 1 komento suoritetaan vain kerran algoritmin alussa.
Rivin 3 komento suoritetaan $n$ kertaa jokaisella silmukan
kierroksella.
Rivin 4 komento taas suoritetaan $0 \dots n$
kertaa riippuen siitä, kuinka usein
luku $x$ esiintyy taulukossa.
Algoritmissa suoritetaan siis vähintään $n+1$ ja enintään $2n+1$
komentoa.

Näin tarkka analyysi ei ole kuitenkaan yleensä tarpeen,
vaan meille riittää usein määrittää karkea ajankäytön yläraja.
Sanomme, että algoritmi toimii ajassa $O(f(n))$ eli sen
\emph{aikavaativuus} on $O(f(n))$, jos se suorittaa
enintään $c f(n)$ komentoa aina silloin kun $n \ge n_0$,
missä $c$ ja $n_0$ ovat vakioita.
Esimerkiksi yllä oleva algoritmi toimii ajassa $O(n)$,
koska se suorittaa selkeästi enintään $3n$ komentoa
kaikilla $n$:n arvoilla.

Aikavaativuden mukavana puolena on, että yleensä voimme
määrittää aikavaativuuden hyvin helposti algoritmin
rakenteesta. Tutustumme seuraavaksi laskusääntöihin,
joiden avulla tämä on mahdollista.

\subsection{Aikavaativuuden laskusäännöt}

Jos algoritmissa ei ole silmukoita vaan vain
yksittäisiä komentoja, sen aikavaativuus on $O(1)$.
Näin on esimerkiksi seuraavassa algoritmissa.

\begin{code}
c = a+b;
b = a;
if (a > b) a++;
\end{code}

Merkitsemme \texttt{...} koodia,
jonka aikavaativuus on $O(1)$.
Jos algoritmissa on yksi silmukka,
joka suorittaa $n$ askelta,
sen aikavaativuus on $O(n)$:

\begin{code}
for (int i = 0; i < n; i++) {
    ...
}
\end{code}

Jos tällaisia silmukoita on kaksi sisäkkäin,
aikavaativuus on $O(n^2)$:

\begin{code}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        ...
    }
}
\end{code}

Yleisemmin jos algoritmissa on vastaavalla tavalla
$k$ sisäkkäistä silmukkaa,
sen aikavaativuus on $O(n^k)$.

Huomaa, että vakiokertoimet ja matalammat termit eivät vaikuta aikavaativuuteen.
Esimerkiksi seuraavia koodeja suoritetaan $2n$ ja $n-1$ kertaa,
mutta kummankin koodin aikavaativuus on $O(n)$.

\begin{code}
for (int i = 0; i < 2*n; i++) {
    ...
}
\end{code}

\begin{code}
for (int i = 0; i < n-1; i++) {
    ...
}
\end{code}

Jos algoritmissa on peräkkäisiä osuuksia, kokonaisaikavaativuus on suurin
yksittäinen aikavaativuus. Esimerkiksi seuraavan algoritmin aikavaativuus on $O(n^2)$,
koska sen osuudet ovat $O(n)$, $O(n^2)$ ja $O(n)$.

\begin{code}
for (int i = 0; i < n; i++) {
    ...
}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        ...
    }
}
for (int i = 0; i < n; i++) {
    ...
}
\end{code}

Joskus aikavaativuus riippuu useammasta tekijästä,
jolloin kaavassa on monta muuttujaa.
Esimerkiksi seuraavan koodin aikavaativuus on $O(nm)$:

\begin{code}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        ...
    }
}
\end{code}

\subsection{Yleisiä aikavaativuuksia}

Tietyt aikavaativuudet esiintyvät usein algoritmien analyysissa.
Seuraavaksi käymme läpi joukon tällaisia aikavaativuuksia.

\subsubsection{$O(1)$ (vakioaikainen)}

Vakioaikainen algoritmi suorittaa vain kiinteän määrän komentoja.
Tyypillinen vakioaikainen algoritmi on kaava, joka laskee
suoraan vastauksen. Esimerkiksi seuraava algoritmi laskee
summan $1+2+\dots+n$ vakioajassa:

\begin{code}
summa = n*(n+1)/2;
\end{code}

\subsubsection{$O(\log n)$ (logaritminen)}

Logaritminen algoritmi puolittaa usein syötteen koon
joka askeleella. Tyypillinen esimerkki logaritmisesta algoritmista
on binäärihaku, joka etsii alkiota järjestetystä taulukosta.

\begin{code}
int a = 0;
int b = n-1;
while (a <= b) {
    int c = (a+b)/2;
    if (taulu[c] == x) break;
    if (taulu[c] < x) a = c+1;
    else b = c-1;
}
\end{code}

\subsubsection{$O(n)$ (lineaarinen)}

Lineaarinen algoritmi voi käydä läpi syötteen kiinteän määrän kertoja.
Esimerkiksi seuraava algoritmi laskee taulukon lukujen summan $O(n)$-ajassa.

\begin{code}
int summa = 0;
for (int i = 0; i < n; i++) {
    summa += taulu[i];
}
\end{code}

\subsubsection{$O(n \log n)$ (järjestäminen)}

Aikavaativuus $O(n \log n)$ viittaa usein siihen,
että algoritmi järjestää taulukon,
koska tehokkaat algoritmit taulukon järjestämiseen
vievät aikaa $O(n \log n)$.
Esimerkiksi seuraava algoritmi laskee ajassa
$O(n \log n)$, montako eri alkiota taulukko sisältää.

\begin{code}
Arrays.sort(taulu);
int maara = 1;
for (int i = 1; i < n; i++) {
    if (taulu[i] != taulu[i-1]) maara++;
}
\end{code}

\subsubsection{$O(n^2)$ (neliöllinen)}

Neliöllinen algoritmi voi käydä läpi kaikki tavat valita
kaksi alkiota taulukosta.
Esimerkiksi seuraava $O(n^2)$-algoritmi tutkii, onko taulukossa
kahta lukua, joiden summa on $x$.

\begin{code}
boolean ok = false;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        if (taulu[i]+taulu[j] == x) ok = true;
    }
}
\end{code}

\subsubsection{$O(n^3)$ (kuutiollinen)}

Kuutiollinen algoritmi voi käydä läpi kaikki tavat valita
kolme alkiota taulukosta.
Esimerkiksi seuraava $O(n^3)$-algoritmi tutkii, onko taulukossa
kolmea lukua, joiden summa on $x$.

\begin{code}
boolean ok = false;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        for (int k = j+1; k < n; k++) {
            if (taulu[i]+taulu[j]+taulu[k] == x) ok = true;
        }
    }
}
\end{code}

\subsubsection{$O(2^n)$ (osajoukot)}

Aikavaativuus $O(2^n)$ viittaa usein siihen,
että algoritmi käy läpi syötteen alkioiden osajoukot.
Esimerkiksi alkioiden $\{1,2,3\}$ osajoukot ovat
$\emptyset$, $\{1\}$, $\{2\}$, $\{3\}$, $\{1,2\}$, $\{1,3\}$, $\{2,3\}$ ja $\{1,2,3\}$

\subsubsection{$O(n!)$ (permutaatiot)}

Aikavaativuus $O(n!)$ viittaa usein siihen,
että algoritmi käy läpi syötteen alkioiden permutaatiot.
Esimerkiksi alkioiden $\{1,2,3\}$ permutaatiot ovat
$(1,2,3)$, $(1,3,2)$, $(2,1,3)$, $(2,3,1)$, $(3,1,2)$ ja $(3,2,1)$.

\subsection{Aikavaativuuksien käyttö}

Mitä hyötyä on määrittää algoritmin aikavaativuus?
Hyötynä on, että se kertoo meille pika-arvion siitä,
kuinka \emph{hyvä} algoritmi on eli miten suuria syötteitä
sillä voi käsitellä tehokkaasti.
Kun meille kertyy kokemusta algoritmien suunnittelusta,
meille alkaa muodostua selkeä kuva,
mitä eri aikavaativuudet tarkoittavat käytännössä.

Aikavaativuutta voi ajatella samalla tavalla kuin vaikkapa
hotellin tähti\-luokitusta: se kertoo tiiviissä tilassa,
minkä tasoisesta algoritmista on kyse,
eikä meidän tarvitse perehtyä tarkemmin
algoritmin toimintaan.
Esimerkiksi jos kuulemme, että jonkin algoritmin aikavaativuus on $O(n \log n)$,
tiedämme heti, että kyseessä on mainio tehokas algoritmi,
jota voi käyttää myös suurten syötteiden käsittelyyn.

\begin{table}
\center
\begin{tabular}{rrr}
aikavaativuus & syötteen koko \\
\hline
$O(n)$ & $10^6$ & \\
$O(n \log n)$ & $10^5$ & \\
$O(n^2)$ & 2500 & \\
$O(n^3)$ & 250 & \\
$O(2^n)$ & 20 & \\
$O(n!)$ & 10 & \\
\end{tabular}
\caption{Kuinka suuren syötteen algoritmi voi käsitellä sekunnissa?}
\label{tab:algteh}
\end{table}

Yksi kiinnostava näkökulma algoritmin tehokkuuteen on,
miten suuren syötteen algoritmi voi käsitellä sekunnissa.
Taulukossa \ref{tab:algteh} on joitakin hyödyl\-lisiä arvioita
olettaen, että algoritmi suoritetaan tavallisella modernilla tietokoneella.
Esimerkiksi jos meillä on $O(n^2)$-algoritmi, voimme käsitellä sillä
tehokkaasti taulukon, jossa on muutamia tuhansia alkioita.
Jos tavoitteemme on käsitellä tehokkaasti suuria syötteitä,
meidän tulisi pyrkiä löytämään $O(n)$- tai $O(n \log n)$-aikainen
algoritmi.

Huomaa kuitenkin, että nämä luvut ovat vain arvioita ja algoritmin
todelliseen ajankäyttöön vaikuttavat monet asiat.
Saman algoritmin hyvä toteutus saattaa olla
kymmenen kertaa nopeampi kuin huono toteutus,
vaikka aikavaativuudet olisivat samat.
Tässä kirjassa analysoimme algoritmeja sekä aikavaativuuksien
avulla että mittaamalla todellisia suoritusaikoja.

\section{Esimerkkejä}
