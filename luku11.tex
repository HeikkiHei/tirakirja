\chapter{Lyhimmät polut}

Lyhimmän polun etsiminen on keskeinen verkko-ongelma,
jolle on helppoa keksiä käytännön sovelluksia.
Esimerkiksi voimme haluta selvittää,
mikä on nopein reitti kahden katuosoitteen välillä
tai mikä on halvin tapa lentää kaupungista toiseen.
Näissä ja muissa sovelluksissa on tärkeää,
että löydämme lyhimmän polun tehokkaasti.

Olemme käyttäneet aiemmin leveyshakua lyhimmän
polun etsimiseen.
Tämä onkin hyvä ratkaisu silloin, kun haluamme löytää polun,
jonka kaarten määrä on pienin.
Tässä luvussa keskitymme kuitenkin vaikeampaan
tilanteeseen, jossa verkko on \emph{painotettu}
ja haluamme löytää polun,
jossa painojen summa on pienin.
Esimerkiksi kuvassa \ref{fig:verpai}
lyhin polku solmusta $1$ solmuun $5$ on
$1 \rightarrow 3 \rightarrow 4 \rightarrow 5$,
jonka pituus on $2+4+3=9$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:2] {} (3);
\path[draw,thick,->] (1) -- node[font=\small,label=above:9] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=above:8] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=right:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\node at (3,-1) {(a)};
\end{scope}
\begin{scope}[xshift=8cm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:2] {} (3);
\path[draw,thick,->] (1) -- node[font=\small,label=above:9] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=above:8] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=right:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\path[draw,thick,->,red,line width=1.5pt] (1) -- (3);
\path[draw,thick,->,red,line width=1.5pt] (3) -- (4);
\path[draw,thick,->,red,line width=1.5pt] (4) -- (5);

\node at (3,-1) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Painotettu verkko. (b) Lyhin polku solmusta $1$ solmuun $5$.
}
\label{fig:verpai}
\end{figure}

Painotetussa verkossa lyhimmän polun etsimiseen
on monia algoritmeja, joilla on erilaisia ominaisuuksia.
Tutustumme ensin Bellman–Fordin algoritmiin,
joka etsii lyhimmät polut annetusta lähtösolmusta
kaikkiin verkon solmuihin.
Tämän jälkeen opimme Dijkstran algoritmin,
joka tekee saman tehokkaammin
olettaen, että verkossa ei ole negatiivisen painoisia kaaria.
Lopuksi käsitte\-lemme Floyd–Warshallin algoritmin,
joka etsii samanaikaisesti lyhimmät polut \emph{kaikkien}
verkon solmujen välillä.

\section{Bellman–Fordin algoritmi}

Bellman–Fordin algoritmi etsii lyhimmät polut
annetusta lähtösolmusta kaikkiin verkon solmuihin.
Algoritmi muodostaa taulukon, joka kertoo jokaiselle
solmulle sen \emph{etäisyyden} eli lyhimmän polun pituuden lähtösolmusta.
Algoritmi toimii missä tahansa verkossa,
kunhan verkossa ei ole negatiivista sykliä eli sykliä,
jonka painojen summa on negatiivinen.

Bellman–Fordin algoritmi pitää yllä \emph{arvioita}
solmujen etäisyyksistä niin,
että aluksi etäisyys lähtösolmuun on 0 ja etäisyys
kaikkiin muihin solmuihin on ääretön.
Tämän jälkeen algoritmi alkaa parantaa etäisyyksiä
etsimällä verkosta kaaria, joiden kautta kulkeminen
lyhentää polkuja.
Jokaisessa vaiheessa algoritmi etsii kaaren $a \rightarrow b$,
jolle pätee, että pääsemme solmuun $b$ lyhempää polkua
kulkemalla kaarella solmusta $a$.
Kun mitään etäisyysarviota ei voi enää parantaa,
algoritmi päättyy ja kaikki etäisyydet vastaavat
todellisia lyhimpien polkujen pituuksia.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}{0}{8}{\infty}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}{0}{8}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}{0}{6}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\verkko{6}{0}{6}{2}{13}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-11cm]
\verkko{7}{0}{6}{2}{12}{9}
\path[draw=red,thick,->,line width=1.5pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-11cm,xshift=6.5cm]
\verkko{8}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Bellman–Fordin algoritmin toiminnasta.}
\label{fig:belfor}
\end{figure}

Kuva \ref{fig:belfor} näyttää esimerkin Bellman–Fordin algoritmin toiminnasta,
kun lähtösolmuna on solmu $1$.
Jokaisen solmun vieressä on ilmoitettu sen etäisyysarvio:
aluksi etäisyys solmuun 1 on 0 ja etäisyys kaikkiin muihin solmuihin on ääretön.
Jokainen etäisyyden muutos näkyy kuvassa omana vaiheenaan.
Ensin parannamme etäisyyttä solmuun 2
kulkemalla kaarta $1 \rightarrow 2$,
jolloin etäisyydeksi tulee $8$.
Sitten parannamme etäisyyttä solmuun $3$
kulkemalla kaarta $1 \rightarrow 3$,
jolloin solmun uudeksi etäisyydeksi tulee $2$.
Jatkamme samalla tavalla, kunnes emme voi enää parantaa
mitään etäisyyttä, ja vaiheen $8$ jälkeen kaikki etäisyydet
vastaavat lyhimpien polkujen pituuksia.
Esimerkiksi solmun 4 etäisyys on lopuksi 11,
koska lyhin polku solmusta $1$ solmuun $4$ on
$1 \rightarrow 3 \rightarrow 2 \rightarrow 4$,
jonka pituus on $2+4+5=11$.

\subsection{Algoritmin toteutus}

Toteutamme Bellman–Fordin algoritmin niin,
että se muodostuu kierroksista,
joista jokainen käy läpi kaikki verkon kaaret
ja koettaa parantaa etäisyys\-arvioita niiden avulla.
Jos jonkin kierroksen aikana mikään etäisyysarvio ei parane,
algoritmi päättyy.

Koska algoritmi käy joka kierroksella läpi
kaikki verkon kaaret,
hyvä tapa tallentaa verkko on kaarilista,
jossa jokaisesta kaaresta on tiedossa
alku- ja loppusolmu sekä paino.
Lisäksi tarvitsemme taulukon etäisyyksille,
joka alustetaan seuraavasti:

\begin{code}
for (int i = 1; i <= n; i++) {
    if (i == alku) etaisyys[i] = 0;
    else etaisyys[i] = INF;
}
\end{code}

Tässä \texttt{INF} on vakio, joka edustaa ääretöntä.
Käytännössä tämä on jokin suuri luku,
joka on suurempi, kuin mikä tahansa todellinen etäisyys.

Tämän jälkeen voimme toteuttaa algoritmin seuraavasti:

\begin{code}
while (true) {
    boolean muutos = false;
    for (Kaari kaari : kaaret) {
        int vanha = etaisyys[kaari.loppu];
        int uusi = etaisyys[kaari.alku]+kaari.paino;
        if (uusi < vanha) {
            muutos = true;
            etaisyys[kaari.loppu] = uusi;
        }
    }
    if (!muutos) break;
}
\end{code}


\subsection{Algoritmin analyysi}

Miksi Bellman–Fordin algoritmi toimii ja miten tehokas se on?
Jotta voimme vastata näihin kysymyksiin,
tarvitsemme kaksi havaintoa koskien verkon lyhimpiä polkuja.

Ensimmäinen havainto on, että jos lyhin polku solmusta $s_1$ solmuun $s_k$ on
$s_1 \rightarrow s_2 \rightarrow \dots \rightarrow s_k$,
niin myös lyhin polku solmusta $s_1$ solmuun $s_2$ on $s_1 \rightarrow s_2$,
lyhin polku solmusta $s_1$ solmuun $s_3$ on $s_1 \rightarrow s_2 \rightarrow s_3$, jne.,
eli jokainen polun alkuosa on myös lyhin polku vastaavaan solmuun.
Jos näin ei olisi, voisimme parantaa lyhintä polkua solmusta $s_1$ solmuun $s_k$
parantamalla jotain polun alkuosaa, mikä aiheuttaisi ristiriidan.

Toinen havainto on,
että $n$ solmun verkossa jokainen lyhin polku voi
sisältää enintään $n-1$ kaarta,
kun oletamme, että verkossa ei ole negatiivista sykliä.
Jos polkuun kuuluisi $n$ tai enemmän kaaria,
jokin solmu esiintyisi polulla monta kertaa.
Tämä ei ole kuitenkaan mahdollista,
koska ei olisi järkeä kulkea monta kertaa saman solmun kautta,
kun haluamme saada aikaan lyhimmän polun.

Tarkastellaan nyt, mitä tapahtuu algoritmin kierroksissa.
Ensimmäisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään yksi kaari.
Toisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään kaksi kaarta.
Sama jatkuu, kunnes $n-1$ kierroksen jälkeen olemme löytäneet
lyhimmät polut, joissa on enintään $n-1$ kaarta.
Koska missään lyhimmässä polussa ei voi olla enempää kaaria,
olemme löytäneet kaikki lyhimmät polut.
Algoritmi suorittaa siis enintään $n-1$ kierrosta,
joista jokainen käy läpi kaikki verkon kaaret ajassa $O(m)$.
Niinpä algoritmi löytää lyhimmät polut ajassa $O(nm)$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:1] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:3] {} (3);
\path[draw,thick,<-] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=left:$-7$] {} (4);
\path[draw,thick,<-] (2) -- node[font=\small,label=above:2] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);
\end{tikzpicture}
\end{center}
\caption{Negatiivinen sykli $2 \rightarrow 4 \rightarrow 5 \rightarrow 2$,
jonka avulla voimme lyhentää polkuja loputtomasti.}
\label{fig:belsyk}
\end{figure}

Mitä tapahtuu sitten, jos verkossa on negatiivinen sykli?
Esimerkiksi kuvan \ref{fig:belsyk} verkossa on negatiivinen sykli
$2 \rightarrow 4 \rightarrow 5 \rightarrow 2$, jonka paino on $-2$.
Tässä tilanteessa Bellman–Fordin algoritmi jää jumiin, koska se pystyy parantamaan
loputtomasti syklin kautta kulkevia polkuja.
Oikeastaan ongelma on siinä, että lyhin polku ei ole mielekäs käsite,
jos polun osana on negatiivinen sykli.
Voimme kuitenkin havaita negatiivisen syklin siitä,
että jokin etäisyys paranee vielä $n-1$ kierroksen jälkeen.

\section{Dijkstran algoritmi}

Dijkstran algoritmi on Bellman–Fordin algoritmin tehostettu versio,
jonka toiminta perustuu oletukseen, että verkossa ei ole
negatiivisen painoisia kaaria.
Bellman–Fordin algoritmin tapaan Dijkstran algoritmi pitää
yllä arvioita etäisyyksistä lähtösolmusta muihin solmuihin.
Erona on kuitenkin tapa, miten Dijkstran algoritmi parantaa etäisyyksiä.

Dijkstran algoritmissa verkon solmut kuuluvat kahteen luokkaan:
käsitte\-lemättömiin ja käsiteltyihin.
Aluksi kaikki solmut ovat käsittelemättömiä.
Algoritmi etsii jokaisessa vaiheessa solmun, jota ei ole vielä
käsitelty ja jonka etäisyysarvio on pienin.
Sitten algoritmi käy läpi kaikki solmusta lähtevät kaaret ja
koettaa parantaa etäisyyksiä niiden avulla.
Tämän jälkeen solmu on käsitelty eikä sen etäisyys enää muutu,
eli aina kun olemme käsitelleet solmun,
olemme saaneet selville sen lopullisen etäisyyden.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\verkko{2}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\verkko{3}{0}{6}{2}{\infty}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\verkko{4}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\verkko{5}{0}{6}{2}{11}{9}
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\node[draw, circle, fill=lightgray] (4) at (4,0) {$4$};
\verkko{6}{0}{6}{2}{11}{9}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Dijkstran algoritmin toiminnasta.}
\label{fig:dijalg}
\end{figure}

Kuva \ref{fig:dijalg} näyttää esimerkin Dijkstran algoritmin
toiminnasta.
Solmun harmaa väri tarkoittaa, että se on käsitelty.
Alussa valitsemme käsittelyyn solmun 1, koska sen etäisyys 0 on pienin.
Sitten jäljellä ovat solmut 2, 3, 4 ja 5,
joista valitsemme käsittelyyn solmun 3, jonka etäisyys 2 on pienin.
Tämän jälkeen valitsemme käsittelyyn solmun 2,
jonka etäisyys on 6.
Sama jatkuu, kunnes olemme käsitelleet kaikki verkon solmut.

\subsection{Algoritmin toteutus}

Dijkstran algoritmi muodostuu $n$ vaiheesta,
jossa jokaisessa etsimme verkosta seuraavaksi käsiteltävän
solmun ja käymme läpi siitä lähtevät kaaret.
Koska haluamme saada aikaan tehokkaan toteutuksen,
meidän täytyy pystyä löytämään joka vaiheessa
seuraavaksi käsiteltävä solmu tehokkaasti.
Tämä onnistuu sopivan tietorakenteen avulla.

Tarvitsemme käytännössä tietorakenteen,
joka pitää yllä joukkoa jäljellä olevista
käsittelemättömistä solmuista ja josta voimme
etsiä tehokkaasti solmun, jonka etäisyys on pienin.
Tähän tarkoitukseen sopivia tietorakenteita ovat
binäärihakupuu ja keko.
Yleensä Dijkstran algoritmi toteutetaan käyttäen kekoa,
koska keon ominaisuudet riittävät ja sen vakiokertoimet
ovat binäärihakupuuta pienemmät.

Oletamme seuraavaksi, että haluamme muodostaa lyhimmät
polut lähtö\-solmusta $1$ alkaen.
Tallennamme kekoon solmuja, joista on tiedossa
etäisyys ja solmun tunnus,
järjestettynä etäisyyden mukaan pienimmästä suurimpaan.
Merkitsemme aluksi taulukkoon, että solmun $1$ etäisyys on $0$
ja lisäämme sitä vastaavan solmun kekoon.
Lisäksi merkitsemme taulukkoon, että kaikkien muiden
solmujen etäisyys on ääretön.

\begin{code}
etaisyys[1] = 0;
keko.push(new Solmu(0,1));
for (int i = 2; i <= n; i++) {
    etaisyys[i] = INF;
}
\end{code}

Tämän jälkeen haemme joka askeleella keosta solmun,
jonka etäisyys on pienin.
Jos solmu on jo käsitelty, emme tee mitään.
Muuten käymme läpi kaikki solmusta lähtevät kaaret
ja tarkastamme, voimmeko parantaa etäisyyksiä
niiden avulla.
Aina kun voimme parantaa etäisyyttä,
lisäämme uuden etäisyyden kekoon.

\begin{code}
while (!keko.empty()) {
    Solmu solmu = keko.pop();
    if (kasitelty[solmu.id]) continue;
    kasitelty[solmu.id] = true;
    for (Kaari kaari : verkko[solmu]) {
        int vanha = etaisyys[kaari.kohde];
        int uusi = etaisyys[solmu]+kaari.paino;
        if (vanha < uusi) {
            etaisyys[kaari.kohde] = uusi;
            keko.push(new Solmu(uusi,kaari.kohde));
        }
    }
}
\end{code}

Huomaa, että keossa voi olla \emph{useita} etäisyyksiä
samalle solmulle, koska lisäämme kekoon uuden solmun
aina etäisyyden parantuessa.
Käsittelemme näistä kuitenkin vain pienimmän etäisyyden solmun.

\subsection{Algoritmin analyysi}

Dijkstran algoritmi on ahne algoritmi,
koska se valitsee joka vaiheessa käsitte\-lyyn solmun,
jonka etäisyys on pienin.
Miten voimme olla varmoja, että algoritmi löytää lyhimmät
polut kaikissa tilanteissa?

Algoritmin toiminta perustuu oletukseemme,
että verkossa ei ole negatiivisen painoisia kaaria.
Voimme ajatella asiaa käänteisesti: jos pienimmän etäisyyden
käsittelemättömän solmun
etäisyys ei olisi lopullinen, pystyisimme parantamaan
sitä kulkemalla solmuun jonkin toisen käsittelemättömän solmun kautta.
Kuitenkin kaikkien muiden tarjolla olevien solmujen etäisyy\-det
ovat suurempia tai yhtä suuria eivätkä etäisyydet voi lyhentyä,
koska verkossa ei ole negatiivisen painoisia kaaria.
Tästä syystä voimme turvallisesti valita pienimmän etäisyyden
solmun ja käsitellä sen.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\node[draw, circle] (1) at (0,1) {$1$};
\node[draw, circle] (2) at (2.5,2) {$2$};
\node[draw, circle] (3) at (2.5,0) {$3$};
\node[draw, circle] (4) at (5,1) {$4$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:7] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=above:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:$-4$] {} (4);
\end{tikzpicture}
\end{center}
\caption{Dijkstran algoritmi ei toimi oikein verkossa
negatiivisen kaaren takia.}
\label{fig:dijneg}
\end{figure}

Jos verkossa on negatiivinen kaari,
Dijkstran algoritmi ei toimi välttä\-mättä oikein.
Kuva \ref{fig:dijneg} näyttää esimerkin tällaisesta verkosta.
Dijkstran algoritmi seuraa ahneesti ylempää polkua ja toteaa,
että pienin etäisyys solmusta 1 solmuun 4 on 8.
Kuitenkin parempi tapa olisi kulkea alempaa polkua,
jolloin negatiivisen kaaren asiosta pienin etäisyys on vain 3.

Seuraava kysymys on, kuinka nopeasti algoritmi toimii.
Algoritmin aikana käsittelemme vuorollaan kunkin verkon solmun
ja käymme läpi siitä lähtevät kaaret, missä kuluu aikaa $O(n+m)$.
Pahimmassa tapauksessa lisäämme jokaisen kaaren kohdalla
kekoon uuden alkion, eli lisäykset kekoon vievät aikaa $O(m \log m)$.
Toisaalta poistamme kaikki alkiot aikanaan keosta,
mihin menee myös aikaa $O(m \log m)$.
Kun yhdistämme nämä tiedot, saamme algoritmin
kokonaisaikavaativuudeksi $O(n + m \log m)$.

\section{Floyd–Warshallin algoritmi}

Floyd-Warshallin algoritmi muodostaa verkolle \emph{etäisyysmatriisin},
jossa rivin $a$ sarakkeessa $b$ on lyhimmän polun pituus
solmusta $a$ solmuun $b$.
Algoritmi eroaa siis Bellman–Fordin ja Dijkstran algoritmeista
siinä, että se laskee samalla kertaa \emph{kaikki} etäisyydet verkossa
eikä meidän tarvitse valita, mistä solmusta lähdemme liikkeelle.

Algoritmin alustaa ensin etäisyysmatriisin niin,
että siihen on merkitty vain etäisyydet,
jotka toteutuvat kulkemalla yksittäistä kaarta,
ja kaikissa muissa matriisin kohdissa on arvo ääretön.
Sitten algoritmi suorittaa $n$ kierrosta,
jotka on numeroitu $1,2,\dots,n$.
Kierroksella $k$ algoritmi etsii polkuja, joissa on välisolmuna
solmu $k$ sekä mahdollisesti solmuja $1,2,\dots,k-1$.
Jos tällainen polku parantaa etäisyyttä,
päivitämme uuden etäisyyden matriisiin.
Viimeisen kierroksen jälkeen jokainen solmu on voinut olla
välisolmuna poluilla, jolloin olemme saaneet selville
kaikki lyhimmät polut.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\newcommand\verkko[5]{
\begin{scope}[xshift=0.75cm,yshift=2cm]
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (2.5,0) {$2$};
\node[draw, circle, fill=#4] (3) at (0,-2.5) {$3$};
\node[draw, circle, fill=#5] (4) at (2.5,-2.5) {$4$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:1] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=right:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:4] {} (3);
\end{scope}

\foreach \x in {1,2,3,4} \node at (-0.5,-2.5-\x) {\x};
\foreach \x in {1,2,3,4} \node at (-0.5+\x,-2.5) {\x};
\draw (0,-3) grid (4,-7);

\node at (2,-8) {kierros #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/\infty} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/\infty} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\end{scope}
\begin{scope}[xshift=5.5cm]
\verkko{2}{white}{lightgray}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (3.5,-3.5) {$8$};
\node[color=red] at (3.5,-5.5) {$5$};
\end{scope}
\begin{scope}[xshift=11cm]
\verkko{3}{white}{white}{lightgray}{white}
\foreach \x/\v in {1/\infty,2/,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/4,4/} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-3.5) {$3$};
\node[color=red] at (1.5,-6.5) {$6$};
\node[color=red] at (3.5,-6.5) {$9$};
\end{scope}
\begin{scope}[xshift=16.5cm]
\verkko{4}{white}{white}{white}{lightgray}
\foreach \x/\v in {1/\infty,2/3,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/6,3/4,4/9} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-4.5) {$9$};
\node[color=red] at (2.5,-4.5) {$7$};
\node[color=red] at (2.5,-5.5) {$9$};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Floyd–Warshallin algoritmin toiminnasta.}
\label{fig:flowar}
\end{figure}

Kuva \ref{fig:flowar} näyttää esimerkin Floyd–Warshallin algoritmin toiminnasta.
Kierroksella 1 etsimme polkuja, joissa solmu 1 on välisolmuna.
Tällaisia polkuja ei ole, koska solmuun 1 ei pääse mistään solmusta,
joten matriisi ei muutu.
Kierroksella 2 huomaamme, että voimme kulkea solmun 2 kautta
solmusta 1 solmuun 4, jolloin saamme etäisyyden 8.
Samoin voimme kulkea solmun 2 kautta solmusta 3 solmuun 4,
jolloin saamme etäisyyden 5.
Jatkamme vastaavasti, kunnes kierroksen 4 jälkeen olemme
saaneet selville kaikki etäisyydet ja etäisyysmatriisi on lopullinen.

\subsection{Algoritmin toteutus}

Floyd–Warshallin algoritmin etuna on, että se on hyvin helppoa toteuttaa.
Meidän riittää rakentaa kolme sisäkkäistä for-silmukkaa,
jotka toteuttavat matriisin päivitykset.
Seuraavassa koodissa muuttuja $k$ kertoo,
mikä kierros on kyseessä ja mitä solmua käytämme välisolmuna.
Jokaisella kierroksella käymme läpi kaikki solmuparit $(i,j)$
ja koetamme parantaa niiden etäisyyksiä kulkemalla solmun $k$ kautta.

\begin{code}
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int vanha = etaisyys[i][j];
            int uusi = etaisyys[i][k]+etaisyys[k][j];
            etaisyys[i][j] = Math.min(vanha,uusi);
        }
    }
}
\end{code}

Algoritmin aikavaativuus on selkeästi $O(n^3)$.

\subsection{Miksi algoritmi toimii?}

Yksi tapa ymmärtää Floyd–Warshallin algoritmia on
ajatella algoritmin toimintaa ''käänteisesti'' rekursiivisesti:
kun verkossa on lyhin polku solmusta $a$ solmuun $b$,
millainen tämä polku voi olla?

Jos solmu $x$ kuuluu polkuun, meille syntyy kaksi osaongelmaa:
meidän tulee etsiä ensin lyhin polku solmusta $a$ solmuun $x$
ja sitten lyhin polku solmusta $x$ solmuun $b$.
Näiden polkujen muodostamisessa voimme jälleen käydä läpi tapauksia,
mitkä solmut kuuluvat polkuihin.
Esimerkiksi lyhin polku solmusta $a$ solmuun $x$
voi kulkea vuorostaan solmun $y$ kautta,
jolloin haluamme etsiä lyhimmät polut solmusta $a$ solmuun $y$
ja solmusta $y$ solmuun $x$, ja niin edelleen.

Floyd–Warshallin algoritmissa muodostamme joka vaiheessa
polkuja, joissa voi olla välisolmuina solmuja $1,2,\dots,i$.
Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $b$,
meillä on kaksi vaihtoehtoa:
Jos solmu $i$ on välisolmuna, yhdistämme lyhimmät polut
solmusta $a$ solmuun $i$ ja solmusta $i$ solmuun $b$.
Jos taas solmu $i$ ei ole välisolmuna, olemme käsitelleet
polun jo aiemmin.
Algoritmin päätteeksi välisolmuina voi olla solmuja $1,2,\dots,n$,
eli mikä tahansa verkon solmu voi olla välisolmu.