\chapter{Reitinhaku}

Monissa verkkotehtävissä on kysymys siitä,
että haluamme löytää parhaan reitin paikasta toiseen
eli \emph{lyhimmän polun} verkon solmusta toiseen.
Esimerkiksi voimme haluta selvittää,
mikä on nopein reitti kahden katuosoitteen välillä
tai mikä on halvin tapa lentää kaupungista toiseen.
Näissä ja muissa sovelluksissa on tärkeää,
että löydämme lyhimmän polun tehokkaasti.

Olemme käyttäneet aiemmin leveyshakua lyhimmän
polun etsimiseen.
Tämä onkin hyvä ratkaisu, kun haluamme löytää polun,
jonka kaarten määrä on pienin.
Tässä luvussa keskitymme kuitenkin vaikeampaan
tilanteeseen, jossa verkko on \emph{painotettu}
ja haluamme löytää polun,
jossa painojen summa on pienin.
Esimerkiksi kuvassa \ref{fig:verpai}
lyhin polku solmusta $1$ solmuun $5$ on
$1 \rightarrow 3 \rightarrow 4 \rightarrow 5$,
jonka pituus on $2+4+3=9$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:2] {} (3);
\path[draw,thick,->] (1) -- node[font=\small,label=above:9] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=above:8] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=right:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\node at (3,-1) {(a)};
\end{scope}
\begin{scope}[xshift=8cm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:2] {} (3);
\path[draw,thick,->] (1) -- node[font=\small,label=above:9] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=above:8] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=right:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\path[draw,thick,->,red,line width=1.5pt] (1) -- (3);
\path[draw,thick,->,red,line width=1.5pt] (3) -- (4);
\path[draw,thick,->,red,line width=1.5pt] (4) -- (5);

\node at (3,-1) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Painotettu verkko. (b) Lyhin polku solmusta $1$ solmuun $5$.
}
\label{fig:verpai}
\end{figure}

Painotetussa verkossa lyhimmän polun etsimiseen
on monia algoritmeja, joilla on erilaisia ominaisuuksia.
Tutustumme ensin Bellman–Fordin algoritmiin,
joka etsii lyhimmät polut annetusta lähtösolmusta
kaikkiin verkon solmuihin.
Tämän jälkeen käymme läpi Dijkstran algoritmin,
joka tekee saman tehokkaammin
olettaen, ettei verkossa ole negatiivisen painoisia kaaria.
Lopuksi käsitte\-lemme Floyd–Warshallin algoritmin,
joka etsii samanaikaisesti lyhimmät polut kaikkien
verkon solmujen välillä.

\section{Lyhimmät polut lähtösolmusta}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=0mm]
\small
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$0$};
\node[color=red] at (2,0.75) {$6$};
\node[color=red] at (2,-2.75) {$2$};
\node[color=red] at (4,0.75) {$11$};
\node[color=red] at (4,-2.75) {$9$};
\end{tikzpicture}
\end{center}
\caption{Lyhimpien polkujen pituudet solmusta $1$ alkaen.}
\label{fig:lypola}
\end{figure}

Lähdemme liikkeelle tilanteesta, jossa olemme valinneet yhden verkon
solmuista lähtösolmuksi ja haluamme määrittää
jokaiselle solmulle sen etäisyy\-den
eli lyhimmän polun pituuden lähtösolmusta.
Kuvassa \ref{fig:lypola} on esimerkkinä verkko,
jossa lähtösolmuna on solmu $1$ ja jokaisen solmun
viereen on merkitty sen etäisyys.
Esimerkiksi solmun $5$ etäisyys on $9$,
koska lyhimmän polun $1 \rightarrow 3 \rightarrow 5$ pituus on $2+7=9$.

Miksi alamme etsiä heti lyhimpiä polkuja lähtösolmusta
\emph{kaikkiin} solmuihin, vaikka käytännössä haluamme yleensä
löytää lyhimmän polun lähtö\-solmusta \emph{tiettyyn} kohdesolmuun?
Syynä tähän on, että yksittäinen lyhin polku voi olla
yhtä vaikeaa löytää kuin kaikki lyhimmät polut,
jos kohdesolmu sijaitsee toisella puolella verkkoa.
Niinpä voimme samalla vaivalla keskittyä kaikkien lyhimpien
polkujen etsimiseen.

\subsection{Bellman–Fordin algoritmi}

Bellman–Fordin algoritmi etsii lyhimmät polut
annetusta lähtösolmusta kaikkiin verkon solmuihin.
Algoritmi muodostaa taulukon, joka kertoo jokaiselle
solmulle sen \emph{etäisyyden} eli lyhimmän polun pituuden lähtösolmusta.
Algoritmi toimii missä tahansa verkossa,
kunhan verkossa ei ole negatiivista sykliä eli sykliä,
jonka painojen summa on negatiivinen.

Bellman–Fordin algoritmi pitää yllä \emph{arvioita}
solmujen etäisyyksistä niin,
että aluksi etäisyys lähtösolmuun on 0 ja etäisyys
kaikkiin muihin solmuihin on ääretön.
Tämän jälkeen algoritmi alkaa parantaa etäisyyksiä
etsimällä verkosta kaaria, joiden kautta kulkeminen
lyhentää polkuja.
Jokaisessa vaiheessa algoritmi etsii kaaren $a \rightarrow b$,
jolle pätee, että pääsemme solmuun $b$ lyhempää polkua
kulkemalla kaarella solmusta $a$.
Kun mitään etäisyysarviota ei voi enää parantaa,
algoritmi päättyy ja kaikki etäisyydet vastaavat
todellisia lyhimpien polkujen pituuksia.

Kuva \ref{fig:belfor} näyttää esimerkin Bellman–Fordin algoritmin toiminnasta,
kun lähtösolmuna on solmu $1$.
Jokaisen solmun vieressä on ilmoitettu sen etäisyysarvio:
aluksi etäisyys solmuun 1 on 0 ja etäisyys kaikkiin muihin solmuihin on ääretön.
Jokainen etäisyyden muutos näkyy kuvassa omana vaiheenaan.
Ensin parannamme etäisyyttä solmuun 2
kulkemalla kaarta $1 \rightarrow 2$,
jolloin etäisyydeksi tulee $8$.
Sitten parannamme etäisyyttä solmuun $3$
kulkemalla kaarta $1 \rightarrow 3$,
jolloin solmun uudeksi etäisyydeksi tulee $2$.
Jatkamme samalla tavalla, kunnes emme voi enää parantaa
mitään etäisyyttä ja kaikki etäisyydet
vastaavat lyhimpien polkujen pituuksia.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.65,label distance=-1.5mm]
\footnotesize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}{0}{8}{\infty}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}{0}{8}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}{0}{6}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\verkko{6}{0}{6}{2}{13}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-11cm]
\verkko{7}{0}{6}{2}{12}{9}
\path[draw=red,thick,->,line width=1.5pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-11cm,xshift=6.5cm]
\verkko{8}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Bellman–Fordin algoritmin toiminnasta.}
\label{fig:belfor}
\end{figure}

Toteutamme Bellman–Fordin algoritmin käytännössä niin,
että se muodostuu \emph{kierroksista},
joista jokainen käy läpi kaikki verkon kaaret
ja koettaa parantaa etäisyys\-arvioita niiden avulla.
Algoritmi pitää kirjaa taulukossa solmujen
etäisyyksistä ja päivittää joka kierroksella yhtä
tai useampaa etäisyyttä.
Algoritmi päättyy, kun se havaitsee, että jonkin kierroksen
aikana mikään etäisyys ei muuttunut.
Jotta voimme toteuttaa algoritmin mukavasti,
oletamme, että verkko on tallennettu kaarilistana,
jossa jokaisesta kaaresta on tiedossa sen alku- ja loppusolmu sekä paino.

Voimme toteuttaa algoritmin seuraavasti:

\begin{code}
while true
    muutos = false
    for kaari in kaaret
        nyky = etaisyys[kaari.loppu]
        uusi = etaisyys[kaari.alku]+kaari.paino
        if uusi < nyky
            etaisyys[kaari.loppu] = uusi
            muutos = true
    if not muutos
        break
\end{code}

Algoritmi käy jokaisella kierroksella läpi verkon kaaret
ja laskee kunkin kaaren kohdalla muuttujaan
\texttt{nyky}, mikä on nykyinen etäisyys kaaren
kohdesolmuun, sekä muuttujaan \texttt{uusi}, mikä on uusi etäisyys,
jos kuljemme kaaren kautta.
Jos uusi etäisyys on pienempi, merkitsemme sen muistiin
ja lisäksi tiedon, että olemme muuttaneet jotain
etäisyyttä kierroksen aikana.

Olemme nyt kuvailleet ja toteuttaneet algoritmin,
mutta miksi algoritmi toimii ja miten tehokas se on?
Jotta voimme vastata näihin kysymyksiin,
tarvitsemme kaksi havaintoa koskien verkon lyhimpiä polkuja.

Ensimmäinen havainto on, että jos lyhin polku solmusta $s_1$ solmuun $s_k$ on
$s_1 \rightarrow s_2 \rightarrow \dots \rightarrow s_k$,
niin myös lyhin polku solmusta $s_1$ solmuun $s_2$ on $s_1 \rightarrow s_2$,
lyhin polku solmusta $s_1$ solmuun $s_3$ on $s_1 \rightarrow s_2 \rightarrow s_3$, jne.,
eli jokainen polun alkuosa on myös lyhin polku vastaavaan solmuun.
Jos näin ei olisi, voisimme parantaa lyhintä polkua solmusta $s_1$ solmuun $s_k$
parantamalla jotain polun alkuosaa, mikä aiheuttaisi ristiriidan.

Toinen havainto on,
että $n$ solmun verkossa jokainen lyhin polku voi
sisältää enintään $n-1$ kaarta,
kun oletamme, että verkossa ei ole negatiivista sykliä.
Jos polkuun kuuluisi $n$ tai enemmän kaaria,
jokin solmu esiintyisi polulla monta kertaa.
Tämä ei ole kuitenkaan mahdollista,
koska ei olisi järkeä kulkea monta kertaa saman solmun kautta,
kun haluamme saada aikaan lyhimmän polun.

Tarkastellaan nyt, mitä tapahtuu algoritmin kierroksissa.
Ensimmäisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään yksi kaari.
Toisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään kaksi kaarta.
Sama jatkuu, kunnes $n-1$ kierroksen jälkeen olemme löytäneet
lyhimmät polut, joissa on enintään $n-1$ kaarta.
Koska missään lyhimmässä polussa ei voi olla enempää kaaria,
olemme löytäneet kaikki lyhimmät polut.
Algoritmi suorittaa siis enintään $n-1$ kierrosta,
joista jokainen käy läpi kaikki verkon kaaret ajassa $O(m)$.
Niinpä algoritmi löytää kaikki lyhimmät polut ajassa $O(nm)$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:1] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:3] {} (3);
\path[draw,thick,<-] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=left:$-7$] {} (4);
\path[draw,thick,<-] (2) -- node[font=\small,label=above:2] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\path[draw,thick,->,red,line width=2pt] (2) -- (4);
\path[draw,thick,->,red,line width=2pt] (4) -- (5);
\path[draw,thick,->,red,line width=2pt] (5) -- (2);

\end{tikzpicture}
\end{center}
\caption{Negatiivinen sykli $2 \rightarrow 4 \rightarrow 5 \rightarrow 2$,
jonka avulla voimme lyhentää polkuja loputtomasti.}
\label{fig:belsyk}
\end{figure}

Mitä tapahtuu sitten, jos verkossa on negatiivinen sykli?
Esimerkiksi kuvan \ref{fig:belsyk} verkossa on negatiivinen sykli
$2 \rightarrow 4 \rightarrow 5 \rightarrow 2$, jonka paino on $-2$.
Tässä tilanteessa Bellman–Fordin algoritmi jää jumiin, koska se pystyy parantamaan
loputtomasti syklin kautta kulkevia polkuja.
Oikeastaan ongelma on siinä, että lyhin polku ei ole mielekäs käsite,
jos polun osana on negatiivinen sykli.
Voimme kuitenkin havaita negatiivisen syklin siitä,
että jokin etäisyys paranee vielä $n-1$ kierroksen jälkeen.

\subsection{Dijkstran algoritmi}

Dijkstran algoritmi on Bellman–Fordin algoritmin tehostettu versio,
jonka toiminta perustuu oletukseen, että verkossa ei ole
negatiivisen painoisia kaaria.
Bellman–Fordin algoritmin tapaan Dijkstran algoritmi pitää
yllä arvioita etäisyyksistä lähtösolmusta muihin solmuihin.
Erona on kuitenkin tapa, miten Dijkstran algoritmi parantaa etäisyyksiä.

Dijkstran algoritmissa verkon solmut kuuluvat kahteen luokkaan:
käsitte\-lemättömiin ja käsiteltyihin.
Aluksi kaikki solmut ovat käsittelemättömiä.
Algoritmi etsii jokaisessa vaiheessa käsittelemättömän solmun,
jonka etäisyys\-arvio on pienin.
Sitten algoritmi käy läpi kaikki solmusta lähtevät kaaret ja
koettaa parantaa etäisyyksiä niiden avulla.
Tämän jälkeen solmu on käsitelty eikä sen etäisyys enää muutu,
eli aina kun olemme käsitelleet solmun,
olemme saaneet selville sen lopullisen etäisyyden.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\verkko{2}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\verkko{3}{0}{6}{2}{\infty}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\verkko{4}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\verkko{5}{0}{6}{2}{11}{9}
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\node[draw, circle, fill=lightgray] (4) at (4,0) {$4$};
\verkko{6}{0}{6}{2}{11}{9}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Dijkstran algoritmin toiminnasta.}
\label{fig:dijalg}
\end{figure}

Kuva \ref{fig:dijalg} näyttää esimerkin Dijkstran algoritmin
toiminnasta.
Solmun harmaa väri tarkoittaa, että se on käsitelty.
Aluksi valitsemme käsittelyyn solmun 1, koska sen etäisyys 0 on pienin.
Sitten jäljellä ovat solmut 2, 3, 4 ja 5,
joista valitsemme käsittelyyn solmun 3, jonka etäisyys 2 on pienin.
Tämän jälkeen valitsemme käsittelyyn solmun 2,
jonka etäisyys on 6.
Sama jatkuu, kunnes olemme käsitelleet kaikki verkon solmut.

\subsubsection{Algoritmin toteutus}

Dijkstran algoritmissa etsimme $n$ kertaa
käsittelemättömän solmun, jonka etäisyysarvio on pienin.
Koska haluamme saada algoritmista tehokkaan,
meidän täytyy pystyä löytämään solmut nopeasti.
Tavallinen tapa toteuttaa Dijkstran algoritmi on käyttää \emph{kekoa},
jonka avulla löydämme joka vaiheessa pienimmän etäisyyden solmun
logaritmisessa ajassa.

Oletamme seuraavaksi, että haluamme muodostaa lyhimmät
polut lähtö\-solmusta \texttt{alku} alkaen.
Tallennamme kekoon solmuja, joista on tiedossa
etäi\-syys ja solmun tunnus,
järjestettynä etäisyyden mukaan pienimmästä suurimpaan.
Merkitsemme aluksi taulukkoon, että lähtösolmun etäisyys on $0$
ja lisäämme sitä vastaavan solmun kekoon.
Lisäksi merkitsemme taulukkoon, että kaikkien muiden
solmujen etäisyys on ääretön.

\begin{code}
for (int i = 1; i <= n; i++) {
    if (i == alku) etaisyys[i] = 0;
    else etaisyys[i] = INF;
}
keko.push(new Solmu(0,alku));
\end{code}

Tämän jälkeen haemme joka askeleella keosta solmun,
jonka etäisyys on pienin.
Jos solmu on jo käsitelty, emme tee mitään.
Muuten käymme läpi kaikki solmusta lähtevät kaaret
ja tarkastamme, voimmeko parantaa etäisyyksiä
niiden avulla.
Aina kun voimme parantaa etäisyyttä,
lisäämme uuden etäisyyden kekoon.

\begin{code}
while (!keko.empty()) {
    Solmu solmu = keko.pop();
    if (kasitelty[solmu.id]) continue;
    kasitelty[solmu.id] = true;
    for (Kaari kaari : verkko[solmu]) {
        int vanha = etaisyys[kaari.kohde];
        int uusi = etaisyys[solmu]+kaari.paino;
        if (vanha < uusi) {
            etaisyys[kaari.kohde] = uusi;
            keko.push(new Solmu(uusi,kaari.kohde));
        }
    }
}
\end{code}

Huomaa, että keossa voi olla \emph{useita} etäisyyksiä
samalle solmulle, koska lisäämme kekoon uuden solmun
aina etäisyyden parantuessa.
Käsittelemme näistä kuitenkin vain pienimmän etäisyyden solmun.

\subsubsection{Algoritmin analyysi}

Dijkstran algoritmi on ahne algoritmi,
koska se valitsee joka vaiheessa käsitte\-lyyn solmun,
jonka etäisyys on pienin.
Miten voimme olla varmoja, että algoritmi löytää lyhimmät
polut kaikissa tilanteissa?

Algoritmin toiminta perustuu oletukseemme,
että verkossa ei ole negatiivisen painoisia kaaria.
Voimme ajatella asiaa käänteisesti: jos pienimmän etäisyyden
käsittelemättömän solmun
etäisyys ei olisi lopullinen, pystyisimme parantamaan
sitä kulkemalla solmuun jonkin toisen käsittelemättömän solmun kautta.
Kuitenkin kaikkien muiden tarjolla olevien solmujen etäisyy\-det
ovat suurempia tai yhtä suuria eivätkä etäisyydet voi lyhentyä,
koska verkossa ei ole negatiivisen painoisia kaaria.
Tästä syystä voimme turvallisesti valita pienimmän etäisyyden
solmun ja käsitellä sen.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\node[draw, circle] (1) at (0,1) {$1$};
\node[draw, circle] (2) at (2.5,2) {$2$};
\node[draw, circle] (3) at (2.5,0) {$3$};
\node[draw, circle] (4) at (5,1) {$4$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:7] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=above:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:$-4$] {} (4);
\end{tikzpicture}
\end{center}
\caption{Dijkstran algoritmi ei toimi oikein negatiivisen kaaren takia.}
\label{fig:dijneg}
\end{figure}

Jos verkossa on negatiivinen kaari,
Dijkstran algoritmi ei toimi välttä\-mättä oikein.
Kuva \ref{fig:dijneg} näyttää esimerkin tällaisesta verkosta.
Dijkstran algoritmi seuraa ahneesti ylempää polkua ja toteaa,
että pienin etäisyys solmusta 1 solmuun 4 on 8.
Kuitenkin parempi tapa olisi kulkea alempaa polkua,
jolloin negatiivisen kaaren asiosta pienin etäisyys on vain 3.

Dijkstran algoritmi toimii siis oikein,
jos verkossa ei ole negatiivisia kaaria,
mutta kuinka nopeasti algoritmi toimii?

Algoritmin aikana käsittelemme kunkin verkon solmun
ja käymme läpi siitä lähtevät kaaret, missä kuluu aikaa $O(n+m)$.
Lisäksi algoritmissa on joukko kekoon liittyviä operaatioita,
jotka vaikuttavat tehokkuuteen.
Pahimmassa tapauksessa lisäämme jokaisen kaaren kohdalla
kekoon uuden alkion, eli lisäykset kekoon vievät aikaa $O(m \log m)$.
Toisaalta poistamme kaikki alkiot aikanaan keosta,
mihin menee myös aikaa $O(m \log m)$.
Algoritmin kokonaisaikavaativuus on siis $O(n + m \log m)$.

\section{Kaikki lyhimmät polut}

\subsection{Floyd–Warshallin algoritmi}

Floyd-Warshallin algoritmi muodostaa verkolle \emph{etäisyysmatriisin},
jossa rivin $a$ sarakkeessa $b$ on lyhimmän polun pituus
solmusta $a$ solmuun $b$.
Algoritmi eroaa Bellman–Fordin ja Dijkstran algoritmeista
siinä, että se laskee samalla kertaa \emph{kaikki} etäisyydet verkossa
eikä meidän tarvitse valita, mistä solmusta lähdemme liikkeelle.

Algoritmin alustaa ensin etäisyysmatriisin niin,
että siihen on merkitty vain etäisyydet,
jotka toteutuvat kulkemalla yksittäistä kaarta,
ja kaikissa muissa matriisin kohdissa on arvo ääretön.
Sitten algoritmi suorittaa $n$ kierrosta,
jotka on numeroitu $1,2,\dots,n$.
Kierroksella $k$ algoritmi etsii polkuja, joissa on välisolmuna
solmu $k$ sekä mahdollisesti solmuja $1,2,\dots,k-1$.
Jos tällainen polku parantaa etäisyyttä,
päivitämme uuden etäisyyden matriisiin.
Viimeisen kierroksen jälkeen jokainen solmu on ollut
välisolmuna poluilla, jolloin olemme saaneet selville
kaikki lyhimmät polut.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\newcommand\verkko[5]{
\begin{scope}[xshift=0.75cm,yshift=2cm]
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (2.5,0) {$2$};
\node[draw, circle, fill=#4] (3) at (0,-2.5) {$3$};
\node[draw, circle, fill=#5] (4) at (2.5,-2.5) {$4$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:1] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=right:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:4] {} (3);
\end{scope}

\foreach \x in {1,2,3,4} \node at (-0.5,-2.5-\x) {\x};
\foreach \x in {1,2,3,4} \node at (-0.5+\x,-2.5) {\x};
\draw (0,-3) grid (4,-7);

\node at (2,-8) {kierros #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/\infty} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/\infty} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\end{scope}
\begin{scope}[xshift=5.5cm]
\verkko{2}{white}{lightgray}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (3.5,-3.5) {$8$};
\node[color=red] at (3.5,-5.5) {$5$};
\end{scope}
\begin{scope}[xshift=11cm]
\verkko{3}{white}{white}{lightgray}{white}
\foreach \x/\v in {1/\infty,2/,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/4,4/} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-3.5) {$3$};
\node[color=red] at (1.5,-6.5) {$6$};
\node[color=red] at (3.5,-6.5) {$9$};
\end{scope}
\begin{scope}[xshift=16.5cm]
\verkko{4}{white}{white}{white}{lightgray}
\foreach \x/\v in {1/\infty,2/3,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/6,3/4,4/9} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-4.5) {$9$};
\node[color=red] at (2.5,-4.5) {$7$};
\node[color=red] at (2.5,-5.5) {$9$};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Floyd–Warshallin algoritmin toiminnasta.}
\label{fig:flowar}
\end{figure}

Kuva \ref{fig:flowar} näyttää esimerkin Floyd–Warshallin algoritmin toiminnasta.
Kierroksella 1 etsimme polkuja, joissa solmu 1 on välisolmuna.
Tällaisia polkuja ei ole, koska solmuun 1 ei pääse mistään solmusta,
joten matriisi ei muutu.
Kierroksella 2 huomaamme, että voimme kulkea solmun 2 kautta
solmusta 1 solmuun 4, jolloin saamme etäisyyden 8.
Samoin voimme kulkea solmun 2 kautta solmusta 3 solmuun 4,
jolloin saamme etäisyyden 5.
Jatkamme vastaavasti, kunnes kierroksen 4 jälkeen olemme
saaneet selville kaikki etäisyydet ja etäisyysmatriisi on lopullinen.

\subsubsection{Algoritmin toteutus}

Floyd–Warshallin algoritmin etuna on, että se on hyvin helppoa toteuttaa.
Meidän riittää rakentaa kolme sisäkkäistä for-silmukkaa,
jotka toteuttavat matriisin päivitykset.
Seuraavassa koodissa muuttuja $k$ kertoo,
mikä kierros on kyseessä eli mitä solmua käytämme välisolmuna.
Jokaisella kierroksella käymme läpi kaikki solmuparit $(i,j)$
ja koetamme parantaa niiden etäisyyksiä kulkemalla solmun $k$ kautta.

\begin{code}
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int vanha = etaisyys[i][j];
            int uusi = etaisyys[i][k]+etaisyys[k][j];
            etaisyys[i][j] = Math.min(vanha,uusi);
        }
    }
}
\end{code}

Algoritmin aikavaativuus on selkeästi $O(n^3)$,
koska se muodostuu kolmesta sisäkkäisestä for-silmukasta.

\subsubsection{Miksi algoritmi toimii?}

Yksi tapa ymmärtää Floyd–Warshallin algoritmia on
ajatella algoritmin toimintaa ''käänteisesti'' rekursiivisesti:
kun verkossa on lyhin polku solmusta $a$ solmuun $b$,
millainen tämä polku voi olla?

Jos solmu $x$ kuuluu polkuun, meille syntyy kaksi osaongelmaa:
meidän tulee etsiä ensin lyhin polku solmusta $a$ solmuun $x$
ja sitten lyhin polku solmusta $x$ solmuun $b$.
Näiden polkujen muodostamisessa voimme jälleen käydä läpi tapauksia,
mitkä solmut kuuluvat polkuihin.
Esimerkiksi lyhin polku solmusta $a$ solmuun $x$
voi kulkea vuorostaan solmun $y$ kautta,
jolloin haluamme etsiä lyhimmät polut solmusta $a$ solmuun $y$
ja solmusta $y$ solmuun $x$, ja niin edelleen.

Floyd–Warshallin algoritmissa muodostamme joka vaiheessa
polkuja, joissa voi olla välisolmuina solmuja $1,2,\dots,i$.
Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $b$,
meillä on kaksi vaihtoehtoa:
Jos solmu $i$ on välisolmuna, yhdistämme lyhimmät polut
solmusta $a$ solmuun $i$ ja solmusta $i$ solmuun $b$.
Jos taas solmu $i$ ei ole välisolmuna, olemme käsitelleet
polun jo aiemmin.
Algoritmin päätteeksi välisolmuina voi olla solmuja $1,2,\dots,n$,
eli mikä tahansa verkon solmu voi olla välisolmu.