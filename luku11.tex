\chapter{Suunnatut verkot}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (3) -- (2);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (5) -- (4);
\node at (2,-3.5) {(a)};
\end{scope}
\begin{scope}[xshift=8cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3.5) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Suuntaamaton verkko. (b) Suunnattu verkko}
\label{fig:versuu}
\end{figure}

Tähän mennessä olemme olettaneet,
että voimme kulkea verkon kaaria kumpaankin suuntaan,
mikä tarkoittaa, että verkko on \emph{suuntaamaton}.
Tässä luvussa kuitenkin keskitymme tilanteeseen,
jossa verkko on \emph{suunnattu}, eli jokaista kaarta
voi kulkea vain merkittyyn suuntaan.

Kuvassa \ref{fig:versuu} on esimerkkinä kaksi verkkoa,
joilla on sama rakenne, mutta vasen verkko on
suuntaamaton ja oikea verkko on suunnattu.
Oikeassa verkossa esimerkiksi solmujen $1$ ja $2$
välinen kaari on suunnattu niin, että voimme kulkea
sitä pitkin solmusta $1$ solmuun $2$,
mutta emme voi kulkea solmusta $2$ solmuun $1$.

Suunnatun verkon käsitteleminen on melko samanlaista
kuin suuntaamattoman verkon:
voimme tallentaa verkon vieruslistoina ja käyttää
syvyyshakua ja leveyshakua kuten ennenkin.
Erona on, että kaarten suunnat rajoittavat
liikkumistamme verkossa.
Suunnatussa verkossa on mahdollista, että solmusta
$a$ solmuun $b$ on polku mutta solmusta
$b$ solmuun $a$ ei ole polkua.
Esimerkiksi verkossa \ref{fig:versuu}(b)
voimme kulkea solmusta $1$ solmuun $4$
mutta emme voi kulkea solmusta $4$ solmuun $1$.

Tämän luvun alussa tutustumme topologiseen järjestämiseen,
joka on mahdollista silloin, kun suunnattu verkko on syklitön.
Se antaa meille verkon solmujen käsittelyjärjestyksen,
jonka avulla voimme käyttää dynaamista ohjelmointia.
Tämän jälkeen käymme läpi algoritmin, joka etsii tehokkaasti
suunnatun verkon vahvasti yhtenäiset komponentit.

\section{Topologinen järjestäminen}

Suunnatun verkon \emph{topologinen järjestys} on solmujen järjestys,
jossa pätee, että jos solmusta $a$ on kaari solmuun $b$,
niin solmu $a$ on ennen solmua $b$ järjestyksessä.
Topologinen järjestys voidaan esittää listana,
joka ilmaisee solmujen järjestyksen.
Kuvassa \ref{fig:topjar} on esimerkkinä verkko ja yksi sen topologinen
järjestys $[1,3,5,2,4]$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\end{scope}
\begin{scope}[xshift=7cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (3) at (2,-1) {$3$};
\node[draw, circle] (5) at (4,-1) {$5$};
\node[draw, circle] (2) at (6,-1) {$2$};
\node[draw, circle] (4) at (8,-1) {$4$};
\path[draw,thick,->] (1) edge [bend right] (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) edge [bend left] (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) edge [bend left] (4);
\path[draw,thick,->] (5) edge [bend right] (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja yksi sen topologinen järjestys $[1,3,5,2,4]$.}
\label{fig:topjar}
\end{figure}

Topologinen järjestäminen vaatii, että verkossa ei ole \emph{sykliä}.
Sykli on verkossa oleva polku, jonka lähtösolmu ja
päätesolmu ovat samat.
Jos verkossa on sykli, emme voi muodostaa topologista
järjestystä, koska emme voi valita mitään syklissä
olevaa solmua järjestykseen ennen muita.
Jos taas verkossa ei ole sykliä,
voimme aina muodostaa topologisen järjestyksen.

Suunnatut syklittömät verkot ovat tärkeässä asemassa
algoritmiikassa, ja englannin kielessä niille on jopa
oma nimitys \emph{dag}, joka tulee sanoista
\emph{directed acyclic graph}.

Seuraavaksi tutustumme algoritmiin,
jonka avulla voimme muodostaa topologisen järjestyksen
tai todeta, että verkossa on sykli eikä järjestyksen
muodostaminen ole mahdollista.

\subsection{Järjestyksen muodostaminen}

Voimme muodostaa topologisen järjestyksen suorittamalla
joukon syvyyshakuja, joissa jokaisella solmulla on kolme mahdollista tilaa:

\begin{itemize}
\item tila 0 (valkoinen): solmussa ei ole käyty
\item tila 1 (harmaa): solmun käsittely on kesken
\item tila 2 (musta): solmun käsittely on valmis
\end{itemize}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{white}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{white}{gray}{white}
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{gray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{gray}{gray}{gray}{gray}{white}
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{gray}{gray}{gray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki topologisen järjestyksen muodostamisesta.}
\label{fig:topesi}
\end{figure}

Algoritmin alussa jokainen solmu on valkoinen.
Käymme läpi kaikki verkon solmut ja aloitamme aina syvyyshaun
solmusta, jos se on valkoinen.
Aina kun saavumme uuteen solmuun, sen väri muuttuu
valkoisesta harmaaksi.
Sitten kun olemme käsitelleet kaikki solmusta lähtevät
kaaret, solmun väri muuttuu harmaasta mustaksi
ja lisäämme solmun listalle.
Tämä lista käänteisessä järjestyksessä on verkon
topologinen järjestys.
Kuitenkin jos saavumme jossain vaiheessa algoritmia
toista kautta harmaaseen solmuun,
verkossa on sykli eikä topologista järjestystä voi muodostaa.

Kuva \ref{fig:topesi} näyttää, kuinka algoritmi muodostaa topologisen
järjestyksen esimerkkiverkossamme.
Tässä tapauksessa suoritamme kaksi syvyyshakua,
joista ensimmäinen alkaa solmusta 1 ja toinen alkaa solmusta 5.
Algoritmin tuloksena on lista $[4,2,3,1,5]$,
joten käänteinen lista $[5,1,3,2,4]$ on verkon topologinen järjestys.
Huomaa, että tämä on eri järjestys kuin kuvassa \ref{fig:topjar};
topologinen järjestys ei ole yksikäsitteinen ja voimme yleensä
muodostaa järjestyksen monella tavalla.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Topologista järjestystä ei voi muodostaa syklin takia.}
\label{fig:topsyk}
\end{figure}

Kuva \ref{fig:topsyk} näyttää puolestaan esimerkin tilanteesta,
jossa topologista järjestystä ei voi muodostaa verkossa
olevan syklin takia.
Tässä verkossa on sykli $2 \rightarrow 4 \rightarrow 3 \rightarrow 2$,
jonka olemassaolon huomaamme siitä, että tulemme uudestaan
harmaaseen solmuun 2.

Algoritmi käy läpi verkon solmut ja kaaret syvyyshaun avulla,
joten sen aikavaativuus on $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

Miten voimme tietää, että algoritmimme topologisen
järjestyksen muodostamiseen toimii
oikein kaikissa mahdollisissa tilanteissa?

Tarkastellaan ensin tilannetta, jossa verkossa on sykli.
Jos algoritmi saapuu uudestaan harmaaseen solmuun $x$,
on selvää, että verkossa on sykli,
koska algoritmi on onnistunut pääsemään solmusta $x$
takaisin itseensä kulkemalla jotain polkua verkossa.
Toisaalta jos verkossa on sykli, algoritmi saapuu
jossain vaiheessa ensimmäistä kertaa johonkin sykliin
kuuluvaan solmuun $x$. Sen jälkeen se käy läpi solmusta
lähtevät kaaret ja aikanaan saapuu varmasti uudestaan
solmuun $x$. Niinpä algoritmi onnistuu kaikissa tilanteissa tunnistamaan,
jos verkossa on sykli.

Jos sitten verkossa ei ole sykliä, algoritmi lisää jokaisen
solmun listalle sen jälkeen, kun se on käsitellyt
kaikki solmusta lähtevät kaaret.
Jos siis verkossa on kaari $a \rightarrow b$,
solmu $b$ lisätään listalle ennen solmua $a$.
Lopuksi lista käännetään, jolloin solmu $a$
tulee ennen solmua $b$.
Tämän ansiosta jokaiselle kaarelle $a \rightarrow b$ pätee,
että solmu $a$ on järjestyksessä ennen solmua $b$.

\subsection{Esimerkki: Kurssivalinnat}

Yliopiston kurssit ja niiden esitietovaatimukset voidaan esittää 
suunnattuna verkkona, jonka solmut ovat kursseja ja kaaret kuvaavat,
missä järjestyksessä kurssit tulisi suorittaa.
Kuvassa \ref{fig:kuresi} on esimerkkinä joitakin
tietojenkäsittely\-tieteen kandiohjelman kursseja.
Tällaisen verkon topologinen järjestys kertoo meille
yhden tavan suorittaa kurssit esitietovaatimusten mukaisesti.
Kuvassa \ref{fig:kurjar} näkyy yksi mahdollinen topologinen järjestys,
joka antaa suoritusjärjestyksen
OHPE, OHJA, TIPE, TITO, JYM, TIRA, LAMA.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {OHPE};
\node[draw, rectangle] (2) at (-4,-2) {OHJA};
\node[draw, rectangle] (3) at (4,-2) {TITO};
\node[draw, rectangle] (4) at (0,-2) {TIPE};
\node[draw, rectangle] (5) at (-8,-2) {JYM};
\node[draw, rectangle] (6) at (-4,-4) {TIRA};
\node[draw, rectangle] (7) at (-4,-6) {LAMA};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) -- (6);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (5) -- (7);
\path[draw,thick,->] (6) -- (7);
\end{tikzpicture}
\end{center}
\caption{Kurssien esitietovaatimukset verkkona.}
\label{fig:kuresi}
\end{figure}


\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {OHPE};
\node[draw, rectangle] (2) at (2.5,0) {OHJA};
\node[draw, rectangle] (4) at (5,0) {TIPE};
\node[draw, rectangle] (3) at (7.5,0) {TITO};
\node[draw, rectangle] (5) at (10,0) {JYM};
\node[draw, rectangle] (6) at (12.5,0) {TIRA};
\node[draw, rectangle] (7) at (15,0) {LAMA};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) edge [bend left] (3);
\path[draw,thick,->] (1) edge [bend right] (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) edge [bend left] (6);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (5) edge [bend right] (7);
\path[draw,thick,->] (6) -- (7);
\end{tikzpicture}
\end{center}
\caption{Topologinen järjestys antaa kurssien suoritusjärjestyksen.}
\label{fig:kurjar}
\end{figure}

On selvää, että kurssien ja esitietovaatimusten muodostaman
verkon tulee olla syklitön, jotta kurssit voi suorittaa halutulla tavalla.
Jos verkossa on sykli, topologista järjestystä ei ole olemassa
eikä meillä ole mitään mahdollisuutta suorittaa kursseja
esitietovaatimusten mukaisesti.

\section{Dynaaminen ohjelmointi}

Kun tiedämme, että suunnattu verkko on syklitön,
voimme ratkaista monia verkko-ongelmia tehokkaasti
dynaamisen ohjelmoinnin avulla,
koska voimme käsitellä solmut topologisen
järjestyksen mukaisesti.

\begin{itemize}
\item Kuinka pitkä on lyhin polku solmusta $a$ solmuun $b$?
\item Kuinka pitkä on pisin polku solmusta $a$ solmuun $b$?
\item Montako erilaista polkua on solmusta $a$ solmuun $b$?
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} verkossa on yhteensä
kolme polkua solmusta 1 solmuun 4:
$1 \rightarrow 2 \rightarrow 4$,
$1 \rightarrow 3 \rightarrow 2 \rightarrow 4$ ja
$1 \rightarrow 3 \rightarrow 4$.
Lyhin polun pituus on 2 ja pisin polun pituus on 3.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Mahdolliset polut solmusta 1 solmuun 4.}
\label{fig:verpol}
\end{figure}

Osoittautuu, että voimme ratkaista
kaikki yllä mainitut ongelmat
ajassa $O(n+m)$ dynaamisella ohjelmoinnilla,
kun oletamme, että verkko on suunnattu ja syklitön.
Yleisessä verkossa tilanne on toinen:
voimme etsiä lyhimmän polun Dijkstran algoritmilla
ajassa $O(m \log n)$, mutta pisimmän polun etsimiseen
tai polkujen yhteismäärän laskemiseen ei tunneta
mitään tehokasta menetelmää\footnote{Oletamme, että sama solmu
ei saa esiintyä polulla monta kertaa. Ilman tätä oletusta
pisin polku voi olla äärettömän pituinen ja erilaisia
polkuja voi olla ääretön määrä.}.

\subsection{Polkujen käsittely}

Jotta voimme käyttää dynaamista ohjelmointia,
meidän täytyy määritellä ongelmat rekursiivisesti.
Sopivat funktiot ovat seuraavat:

\begin{itemize}
\item $\texttt{lyhin}(x)$: lyhimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{pisin}(x)$: pisimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{maara}(x)$: polkujen yhteismäärä solmusta $a$ solmuun $x$
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} tilanteessa lähtösolmu on $a=1$
ja funktiot saavat arvot $\texttt{lyhin}(4)=2$,
$\texttt{pisin}(4)=3$ ja $\texttt{maara}(4)=3$.

Funktioiden pohjatapaukset ovat seuraavat:

\begin{align*}
\texttt{lyhin}(a)&=0 \\
\texttt{pisin}(a)&=0 \\
\texttt{maara}(a)&=1
\end{align*}

Tämä tarkoittaa tilannetta, jossa haluamme kulkea solmusta $a$
solmuun $a$. Koska polulla ei voi olla kaaria,
sekä lyhimmän että pisimmän polun pituus on 0.
Polkujen määrä on 1, koska ainoa polku on tyhjä polku.

Seuraavaksi määrittelemme yleisen tapauksen solmulle $x$.
Oletamme, että solmuun $x$ pääsee kaarella solmuista,
joiden tunnukset ovat $u_1,u_2,\dots,u_k$.
Tällöin saamme seuraavat rekursiiviset kaavat:

\begin{align*}
\texttt{lyhin}(x)&=\min(\texttt{lyhin}(u_1),\texttt{lyhin}(u_2),\dots,\texttt{lyhin}(u_k))+1 \\
\texttt{pisin}(x)&=\max(\texttt{pisin}(u_1),\texttt{pisin}(u_2),\dots,\texttt{pisin}(u_k))+1 \\
\texttt{maara}(x)&=\texttt{maara}(u_1)+\texttt{maara}(u_2)+\dots+\texttt{maara}(u_k)
\end{align*}

Voimme perustella kaavat seuraavasti:
Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $x$,
meidän tulee valita polun edellinen solmu niin,
että siihen on lyhin matka solmusta $a$.
Niinpä valitsemme minimin edellisistä arvoista
ja lisäämme siihen yhden.
Vastaavasti kun haluamme muodostaa pisimmän polun,
valitsemme maksimin edellisistä arvoista ja lisäämme siihen yhden.
Kun taas haluamme laskea polkujen yhteismäärän,
laskemme yhteen kaikki solmuun johtavat polut.

Tarkastellaan esimerkkinä kuvan \ref{fig:verpol} verkkoa,
jossa olemme kiinnostuneita poluista solmusta 1 solmuun 4.
Kun haluamme laskea funktioiden arvot solmulle 4,
otamme huomioon kaaret
$2 \rightarrow 4$, $3 \rightarrow 4$ ja $5 \rightarrow 4$,
joita kulkemalla pääsee muista solmuista solmuun 4.
Oletamme, että olemme laskeneet aiemmin funktioiden
arvot solmuille 2, 3 ja 5.

Nyt esimerkiksi lyhin polku solmusta 1 solmuun 4 on pituudeltaan
\[ \texttt{lyhin}(4)=\min(\texttt{lyhin}(2),\texttt{lyhin}(3),\texttt{lyhin}(5))+1.\]
Aiemmat arvot ovat $\texttt{lyhin}(2)=1$, $\texttt{lyhin}(3)=2$ ja $\texttt{lyhin}(5)=\infty$.
Valitsemme näistä pienimmän, eli tulemme solmuun 4 solmusta 2.
Tämä tuottaa polun, jonka pituus on $\texttt{lyhin}(2)+1=2$.
Vastaavalla tavalla voimme laskea arvot $\texttt{pisin}(4)$ ja $\texttt{maara}(4)$.

Huomaa, että jos solmuun $x$ ei tule kaarta mistään solmusta,
oletamme, että $\texttt{lyhin}(x)=\infty$ ja $\texttt{pisin}(x)=-\infty$.
Tämä on luonteva tulkinta, kun laskemme minimin tai maksimin
tyhjälle joukolle.
Tämän ansiosta emme koskaan muodosta polkua,
joka ei ala solmusta $a$.

Koska tiedämme, että verkko on syklitön,
voimme laskea rekursiivisten funktioiden arvot
tehokkaasti dynaamisella ohjelmoinnilla.
Oleellista on, että emme voi joutua koskaan silmukkaan
laskiessamme arvoja.
Käytännössä voimme laskea arvot solmujen
topologisessa järjestyksessä.
Tällä tavalla saamme kuhunkin ongelmaan ratkaisun, joka
vie aikaa $O(n+m)$.

\subsection{Ongelmat verkkoina}

Itse asiassa \emph{minkä tahansa} dynaamisen ohjelmoinnin ratkaisun voi
esittää suunnattuna syklittömänä verkkona.
Tällöin jokainen verkon solmu vastaa yhtä laskettavaa funktion arvoa,
ja kaaret näyttävät, miten funktion arvot riippuvat toisistaan.

Tarkastellaan esimerkkinä tuttua tehtävää,
jossa haluamme muodostaa rahasumman annetuista kolikoista.
Esimerkiksi jos kolikot ovat $\{1,3,4\}$ ja rahasumma on 6,
ratkaisut ovat seuraavat:

\begin{multicols}{2}
\begin{itemize}
\item $4+1+1$
\item $1+4+1$
\item $1+1+4$
\item $3+3$
\item $3+1+1+1$
\item $1+3+1+1$
\item $1+1+3+1$
\item $1+1+1+3$
\item $1+1+1+1+1+1$
\end{itemize}
\end{multicols}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (0) at (0,0) {$0$};
\node[draw, circle] (1) at (2,0) {$1$};
\node[draw, circle] (2) at (4,0) {$2$};
\node[draw, circle] (3) at (6,0) {$3$};
\node[draw, circle] (4) at (8,0) {$4$};
\node[draw, circle] (5) at (10,0) {$5$};
\node[draw, circle] (6) at (12,0) {$6$};
\path[draw,thick,->] (0) -- (1);
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (2) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (5);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (0) edge [bend left] (2);
\path[draw,thick,->] (1) edge [bend left] (3);
\path[draw,thick,->] (2) edge [bend left] (4);
\path[draw,thick,->] (3) edge [bend left] (5);
\path[draw,thick,->] (4) edge [bend left] (6);
\path[draw,thick,->] (0) edge [bend right] (3);
\path[draw,thick,->] (1) edge [bend right] (4);
\path[draw,thick,->] (2) edge [bend right] (5);
\path[draw,thick,->] (3) edge [bend right] (6);
\end{tikzpicture}
\end{center}
\caption{Kolikkotehtävä esitettynä verkkona.}
\label{fig:verkol}
\end{figure}

Voimme esittää tämän tehtävän verkkona niin,
että solmut ovat rahasummia ja kaaret kertovat,
kuinka voimme valita kolikkoja.
Esimerkiksi kuva \ref{fig:verkol} näyttää verkon,
joka vastaa yllä olevaa tapausta.
Tässä verkossa lyhin polku solmusta 0 solmuun 6
on $0 \rightarrow 3 \rightarrow 6$, joka
vastaa pienimmän kolikkomäärän ratkaisua $3+3$,
ja polkujen yhteismäärä solmusta 0 solmuun 6 on 9,
joka on sama kuin kaikkien ratkaisuiden määrä.

Olemme saaneet siis uuden tavan luonnehtia dynaamista ohjelmointia:
voimme käyttää dynaamista ohjelmointia,
jos pystymme esittämään ongelman suunnattuna syklittömänä verkkona.

\section{Vahvasti yhtenäisyys}

Jos suunnatussa verkossa on sykli,
emme voi muodostaa sille topologista järjestystä
emmekä käyttää dynaamista ohjelmointia.
Mikä neuvoksi, jos kuitenkin haluaisimme tehdä näin?

Joskus voimme selvityä tilanteesta etsimällä
verkon vahvasti yhtenäiset komponentit.
\emph{Vahvasti yhtenäinen komponentti} on joukko verkon solmuja,
jossa pätee, että mistä tahansa solmusta on polku
mihin tahansa solmuun emmekä voi lisätä enempää solmuja joukkoon.
Kun esitämme jokaisen vahvasti yhtenäisen komponentin
yhtenä solmuna, saamme selville verkon syvärakenteen,
joka on aina syklitön verkko.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (0,-2) {$2$};
\node[draw, circle] (3) at (2,0) {$3$};
\node[draw, circle] (4) at (2,-2) {$4$};
\node[draw, circle] (5) at (4,0) {$5$};
\node[draw, circle] (6) at (4,-2) {$6$};

\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (3) -- (2);

\path[draw,thick,->] (5) edge [bend left] (6);
\path[draw,thick,->] (6) edge [bend left] (5);

\path[draw,thick,->] (3) -- (5);
\path[draw,thick,->] (4) -- (6);

\draw[red,dashed,thick,line width=2pt] (-0.75,0.75) rectangle (2.75,-2.75);
\draw[red,dashed,thick,line width=2pt] (3.25,0.75) rectangle (4.75,-2.75);

\node at (2,-3.5) {(a)};
\end{scope}
\begin{scope}[xshift=8cm,yshift=-1cm]
\node[draw,rectangle] (1) at (0,0) {$\{1,2,3,4\}$};
\node[draw,rectangle] (2) at (4,0) {$\{5,6\}$};
\path[draw,thick,->] (1) -- (2);
\node at (2,-2.5) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Verkon vahvasti yhtenäiset komponentit.
(b) Komponenttiverkko, joka kuvaa verkon syvärakenteen.}
\label{fig:vahkom}
\end{figure}

Kuvassa \ref{fig:vahkom} on esimerkkinä verkko, joka muodostuu
kahdesta vahvasti yhtenäisestä komponentista.
Ensimmäinen komponentti on $\{1,2,3,4\}$
ja toinen komponentti on $\{5,6\}$.
Komponenteista muodostuu syklitön komponenttiverkko,
jossa on kaari solmusta $\{1,2,3,4\}$ solmuun $\{5,6\}$.

Seuraavaksi tutustumme Kosarajun algoritmiin,
jonka avulla pystymme muodostamaan tehokkaasti suunnatun
verkon vahvasti yhtenäiset komponentit ja niitä
vastaavan komponenttiverkon.

\subsection{Kosarajun algoritmi}

Kosarajun algoritmi muodostuu kahdesta verkon läpikäynnistä.
Ensimmäinen läpikäynti muistuttaa topologisen järjestyksen
etsimistä ja tuottaa listan solmuista.
Toinen läpikäynti muodostaa vahvasti yhtenäiset komponentit
ensimmäisen läpikäynnin tuottaman listan avulla.

Algoritmin ensimmäinen läpikäynti aloittaa vuorollaan
syvyyshaun jokaisesta solmusta, jota ei ole vielä käsitelty.
Kun saavumme solmuun, käymme ensin läpi kaikki
solmusta lähtevät kaaret ja lisäämme tämän jälkeen solmun listalle.
Toimimme siis kuten topologisen järjestyksen muodostamisessa,
mutta emme välitä, jos tulemme uudestaan samaan solmuun.

Algoritmin toisen läpikäynnin alussa
käännämme jokaisen verkon kaaren suunnan.
Tämän jälkeen käsittelemme ensimmäisen läpikäynnin tuottaman
solmujen listan kääntei\-sessä järjestyksessä.
Jokaisen solmun kohdalla muodostamme uuden vahvasti yhtenäisen
komponentin, jossa on kaikki vielä käsittelemät\-tömät solmut,
joihin pääsemme solmusta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[7]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (0,-2) {$2$};
\node[draw, circle, fill=#4] (3) at (2,0) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,0) {$5$};
\node[draw, circle, fill=#7] (6) at (4,-2) {$6$};

\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (5) edge [bend left] (6);
\path[draw,thick,->] (6) edge [bend left] (5);
\path[draw,thick,->] (3) -- (5);
\path[draw,thick,->] (4) -- (6);

\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{white}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{gray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{lightgray}{white}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{lightgray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\path[draw=red,thick,->,line width=2pt] (6) edge [bend left] (5);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{lightgray}{lightgray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{lightgray}{gray}{lightgray}{gray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{lightgray}{gray}{gray}{gray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kosarajun algoritmin ensimmäinen läpikäynti.}
\label{fig:koseka}
\end{figure}

Tarkastelemme seuraavaksi, kuinka Kosarajun algoritmi
toimii esimerkkiverkossamme.
Kuva \ref{fig:koseka} näyttää ensimmäisen läpikäynnin,
joka muodostaa solmuista listan $[2,5,6,4,3,1]$.
Tämän jälkeen käännämme kaikki verkon kaaret ja
käsittelemme solmut järjestyksessä $[1,3,4,6,5,2]$.
Kuva \ref{fig:kostok} näyttää toisen läpikäynnin.
Vahvasti yhtenäiset komponentit syntyvät
solmuista 1 ja 6 alkaen.
Kaarten kääntämisen ansiosta
solmusta 1 alkava
vahvasti yhtenäinen komponentti ei ''vuoda''
solmujen 5 ja 6 alueelle.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[7]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (0,-2) {$2$};
\node[draw, circle, fill=#4] (3) at (2,0) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,0) {$5$};
\node[draw, circle, fill=#7] (6) at (4,-2) {$6$};

\path[draw,thick,<-] (1) -- (3);
\path[draw,thick,<-] (3) -- (4);
\path[draw,thick,<-] (4) -- (2);
\path[draw,thick,<-] (2) -- (1);
\path[draw,thick,<-] (3) -- (2);
\path[draw,thick,<-] (5) edge [bend left] (6);
\path[draw,thick,<-] (6) edge [bend left] (5);
\path[draw,thick,<-] (3) -- (5);
\path[draw,thick,<-] (4) -- (6);

\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{lightgray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\draw[red,dashed,thick,line width=1.5pt] (-0.75,0.75) rectangle (2.75,-2.75);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{lightgray}{lightgray}{lightgray}{white}{lightgray}
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,<-,line width=2pt] (5) edge [bend left] (6);
\draw[red,dashed,thick,line width=1.5pt] (3.25,0.75) rectangle (4.75,-2.75);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kosarajun algoritmin toinen läpikäynti.}
\label{fig:kostok}
\end{figure}

Koska algoritmi muodostuu kahdesta verkon läpikäynnistä,
sen aikavaativuus on $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

Keskeinen kysymys Kosarajun algoritmiin liittyen on,
miten voimme olla varmoja, että saamme verkon toisessa läpikäynnissä
muodostettua vahvasti yhtenäisiä komponentteja,
joihin ei tule ylimääräisiä solmuja?

Voimme tarkastella asiaa muodostettavana olevan syklittömän
komponenttiverkon näkökulmasta.
Jos meillä on komponentti $A$, josta pääsee kaarella
komponenttiin $B$, 
algoritmin ensimmäinen läpikäynti takaa, että
jokin $A$:n solmu lisätään listalle kaikkien $B$:n
solmujen jälkeen.
Kun sitten käymme läpi listan käänteisessä järjestyksessä,
jokin $A$:n solmu tulee vastaan ennen kaikkia $B$:n
solmuja.
Niinpä alamme rakentaa ensin komponenttia $A$
emmekä mene komponentin $B$ puolelle,
koska verkon kaaret on käännetty.

Vastaavasti jos meillä on komponentti $A$,
johon pääsee komponentista $B$,
muodostamme komponentin $B$ ennen komponenttia $A$.
Niinpä kun käänteisessä verkossa
komponentista $A$ on kaari komponenttiin $B$,
tämä ei haittaa, koska olemme jo muodostaneet
komponentin $B$ eikä komponenttiin $A$ tule ylimääräisiä solmuja
komponentista $B$.

\subsection{Esimerkki: Luolapeli}

Olemme pelissä luolastossa, joka muodostuu luolista ja niitä yhdistävistä
käytävistä. Jokainen käytävä on yksisuuntainen.
Jokaisessa luolassa on yksi aarre, jonka voimme ottaa mukaamme,
jos kuljemme luolan kautta.
Peli alkaa luolasta $a$ ja päättyy luolaan $b$.
Montako aarretta voimme saada, jos valitsemme parhaan
mahdollisen reitin?

Voimme mallintaa tilanteen verkkona, jonka solmut ovat luolia ja
kaaret ovat käytäviä. Haluamme löytää reitin solmusta $a$ solmuun $b$
niin, että kuljemme mahdollisimman monen solmun kautta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (2,-1) {$2$};
\node[draw, circle] (3) at (-2,0) {$3$};
\node[draw, circle] (4) at (0,-2) {$4$};
\node[draw, circle] (5) at (0,-4) {$5$};
\node[draw, circle] (6) at (-2,-2) {$6$};
\node[draw, circle] (7) at (-2,-4) {$7$};

\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (4) -- (6);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (6);
\path[draw,thick,->] (6) edge [bend left] (7);
\path[draw,thick,->] (7) edge [bend left] (6);
\path[draw,thick,->] (4) -- (5);
\path[draw,thick,->] (5) -- (7);
\end{tikzpicture}
\end{center}
\caption{Luolasto, jossa on 7 luolaa ja 10 käytävää.
Haluamme kulkea luolasta 1 luolaan 7 keräten mahdollisimman paljon aarteita.}
\label{fig:luopel}
\end{figure}

Esimerkiksi kuva \ref{fig:luopel} näyttää verkkona luolaston, joka muodostuu
7 luolasta ja 10 käytävästä.
Oletetaan, että haluamme liikkua luolasta 1 luolaan 7
keräten mahdollisimman paljon aarteita.
Tällöin yksi mahdollinen reitti on
$1 \rightarrow 4 \rightarrow 2 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 7$,
jonka avulla saamme kaikki aarteet paitsi luolassa 5 olevan aarteen.
Ei ole olemassa reittiä, jota seuraamalla saisimme kaikki luolaston aarteet.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {$\{1,2,4\}$};
\node[draw, rectangle] (2) at (-4,-2) {$\{3\}$};
\node[draw, rectangle] (3) at (4,-2) {$\{5\}$};
\node[draw, rectangle] (4) at (0,-4) {$\{6,7\}$};

\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\end{tikzpicture}
\end{center}
\caption{Luolaston vahvasti yhtenäiset komponentit.}
\label{fig:luovah}
\end{figure}

Voimme ratkaista ongelman tehokkaasti määrittämällä ensin verkon
vahvasti yhtenäiset komponentit.
Tämän jälkeen meidän riittää löytää polku alkusolmun komponentista
loppusolmun komponenttiin niin, että komponenttien kokojen summa
on suurin mahdollinen.
Koska verkko on syklitön, tämä onnistuu dynaamisella ohjelmoinnilla.

Kuva \ref{fig:luovah} näyttää vahvasti yhtenäiset komponentit
esimerkkiverkossamme.
Tästä esityksestä näemme suoraan, että optimaalisia reittejä on kaksi:
voimme kulkea joko luolan 3 tai luolan 5 kautta.