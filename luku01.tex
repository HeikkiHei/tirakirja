\chapter{Johdanto}

Kurssin \emph{Tietorakenteet ja algoritmit} tarkoituksena
on opettaa menetelmiä, joiden avulla voimme ratkaista
\emph{tehokkaasti} laskennallisia ongelmia.
Ohjelmoinnin peruskursseilla olemme keskittyneet
ohjelmointitaidon opetteluun.
Nyt on aika siirtyä askel eteenpäin ja alkaa kiinnittää
huomiota myös siihen, miten nopeasti algoritmit toimivat.

Algoritmien tehokkuudella on suuri merkitys käytännössä.
Esimerkiksi netissä toimiva reittiopas on käyttökelpoinen sen vuoksi,
että saamme tietoomme reitin kuvauksen heti sen jälkeen kun olemme
ilmoittaneet, mistä mihin haluamme matkustaa.
Jos meidän pitäisi odottaa reitin kuvausta vaikkapa minuutti tai tunti,
tämä rajoittaisi paljon palvelun käyttöä.

Jotta reittiopas toimisi tehokkaasti, sen taustalla on
hyvin suunniteltu algoritmi.
Tällä kurssilla opimme, kuinka voimme luoda itse vastaavia algoritmeja.
Tutustumme kurssilla sekä algoritmien suunnittelun teoriaan että
käytäntöön -- haluamme ymmärtää syvällisesti, mistä algoritmeissa on kysymys,
mutta myös osata toteuttaa niitä käytännössä.

\section{Mitä algoritmit ovat?}

Algoritmi on toimintaohje, jota seuraamalla voimme ratkaista
jonkin laskennallisen ongelman.
Esimerkiksi ''onko luku $n$ alkuluku?'' on laskennallinen ongelma,
jossa algoritmille annetaan luku $n$
ja sen täytyy ilmoittaa ''kyllä'' tai ''ei'' riippuen siitä,
onko $n$ alkuluku vai ei.
Esimerkiksi jos algoritmille annetaan luku $7$,
sen täytyy ilmoittaa ''kyllä'',
ja jos algoritmille annetaan luku $9$,
sen täytyy ilmoittaa ''ei''.

Voimme tarkastaa, onko annettu luku $n$ alkuluku, seuraavalla algoritmilla:
käymme läpi kaikki luvut $2,3,\dots,n-1$ ja koetamme
jakaa lukua $n$ jokaisella niistä.
Jos $n$ on jaollinen jollain luvuista, se ei ole alkuluku,
ja muuten se on alkuluku.
Esimerkiksi luku $7$ on alkuluku, koska se ei ole jaollinen
millään luvuista $2,3,\dots,6$,
ja luku $9$ puolestaan ei ole alkuluku, koska se on jaollinen luvulla $3$.
Voimme tutkia tämän algoritmin avulla mistä tahansa luvusta,
onko se alkuluku vai ei.

Ensimmäinen vaihe ohjelmoinnin oppimisessa on oppia
ohjelmoinnin perustaidot niin, että osaamme laatia
\emph{jonkin} toimivan annetun algoritmin ongelman ratkaisemiseen.
On arvokas taito sinänsä, että osaamme ratkaista
ongelman jollakin tavalla.
Toinen vaihe, johon keskitymme tällä kurssilla,
on oppia suunnittelemaan \emph{tehokkaita} algoritmeja.
Tämä tarkoittaa, että haluamme saada aikaan mahdollisuuksien mukaan
jotain parempaa kuin suoraviivaisia
raakaan voimaan perustuvia algoritmeja.

Kiehtova seikka ohjelmoinnissa on, että monimutkaisetkin algoritmit
syntyvät yksinkertaisista aineksista. Keskeiset käsitteet ovat

\begin{itemize}
\item muuttujat, joissa voimme säilyttää tietoa ohjelmassa,
\item ehtolause (\texttt{if}), jonka avulla voimme haarautua ohjelmassa,
\item silmukat (\texttt{for} ja \texttt{while}), joiden avulla voimme
toistaa laskentaa, sekä
\item taulukot, joissa voimme säilyttää paljon tietoa.
\end{itemize}

Itse asiassa voimme toteuttaa \emph{minkä tahansa} algoritmin
vain näitä aineksia käyttäen.
Tämä on huojentava tieto, koska meidän ei siis tarvitse opetella
suurta määrää ohjelmointikielten ominaisuuksia,
ennen kuin voimme alkaa suunnitella tehokkaita algoritmeja.
Vaikeutena on kuitenkin \emph{keksiä}, kuinka käyttää näitä
tekniikoita eri tilanteessa.

Algoritmin toiminnan esittämiseen on useita tapoja.
Yksi tapa on selittää sanallisesti, kuinka algoritmi toimii,
kuten teimme äsken.
Toinen tapa taas on antaa koodi, joka toteuttaa algoritmin.
Tällöin meidän täytyy valita jokin ohjelmointikieli,
jonka avulla esitämme algoritmin.
Esimerkiksi voimme tarkastaa seuraavasti Java-kielellä,
onko luku $n$ alkuluku:

\begin{code}
boolean alkuluku = true;
for (int i = 2; i < n; i++) {
    if (n%i == 0) {
        alkuluku = false;
    }
}
\end{code}

Algoritmien suunnittelussa on usein tapana esittää
algoritmin koodi \emph{pseudokoodina} todellisen ohjelmointikielen sijasta.
Tämä tarkoittaa, että kirjoitamme koodia,
joka on lähellä todellista ohjelmointia, mutta voimme
päättää koodin tarkan syntaksin itse ja ottaa joitakin vapauksia,
joiden ansiosta voimme kuvata algoritmin mukavammin.
Voisimme esimerkiksi esittää äskeisen algoritmin pseudokoodina seuraavasti:

\begin{code}
alkuluku = true
for i = 2 to n-1
    if n%i == 0
        alkuluku = false
\end{code}

Tässä kirjassa esitämme algoritmeja sekä Java-koodina että pseudokoodina
tilanteesta riippuen.
Käytämme Java-koodia silloin, kun haluamme erityisesti kiinnittää huomiota siihen,
miten jokin asia toteutetaan käytännössä Javassa.
Pseudokoodia käytämme taas silloin, kun haluamme kuvata algoritmin yleisen
idean eikä käytetyllä kielellä ole merkitystä.

Taulukko \ref{tab:psekoo} esittää yhteenvedon tässä kirjassa käytetyn pseudokoodin syntaksista
suhteessa Java-kieleen.
Tavoitteena on ollut, että voimme esittää koodin tiiviisti ja
käyttää joitakin hyödyllisiä lyhennyksiä.
Tämä ei tarkoita, että kyseinen tapa kirjoittaa pseudokoodia olisi ainoa sallittu --
se on vain yksi mahdollisuus, joka soveltuu hyvin tähän kirjaan.

\lstnewenvironment{smallcode}[1][]%
{
   \noindent
   \small
   \minipage{0.47\linewidth} 
   \vspace{0.5\baselineskip}
   \lstset{#1,xleftmargin=0pt}}
{\endminipage}

\begin{table}
\center
\begin{tabular}{ll}
pseudokoodi & Java-koodi \\
\hline
\begin{smallcode}[xleftmargin=0pt]
x = 5
s = "abc"
t = [1,2,3]
\end{smallcode}
&
\begin{smallcode}
int x = 5;
String s = "abc";
int[] t = {1,2,3};
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
if a == b
    // koodia
\end{smallcode}
&
\begin{smallcode}
if (a == b) {
    // koodia
}
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
while a == b
    // koodia
\end{smallcode}
&
\begin{smallcode}
while (a == b) {
    // koodia
}
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
for i = 1 to n
    // koodia
\end{smallcode}
&
\begin{smallcode}
for (int i = 1; i <= n; i++) {
    // koodia
}
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
for i = n to 1
    // koodia
\end{smallcode}
&
\begin{smallcode}
for (int i = n; i >= 1; i--) {
    // koodia
}
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
sort(x)
\end{smallcode}
&
\begin{smallcode}
Arrays.sort(x);
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
print(x)
\end{smallcode}
&
\begin{smallcode}
System.out.println(x);
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
swap(a,b)
\end{smallcode}
&
\begin{smallcode}
t = a;
a = b;
b = t;
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
a = min(x,y)
b = max(x,y)
\end{smallcode}
&
\begin{smallcode}
a = Math.min(x,y);
b = Math.max(x,y);
\end{smallcode}
\\
\begin{smallcode}[xleftmargin=0pt]
summa(a,b)
    return a+b
\end{smallcode}
&
\begin{smallcode}
int summa(int a, int b) {
    return a+b;
}
\end{smallcode}
\\
\end{tabular}
\caption{Kirjassa käytetty pseudokoodin syntaksi.}
\label{tab:psekoo}
\end{table}

\section{Rekursio}

Rekursio on hyödyllinen ohjelmointitekniikka,
joka jää kuitenkin usein sivurooliin ohjelmoinnin perusteiden opiskelussa.
Nyt onkin hyvä hetki perehtyä kunnolla siihen,
mitä hyötyä meille on rekursiosta.
Tulemme tarvitsemaan rekursiota useassa vaiheessa kurssin aikana.

\subsection{Osajoukkojen läpikäynti}

Joukon osajoukkoja ovat kaikki tavat valita osa joukon alkioista.
Esimerkiksi joukon $\{1,2,3\}$ osajoukot ovat
$\emptyset$ (tyhjä joukko), $\{1\}$, $\{2\}$, $\{3\}$,
$\{1,2\}$, $\{1,3\}$, $\{2,3\}$ ja $\{1,2,3\}$.
Jos joukossa on $n$ alkioita, osajoukkoja on $2^n$.

Rekursio tarjoaa kätevän tavan käydä läpi kaikki
joukon osajoukot. Esimerkiksi seuraava koodi pitää yllä
rakennetta

\begin{code}
ArrayDeque<Integer> osajoukko;
\end{code}

joka sisältää vuorollaan kunkin joukon $\{1,2,\dots,n\}$
osajoukon.
Haku läh\-tee käyntiin, kun kutsumme metodia \texttt{muodosta}
parametrilla $1$.

\begin{code}
void muodosta(int x) {
    if (x == n+1) {
        System.out.println(osajoukko);
        return;
    }
    muodosta(x+1); // x ei valita osajoukkoon
    osajoukko.addLast(x);
    muodosta(x+1); // x valitaan osajoukkoon
    osajoukko.removeLast();
}
\end{code}

Jokaisessa kutsussa metodi käy läpi tapaukset,
otetaanko luku $x$ mukaan osajoukkoon vai ei.
Molemmissa tapauksissa metodi kutsuu itseään yhtä
suuremalla $x$:n arvolla.
Lopulta kun $x=n+1$, kaikki luvut on käyty läpi
ja on aika tulostaa osajoukko.

Esimerkiksi tapauksessa $n=3$ koodin tulostus on seuraava:

\begin{code}
[]
[3]
[2]
[2, 3]
[1]
[1, 3]
[1, 2]
[1, 2, 3]
\end{code}

\subsection{Permutaatioiden läpikäynti}

Joukon permutaatiot ovat kaikki tavat järjestää joukon alkiot.
Esimerkiksi joukon $\{1,2,3\}$ permutaatiot ovat
$(1,2,3)$, $(1,3,2)$, $(2,1,3)$, $(2,3,1)$, $(3,1,2)$ ja $(3,2,1)$.
Jos joukossa on $n$ alkiota, permutaatioita on $n!$.

Myös permutaatioiden läpikäynti onnistuu kätevästi rekursiolla.
Seuraava koodi pitää yllä rakennetta

\begin{code}
ArrayDeque<Integer> permutaatio;
\end{code}

joka sisältää vuorollaan kunkin joukon $\{1,2,\dots,n\}$ permutaation.
Haku lähtee käyntiin, kun kutsumme metodia
\texttt{muodosta} ilman parametreja.

\begin{code}
void muodosta() {
    if (permutaatio.size() == n) {
        System.out.println(permutaatio);
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (!permutaatio.contains(i)) {
            permutaatio.addLast(i);
            muodosta();
            permutaatio.removeLast();
        }
    }
}
\end{code}

Tässä on ideana, että metodi käy joka kutsulla läpi kaikki luvut
$1,2,\dots,n$ ja aina jos luku ei kuulu vielä permutaatioon,
koodi haarautuu rekursiivisesti tapaukseen, jossa se lisätään
seuraavaksi permutaatioon.
Sitten kun permutaatiossa on $n$ lukua, se on valmis ja
voimme tulostaa sen.

Esimerkiksi tapauksessa $n=3$ koodin tulostus on seuraava:

\begin{code}
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
\end{code}

\subsection{Peruuttava haku}

\emph{Peruuttava haku} on yleinen menetelmä,
jota käyttäen voimme muodostaa järjestelmällisesti
kaikki ratkaisut annettuun tehtävään.
Siinä on ideana aloittaa tyhjästä ratkaisusta ja käydä
joka askeleella läpi rekursiivisesti kaikki mahdolliset tavat laajentaa ratkaisua.

Peruuttava haku on raa'an voiman menetelmä,
ja voimme käyttää sitä vain silloin,
kun ratkaisujen määrä on niin pieni,
että ehdimme käydä kaikki läpi.
Kuitenkin jos voimme käyttää peruuttavaa hakua,
se on mainio tekniikka,
koska voimme olla varmoja, että oikein toteutettu
peruuttava haku löytää kaikki ratkaisut.

\begin{figure}
\center
\begin{tikzpicture}[scale=0.5]
\newcommand\nelio[9]{
\draw (0,0) grid (3,3);
\foreach \x/\y/\v in {0/0/#1,1/0/#2,2/0/#3,0/1/#4,1/1/#5,2/1/#6,0/2/#7,1/2/#8,2/2/#9} \node at (0.5+\x,2.5-\y) {\v};
}
\begin{scope}
\nelio{1}{2}{3}{2}{3}{1}{3}{1}{2}
\end{scope}
\begin{scope}[xshift=4cm]
\nelio{1}{2}{3}{3}{1}{2}{2}{3}{1}
\end{scope}
\begin{scope}[xshift=8cm]
\nelio{1}{3}{2}{2}{1}{3}{3}{2}{1}
\end{scope}
\begin{scope}[xshift=12cm]
\nelio{1}{3}{2}{3}{2}{1}{2}{1}{3}
\end{scope}
\begin{scope}[xshift=16cm]
\nelio{2}{1}{3}{1}{3}{2}{3}{2}{1}
\end{scope}
\begin{scope}[xshift=20cm]
\nelio{2}{1}{3}{3}{2}{1}{1}{3}{2}
\end{scope}
\begin{scope}[yshift=-4cm]
\nelio{2}{3}{1}{1}{2}{3}{3}{1}{2}
\end{scope}
\begin{scope}[yshift=-4cm,xshift=4cm]
\nelio{2}{3}{1}{3}{1}{2}{1}{2}{3}
\end{scope}
\begin{scope}[yshift=-4cm,xshift=8cm]
\nelio{3}{1}{2}{1}{2}{3}{2}{3}{1}
\end{scope}
\begin{scope}[yshift=-4cm,xshift=12cm]
\nelio{3}{1}{2}{2}{3}{1}{1}{2}{3}
\end{scope}
\begin{scope}[yshift=-4cm,xshift=16cm]
\nelio{3}{2}{1}{1}{3}{2}{2}{1}{3}
\end{scope}
\begin{scope}[yshift=-4cm,xshift=20cm]
\nelio{3}{2}{1}{2}{1}{3}{1}{3}{2}
\end{scope}
\end{tikzpicture}
\caption{Kaikki 12 latinalaista neliötä kokoa $3 \times 3$.}
\label{fig:latnel}
\end{figure}

Tarkastelemme esimerkkinä tehtävää, jossa haluamme laskea,
montako tietyn kokoista latinalaista neliötä on olemassa.
\emph{Latinalainen neliö} on ruudukko kokoa $n \times n$, jonka
kullakin vaaka- ja pystyrivillä esiintyy tarkalleen kerran
jokainen luku $1,2,\dots,n$.
Kyseessä on siis yksinkertaisempi muoto tutusta sudoku-tehtävästä.
Esimerkiksi kuvassa \ref{fig:latnel} on kaikki 12 latinalaista neliötä kokoa $3 \times 3$.
Kun $n$ kasvaa, niin ratkaisujen määrä kasvaa nopeasti.

Hakua varten määrittelemme seuraavat taulukot:

\begin{code}
int[][] nelio = new int[n][n];
boolean[][] vaaka = new boolean[n][n];
boolean[][] pysty = new boolean[n][n];
\end{code}

Numeroimme ruudukon pysty- ja vaakarivit $0,1,\dots,n-1$.
Tarkoituksena on, että kohdassa $\texttt{nelio}[y][x]$
on neliössä ruudussa $(y,x)$ oleva luku.
Lisäksi $\texttt{vaaka}[y][k]$ kertoo, onko vaakarivillä $y$
jo lukua $k$, ja vastaavasti $\texttt{pysty}[x][k]$ kertoo,
onko pystyrivillä $x$ jo lukua $k$.
Alussa kaikki taulukot ovat tyhjiä ja täytämme niitä
pikkuhiljaa peruuttavan haun aikana.

Seuraava rekursiivinen metodi toteuttaa haun, kun sille
annetaan alkuparametreina $y=0$ ja $x=0$.
Metodi laskee latinalaisten neliöiden määrän muuttujaan 
\texttt{laskuri}.

\begin{code}
void muodosta(int y, int x) {
    if (y == n) laskuri++;
    else if (x == n) muodosta(y+1,0);
    else {
        for (int i = 1; i <= n; i++) {
            if (!vaaka[y][i] && !pysty[x][i]) {
                vaaka[y][i] = pysty[x][i] = true;
                nelio[y][x] = i;
                muodosta(y,x+1);
                vaaka[y][i] = pysty[x][i] = false;
            }
        }
    }
}
\end{code}

Jokaisella askeleella metodi valitsee luvun ruutuun
$(y,x)$ ja siirtyy seuraavaan ruutuun oikealle.
Jos $x=n$, vaakarivi on tullut täyteen ja metodi siirtyy
seuraavalle vaakariville.
Jos taas $y=n$, koko ruudukko on tullut täyteen ja
metodi kasvattaa ruudukoiden määrää yhdellä.

\begin{table}
\center
\begin{tabular}{rr}
ruudukon koko $n$ & neliöiden määrä \\
\hline
1 & 1 \\
2 & 2 \\
3 & 12 \\
4 & 576 \\
5 & 161280 \\
6 & 812851200 \\
\end{tabular}
\caption{Latinalaisten neliöiden määriä pienille $n$:n arvoille.}
\label{tab:latnel}
\end{table}

Tämän koodin avulla voimme laskea latinalaisten neliöiden
määrät ensimmäisille $n$:n arvoille.
Taulukko \ref{tab:latnel} näyttää nämä tulokset.
Suuremmilla $n$:n arvoilla haku alkaa kestää liian kauan
ja meidän tulisi keksiä keino tehostaa hakua,
jos haluaisimme laskea tuloksia suuremmissa tapauksissa.

\section{Matemaattinen tausta}

Tietorakenteiden ja algoritmien teoria perustuu matematiikkaan,
ja käym\-me kirjassa pikkuhiljaa läpi tarvittavia tietoja.
Seuraavassa on joitakin merkintöjä ja käsitteitä, joista on hyötyä
useassa kirjan kohdassa.

\subsection{Summakaavat}

Voimme laskea lukujen $1,2,\dots,n$ summan kaavalla
\[1+2+\dots+n = \frac{n(n+1)}{2}.\]
Esimerkiksi
\[1+2+3+4+5 = \frac{5 \cdot 6}{2}=15.\]
Kaavan voi ymmärtää niin, että laskemme yhteen $n$ lukua,
joiden suuruus on \emph{keskimäärin} $(n+1)/2$.

Toinen hyödyllinen kaava on
\[2^0+2^1+\dots+2^n = 2^{n+1}-1.\]
Esimerkiksi
\[1+2+4+8+16=32-1.\]
Tässä voimme ajatella, että aloitamme luvusta $2^n$
ja lisäämme siihen aina puolet pienemmän luvun lukuun $1$ asti.
Tämän seurauksena pääsemme yhtä vaille lukuun $2^{n+1}$ asti.

Esitämme joskus summia merkinnän $\sum$ avulla.
Siinä on ideana antaa muuttujan ala- ja yläraja sekä
joka askeleella summaan lisättävä arvo.
Esimerkiksi voimme merkitä
\[1^2 + 2^2 + \dots + n^2 = \sum_{i=1}^n i^2.\]

Tämä merkintä on itse asiassa hyvin lähellä ohjelmoinnin
for-silmukkaa, koska seuraava koodi ajaa saman asian:

\begin{code}
int summa = 0;
for (int i = 1; i <= n; i++) {
    summa += i*i;
}
\end{code}

\subsection{Logaritmit}

Logaritmin määritelmän mukaan $\log_b(n)=x$
tarkalleen silloin kun $b^x=n$.
Esimerkiksi $\log_2(32)=5$, koska $2^5=32$.

Algoritmiikassa logaritmin kantaluku $b$ on usein 2,
ja voimme ajatella, että logaritmi kertoo, montako kertaa
meidän tulee \emph{puolittaa} luku $n$, ennen kuin pääsemme lukuun 1.
Esimerkiksi $\log_2(32)=5$, koska tarvitsemme 5 puolitusta:
\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1\]

Logaritmeille pätee kaavat
\[\log_b(x \cdot y) = \log_b(x)+\log_b(y)\]
ja
\[\log_b(x / y) = \log_b(x)-\log_b(y).\]
Ylemmästä kaavasta seuraa myös
\[\log_b(x^k) = k \log_b(x).\]
Lisäksi voimme vaihtaa logaritmin kantalukua kaavalla
\[\log_u(x) = \frac{\log_b(x)}{\log_b(u)}.\]