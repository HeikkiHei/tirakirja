\chapter{Johdanto}

Kurssin \emph{Tietorakenteet ja algoritmit} tarkoituksena
on opettaa menetelmiä, joiden avulla voimme ratkaista
\emph{tehokkaasti} laskennallisia ongelmia.
Ohjelmoinnin peruskursseilla olemme keskittyneet
ohjelmointitaidon opetteluun.
Nyt on aika siirtyä askel eteenpäin ja alkaa kiinnittää
huomiota myös siihen, miten nopeasti algoritmit toimivat.

Algoritmien tehokkuudella on suuri merkitys käytännössä.
Esimerkiksi netissä toimiva reittiopas on käyttökelpoinen sen vuoksi,
että se antaa ehdotuksen reitistä heti sen jälkeen, kun olemme
ilmoittaneet, mistä mihin haluamme matkustaa.
Jos reittiehdotusta pitäisi odottaa vaikkapa minuutti tai tunti,
tämä rajoittaisi paljon palvelun käyttöä.

Jotta reittiopas toimisi tehokkaasti, sen taustalla on
hyvin suunniteltu algoritmi.
Tällä kurssilla opimme, kuinka voimme luoda itse vastaavia algoritmeja.
Tutustumme kurssilla sekä algoritmien suunnittelun teoriaan että
käytäntöön -- haluamme ymmärtää syvällisesti, mistä algoritmeissa on kysymys,
mutta myös osata toteuttaa niitä käytännössä.

\section{Mitä algoritmit ovat?}

\index{algoritmi}
\index{syöte}
\index{tuloste}

\emph{Algoritmi} on toimintaohje, jota seuraamalla voimme ratkaista
jonkin laskennallisen ongelman.
Algoritmille annetaan \emph{syöte} (\emph{input}),
joka kuvaa ratkaistavan ongelman tapauksen,
ja algoritmin tulee tuottaa \emph{tuloste} (\emph{output}),
joka on vastaus sille annettuun syötteeseen.

Tarkastellaan esimerkkinä ongelmaa,
jossa syötteenä on $n$ kokonaislukua sisältävä taulukko ja
tehtävänä on laskea lukujen summa.
Esimerkiksi jos syöte on $[2,4,1,8]$,
haluttu tuloste on 15, koska $2+4+1+8=15$.
Voimme ratkaista tämän ongelman algoritmilla,
joka käy luvut läpi silmukalla ja laskee niiden
summan muuttujaan.

Algoritmin toiminnan esittämiseen on useita mahdollisuuksia.
Yksi tapa on selostaa sanallisesti, kuinka algoritmi toimii,
kuten teimme äsken.
Toinen tapa taas on antaa koodi, joka toteuttaa algoritmin.
Tällöin meidän täytyy valita jokin ohjelmointikieli,
jonka avulla esitämme algoritmin.
Esimerkiksi seuraava Java-koodi kuvaa algoritmin,
joka laskee lukujen summan:

\begin{code}
int summa = 0;
for (int i = 0; i < n; i++) {
    summa += luvut[i];
}
System.out.println(summa);
\end{code}

\index{pseudokoodi}

Voimme myös esittää algoritmin \emph{pseudokoodina}
todellisen ohjelmointikielen sijasta.
Tämä tarkoittaa, että kirjoitamme koodia,
joka on lähellä käytössä olevia ohjelmointikieliä, mutta voimme
päättää koodin tarkan kirjoitusasun itse ja ottaa joitakin vapauksia,
joiden ansiosta voimme kuvata algoritmin mukavammin.
Voisimme esimerkiksi esittää äskeisen algoritmin pseudokoodina seuraavasti:

\begin{code}
summa = 0
for i = 0 to n-1
    summa += luvut[i]
print(summa)
\end{code}

Tässä kirjassa esitämme algoritmeja sekä Java-koodina että pseudokoodina
tilanteesta riippuen.
Käytämme Java-koodia silloin, kun haluamme kiinnittää huomiota siihen,
miten jokin asia toteutetaan tarkalleen Javassa.
Pseudokoodia käytämme taas silloin, kun haluamme kuvata algoritmin yleisen
idean eikä käytetyllä kielellä ole merkitystä.

\section{Ohjelmoinnin peruspalikat}

Kiehtova seikka ohjelmoinnissa on, että monimutkaisetkin algoritmit
syntyvät yksinkertaisista aineksista.
Käymme seuraavaksi läpi ohjelmoinnin peruspalikat,
jotka muodostavat pohjan algoritmien suunnittelulle.
Tutustumme myös samalla tarkemmin kirjassa käytettyyn pseudokoodiin.

\subsubsection{Muuttuja}

\index{muuttuja}
\emph{Muuttuja} (\emph{variable}) sisältää yksittäisen algoritmin
käsittelemän tiedon, kuten lukuarvon, totuusarvon (\texttt{true}/\texttt{false}) tai merkkijonon.
Esimerkiksi seuraava Java-koodi määrittelee kolme \texttt{int}-muuttujaa:

\begin{code}
int a = 5;
int b = 7;
int c = a+b;
\end{code}

Pseudokoodissa käytämme muuttujia samaan tapaan,
mutta emme merkitse niiden tyyppiä erikseen:

\begin{code}
a = 5
b = 7
c = a+b
\end{code}

\subsubsection{Ehtolause}

\index{ehtolause}
\emph{Ehtolause} (\emph{conditional statement}) saa ohjelman
toiminnan riippumaan esimerkiksi muuttujista.
Seuraava Java-koodi ilmoittaa, onko muuttujan $x$ arvo parillinen vai pariton:

\begin{code}
if (x%2 == 0) {
    System.out.println("parillinen");
} else {
    System.out.println("pariton");
}
\end{code}

Vastaava pseudokoodi on seuraavanlainen:

\begin{code}
if x%2 == 0
    print("parillinen")
else
    print("pariton")
\end{code}

\subsubsection{Silmukka}

\index{silmukka}
\emph{Silmukka} (\emph{loop}) toistaa sen sisällä olevaa koodia.
Tavalliset silmukat ovat for-silmukka,
jonka avulla voi käydä läpi tietyn lukuvälin,
sekä while-silmukka,
joka jatkuu niin kauan kuin haluttu ehto on voimassa.

Esimerkiksi seuraava Java-koodi tulostaa luvut $1,2,\dots,100$:

\begin{code}
for (int i = 1; i <= 100; i++) {
    System.out.println(i);
}
\end{code}

Tässä on vastaava pseudokoodi:

\begin{code}
for i = 1 to 100
    print(i)
\end{code}

Seuraava Java-koodi puolestaan tulostaa positiivisia lukuja luvusta $x$ alkaen
ja puolittaa luvun joka askeleella.

\begin{code}
while (x >= 1) {
    System.out.println(x);
    x /= 2;
}
\end{code}

Esimerkiksi jos $x=50$, koodi tulostaa luvut 50, 25, 12, 6, 3 ja 1.
Vastaava pseudokoodi on seuraavanlainen:

\begin{code}
while x >= 1
    print(x)
    x /= 2
\end{code}

\subsubsection{Taulukko}

\index{taulukko}
\index{tietorakenne}
\index{indeksi}

\emph{Taulukko} (\emph{array}) on ohjelmoinnin tavallisin \emph{tietorakenne}
(\emph{data structure})
eli tapa säilyttää kokoelmaa tietoa ohjelmassa.
Taulukossa on $n$ alkiota, joiden kohdat (eli indeksit) ovat $0,1,\dots,n-1$.

Esimerkiksi seuraava Java-koodi luo taulukon,
jossa on 5 kokonaislukua. Aluksi jokainen luku on 0,
ja sitten koodi muuttaa kohtia 0 ja 3.

\begin{code}
int[] luvut = new int[5];
luvut[0] = 4;
luvut[3] = 2;
\end{code}

Pseudokoodissa taulukkoa käytetään muuten samalla tavalla,
mutta usein taulukkoa ei määritellä erikseen:

\begin{code}
luvut[0] = 4
luvut[3] = 2
\end{code}

Taulukko on mainio tietorakenne, mutta siinä on kaksi heikkoutta:
(1) taulukon kokoa ei voi muuttaa määrittelyn jälkeen ja
(2) tietyn alkion etsiminen suuresta taulukosta on hidasta.
Kurssin aikana tutustumme muihin tietorakenteisiin,
jotka ratkaisevat nämä ongelmat.

Taulukko on tärkeä tietorakenne myös sen vuoksi,
että tietokoneen muisti on kuin suuri taulukko.
Niinpä minkä tahansa muun tietorakenteen voi toteuttaa
taulukon avulla.

\subsubsection{Aliohjelma}

\index{aliohjelma}
\index{metodi}
\index{proseduuri}
\index{funktio}

\emph{Aliohjelma} (\emph{subprogram}) on ohjelman osa, jota voi kutsua parametreilla.
Aliohjelmalle on monia eri nimiä kielestä riippuen,
ja Javassa käytetään nimeä \emph{metodi} (\emph{method}).

Tässä kirjassa käytäntönä on,
että \emph{proseduuri} (\emph{procedure}) on aliohjelma,
joka ei palauta mitään (Javassa \texttt{void}),
ja \emph{funktio} (\emph{function}) on aliohjelma,
jolla on palautusarvo.

Esimerkiksi seuraava Java-metodi tulostaa luvut $1,2,\dots,n$:

\begin{code}
void tulosta(int n) {
    for (int i = 1; i <= n; i++) {
        System.out.println(i);
    }
}
\end{code}

Tätä vastaa pseudokoodina seuraava proseduuri:

\begin{code}
procedure tulosta(n)
    for i = 1 to n
        print(i)
\end{code}

Seuraava Java-metodi puolestaan laskee summan $1+2+\dots+n$:

\begin{code}
int summa(int n) {
    int s = 0;
    for (int i = 1; i <= n; i++) {
        s += i;
    }
    return s;
}
\end{code}

Tätä vastaa pseudokoodina seuraava funktio:

\begin{code}
function summa(n)
    s = 0
    for i = 1 to n
        s += i
    return s
\end{code}

\subsubsection{Rekursio}

\index{rekursio}

Usein algoritmien suunnittelussa esiintyvä ohjelmointitekniikka on
\emph{rekursio} (\emph{recursion}),
joka tarkoittaa, että aliohjelma kutsuu itseään.
Tässä on yksi esimerkki rekursion käyttämisestä:

\begin{code}
procedure testi(n)
    if n == 0
        return
    else
        print("moikka")
        testi(n-1)
\end{code}

Tämä proseduuri tulostaa $n$ kertaa rivin "moikka".
Esimerkiksi kutsu \texttt{testi}(3) saa aikaan seuraavan tulostuksen:

\begin{code}
moikka
moikka
moikka
\end{code}

Ideana on, että jos $n=0$, proseduuri ei tee mitään,
koska ei ole mitään tulostettavaa.
Muussa tapauksessa proseduuri tulostaa rivin "moikka"
ja kutsuu sitten itseään parametrilla $n-1$.

Käytämme rekursiota usein kurssin aikana,
ja tutustumme pikkuhiljaa tarkemmin sen mahdollisuuksiin.

\subsubsection{***}

Olemme nyt käyneet läpi ainekset,
joiden avulla voimme toteuttaa \emph{minkä tahansa} algoritmin.
On huojentava tieto, että näinkin pieni määrä tekniikoita
riittää algoritmien suunnittelussa.
Nyt kaikki on vain kiinni siitä, miten osaamme \emph{soveltaa}
näitä tekniikoita eri tilanteissa.
