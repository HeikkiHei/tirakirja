\chapter{Hajautustaulu}

Hajautustaulu on tietorakenne,
jonka avulla voimme pitää yllä alkioiden joukkoa,
jossa on seuraavat operaatiot:

\begin{itemize}
\item lisää alkio $x$ joukkoon
\item tarkista, onko alkio $x$ joukossa
\item poista alkio $x$ joukosta
\end{itemize}

Yksi tapa toteuttaa tällainen joukko olisi tallentaa
alkiot listaan.
Esimerkiksi voisimme säilyttää alkioita listalla
järjestyksessä, jolloin voisimme selvittää binäärihaulla,
kuuluuko tietty alkio joukkoon.
Tällaista tietorakennetta käyttäen alkion tarkistaminen
veisi aikaa $O(\log n)$ ja alkion lisääminen ja poistaminen
veisivät aikaa $O(n)$.
Ratkaisu ei ole tyydyttävä, koska lisääminen ja poistaminen
toimivat hitaasti.

Jos voisimme olettaa, että alkiot ovat sopivan pieniä kokonaislukuja,
voisimme myös toteuttaa joukon taulukkona $\texttt{joukko}$,
jossa kohta $\texttt{joukko}[x]$ kertoo meille,
kuuluuko alkio $x$ joukkoon vai ei.
Esimerkiksi voisimme sopia, että taulukossa on luku 1,
jos alkio kuuluu joukkoon, ja muuten luku 0.
Tällaisen taulukon avulla voisimme toteuttaa kaikki
joukon operaatiot ajassa $O(1)$, mutta joudumme rajoittumaan
pieniin kokonaislukuihin joukon alkioina.

Tässä luvussa keskitymme yleisempään tilanteeseen,
jossa alkiot eivät ole välttämättä sopivan pieniä kokonaislukuja
vaan ne voivat olla minkä tahansa tyyppisiä, esimerkiksi merkkijonoja.
Osoittautuu, että voimme yleistää yllä olevan idean toteuttamalla
hajautustaulun, jossa jokaisen alkion sijainnin määrää sen hajautusarvo,
ja pystymme edelleen toteuttamaan kaikki operaatiot
tehokkaasti keskimäärin $O(1)$-aikaisesti.

\section{Hajautustaulun toteutus}

Toteutamme hajautustaulun taulukkona,
jossa on $n$ alkiota.
Jokaisessa hajautustaulun kohdassa on lista,
jossa voi olla joukossa olevia alkioita.
Jotta voimme käyttää hajautustaulua,
meillä täytyy olla myös \emph{hajautusfunktio},
jonka avulla voimme laskea mille tahansa alkiolle
\emph{hajautusarvon} eli kohdan, johon alkio
tallennetaan hajautustaulussa.

\begin{figure}
\begin{tikzpicture}[scale=0.5]
\draw (0,0) grid (10,1);
\foreach \x in {0,1,...,9} \node at (0.5+\x,0.5) {\x};
\draw[->,thick] (2.5,0) -- (2.5,-1);
\draw[->,thick] (7.5,0) -- (7.5,-1);
\draw[->,thick] (2.5,-2) -- (2.5,-3);
\node at (2.5,-1.5) {\texttt{apina}};
\node at (7.5,-1.5) {\texttt{banaani}};
\node at (2.5,-3.5) {\texttt{cembalo}};
\end{tikzpicture}
\caption{Hajautustaulu, joka vastaa joukkoa $\{\texttt{apina},\texttt{banaani},\texttt{cembalo}\}$.
Merkkijonojen \texttt{apina} ja \texttt{cembalo} hajautusarvo on 2, ja merkkijonon
\texttt{banaani} hajautusarvo on 7.}
\label{fig:hajtau}
\end{figure}

Kuvassa \ref{fig:hajtau} on esimerkkinä hajautustaulu, jossa on
merkkijonot \texttt{apina}, \texttt{banaani} ja \texttt{cembalo}.
Tässä hajautustaulussa $n=10$, joten voimme tallentaa alkioita
listoihin kohtiin $0,1,\dots,9$.
Merkkijonojen \texttt{apina} ja \texttt{cembalo}
hajautusarvo on 2, joten ne ovat samassa listassa kohdassa 2.
Merkkijonon \texttt{banaani} hajautusarvo taas on 7,
joten se on yksin omassa listassaan.
Kaikki muut hajautustaulun listat ovat tällä hetkellä tyhjiä.

Kun olemme luoneet hajautustaulun, voimme tarkistaa,
onko tietty alkio joukossa, laskemalla sen hajautusarvon
ja käymällä läpi vastaavan listan.
Vastaavasti voimme lisätä alkion joukkoon
lisäämällä sen listan loppuun ja poistaa
alkion joukosta poistamalla sen listasta.
Näiden operaatioiden aikavaativuus on $O(k)$,
missä $k$ on alkion hajautusarvoa vastaavan listan pituus,
koska meidän täytyy käydä läpi listalla olevat alkiot.
Hajautustaulun tehokkuus riippuukin siitä,
kuinka pitkiä listat ovat.

\subsection{Hajautusfunktio}

Hajautusfunktio määrittää, mihin kohtaan hajautustaulua
alkio sijoitetaan.
Sen täytyy antaa jokaiselle mahdolliselle alkiolle
hajautusarvo eli kokonaisluku väliltä $0 \dots n-1$,
missä $n$ on hajautustaulun koko.
Muuten meillä on vapaat kädet hajautusfunktion suunnitteluun:
ainoa välttämätön vaatimus on, että tietty alkio saa aina
saman hajautusarvon, jotta voimme löytää sen uudelleen
hajautustaulusta.

Jotta hajautustaulu olisi käyttökelpoinen, hajautusfunktioon
liittyy kuitenkin toinenkin vaatimus:
sen tulisi jakaa alkiot mahdollisimman \emph{tasaisesti}
eri puolille hajautustaulua.
Jos alkiot ovat jakautuneet tasaisesti ja listat ovat lyhyitä,
voimme lisätä, etsiä ja poistaa alkioita tehokkaasti.

\begin{figure}
\begin{tikzpicture}[scale=0.5]
\begin{scope}
\draw (0,0) grid (10,1);
\foreach \x in {0,1,...,9} \node at (0.5+\x,0.5) {\x};
\draw[->,thick] (1.5,0) -- (1.5,-1);
\draw[->,thick] (4.5,0) -- (4.5,-1);
\draw[->,thick] (8.5,0) -- (8.5,-1);
\node at (1.5,-1.5) {\texttt{apina}};
\node at (8.5,-1.5) {\texttt{banaani}};
\node at (4.5,-1.5) {\texttt{cembalo}};
\end{scope}
\begin{scope}[xshift=15cm]
\draw (0,0) grid (10,1);
\foreach \x in {0,1,...,9} \node at (0.5+\x,0.5) {\x};
\draw[->,thick] (3.5,0) -- (3.5,-1);
\draw[->,thick] (3.5,-4) -- (3.5,-5);
\draw[->,thick] (3.5,-2) -- (3.5,-3);
\node at (3.5,-1.5) {\texttt{apina}};
\node at (3.5,-5.5) {\texttt{banaani}};
\node at (3.5,-3.5) {\texttt{cembalo}};
\end{scope}
\end{tikzpicture}
\caption{Kaksi hajautustaulua joukolle $\{\texttt{apina},\texttt{banaani},\texttt{cembalo}\}$.
Vasemmassa taulussa hajautus on onnistunut täydellisesti,
oikeassa taulussa kaikki alkiot ovat samassa listassa.}
\label{fig:hajjak}
\end{figure}

Kuva \ref{fig:hajjak} näyttää kaksi hajautustaulua, jotka vastaavat
samaa joukkoa kahdella eri hajautusfunktiolla.
Vasemmassa taulussa hajautus on onnistunut täydellisesti
ja jokainen alkio on omassa listassaan.
Oikeassa taulussa taas kaikki alkiot ovat joutuneet samaan
listaan eikä hajautuksesta ole mitään hyötyä.
Tavoitteemme on, että saisimme aikaan hajautusfunktion,
jonka toiminta on lähempänä vasenta taulua.

Tarkastelemme seuraavaksi esimerkkinä hajautusfunktioita,
joilla voi laskea hajautusarvoja merkkijonoille.
Käytännössä meidän riittää määritellä hajautusfunktio,
joka muuttaa merkkijonon epänegatiiviseksi kokonaisluvuksi,
koska tämän jälkeen saamme helposti kokonaisluvun
väliltä $0 \dots n-1$ ottamalla alkuperäisestä luvusta jakojäännöksen $n$:llä.

Oletamme, että merkkijonossa on $k$ merkkiä,
joiden merkkikoodit\footnote{Käytämme tässä merkkien ASCII-koodeja.
Esimerkiksi Javassa char-merkin \texttt{c} koodin saa
selville kirjoittamalla \texttt{(int)c}, eli esimerkiksi
\texttt{(int)'a'} on 97.} ovat $c_0,c_1,\dots,c_{k-1}$.
Esimerkiksi jos merkkijono on \texttt{apina},
$k=5$ ja koodit ovat $c_0=97$, $c_1=112$, $c_2=105$,
$c_3=110$ ja $c_4=97$.
Seuraavassa on kolme mahdollista tapaa määritellä hajautusfunktio:

\begin{enumerate}
\item Hajautusarvo on merkkijonon pituus $k$.
Esimerkiksi merkkijonon \texttt{apina} hajautusarvo on 5.
\item Hajautusarvo on merkkikoodien summa
\[ c_0 + c_1 + \dots + c_{k-1}.\]
Esimerkiksi merkkijonon \texttt{apina} hajautusarvo on
\[97+112+105+110+97=521.\]
\item Hajautusarvo on painotettu merkkikoodien summa
\[ A^{k-1} c_0 + A^{k-2} c_1 + \dots + A^0 c_{k-1},\]
missä $A$ on sopiva vakio.
Esimerkiksi jos $A=7$, merkkijonon \texttt{apina} hajautusarvo on
\[7^4 \cdot 97+7^3 \cdot 112+7^2 \cdot 105+7^1 \cdot 110+7^0 \cdot 97=61235.\]
\end{enumerate}

Kaikki yllä olevat hajautusfunktiot ovat toimivia,
mutta ne eivät ole yhtä hyviä.
Funktio 1 ei ole hyvä, koska se antaa monelle
usein esiintyvälle merkkijonolle saman hajautusarvon.
Esimerkiksi suomen kielessä on suuri määrä viisikirjaimisia
sanoja ja ne kaikki saavat saman hajautusarvon tätä
hajautusfunktiota käyttämällä.
Funktio 2 on jo parempi, mutta siinä on heikkoutena,
että jos kahdessa merkkijonossa on samat merkit eri
järjestyksessä, ne saavat aina saman hajautusarvon.
Funktio 3 eli \emph{polynominen hajautus} korjaa tämän puutteen
asettamalla summaan painoja, jotka riippuvat merkkien kohdista.
Tämä on käytännössä hyvä tapa luoda hajautusfunktio,
jota käytetään esimerkiksi Javan standardikirjastossa.

\subsection{Hajautuksen tehokkuus}

Hajautuksen tehokkuus riippuu kahdesta asiasta:
kuinka suuri hajautustaulu on (parametri $n$)
sekä miten tasaisesti hajautusfunktio jakaa alkiota
eri puolille hajautustaulua.
Jos oletamme, että alkiot jakautuvat tasaisesti
ja joukossa on yhteensä $m$ alkiota,
jokaiseen listaan osuu noin $m/n$ alkiota
eli hajautustaulun operaatiot toimivat $O(m/n)$-ajassa.
Jos edelleen $n$ on valittu niin suureksi,
että $m/n$ on pieni vakio, voimme ajatella,
että hajautustaulun operaatiot toimivat $O(1)$-ajassa.

Tämän analyysin heikkoutena on, että \emph{oletamme}
hajautusfunktion toimivan hyvin ja jakavan alkioita
tasaisesti hajautustauluun. Entä jos näin ei olekaan?
Jos käytämme polynomista hajautusta, miten vakio $A$
pitäisi valita, jotta hajautus onnistuisi hyvin?

Kaikeksi onneksi hajautus toimii yleensä aina käytännössä hyvin.
Riski siitä, että jokainen tai edes suuri osa alkioista
menisi samaan listaan, on niin pieni,
että siitä ei tarvitse murehtia.
Jotkut suosittelevat valitsemaan $A$:n alkuluvuksi,
joka ei ole lähellä 2:n potensseja,
mutta käytännössä muutkaan $A$:n arvot tuskin
tuottavat ongelmia.

Hajautustaulun tehokkuus riippuu kuitenkin aina myös siitä,
mitä alkioita sinne laitetaan.
Vaikka olisimme valinneet hajautustaulun koon ja
hajautusfunktion miten huolellisesti tahansa,
ilkeä vastustaja voi kuitenkin antaa meillä alkioita,
joilla kaikilla on sama hajautusarvo ja jotka
menevät samaan listaan hajautustaulussa.
Tällöin hajautustaulun operaatiot vievät aikaa $O(m)$.
Luvussa 5.2.4 näemme tästä konkreettisen esimerkin.

\section{Hajautus Javassa}

Javassa on kaksi hajautustaulua käyttävää tietorakennetta:
\texttt{HashSet} pitää yllä alkioiden joukkoa
hajautustaulun avulla, ja \texttt{HashMap} säilyttää
joukkoa avain-arvo-pareja, mitä voi ajatella taulukon yleistyksenä.
Seuraavaksi tutustumme tarkemmin näihin rakenteisiin.

\subsection{\texttt{HashSet}-rakenne}

Javan \texttt{HashSet}-rakenne pitää yllä joukkoa alkioista.
Joukkoon voi lisätä alkion metodilla \texttt{add},
ja siitä voi poistaa alkion metodilla \texttt{remove}.
Esimerkiksi seuraava koodi luo joukon, jossa voi olla
kokonaislukuja, ja lisää siihen luvut 3, 5 ja 8.
Tämän jälkeen koodi poistaa luvun 5 joukosta.

\begin{code}
HashSet<Integer> joukko = new HashSet<>();
joukko.add(3);
joukko.add(5);
joukko.add(8);
System.out.println(joukko); // [3, 5, 8]
joukko.remove(5);
System.out.println(joukko); // [3, 8]
\end{code}

Metodin \texttt{contains} avulla voimme selvittää,
esiintyykö tietty alkio joukossa.

\begin{code}
if (joukko.contains(5)) {
    System.out.println("Luku 5 on joukossa");
}
\end{code}

Huomaa, että jokainen alkio voi esiintyä vain kerran joukossa.
Esimerkiksi vaikka seuraava koodi lisää luvun 5 kolmesti
joukkoon, se menee sinne vain ensimmäisellä kerralla ja
muut lisäykset jätetään huomiotta.

\begin{code}
HashSet<Integer> joukko = new HashSet<>();
joukko.add(5);
joukko.add(5);
joukko.add(5);
System.out.println(joukko); // [5]
\end{code}

\subsection{\texttt{HashMap}-rakenne}

\texttt{HashMap}-rakenne pitää yllä joukkoa avain-arvo-pareja.
Rakennetta voi ajatella taulukon yleistyksenä:
$n$ alkion taulukossa avaimet ovat aina kokonaisluvut
$0,1,\ldots,n-1$, mutta \texttt{HashMap} sallii
avaimina minkä tahansa tyyppisiä alkioita eikä niiden
tarvitse olla peräkkäisiä kokonaislukuja.

\texttt{HashMap}-rakenteen määrittelyssä annetaan
kaksi tyyppiä: avaimen ja arvon tyyppi.
Esimerkiksi seuraava koodi luo sanakirjan, jossa sekä
avaimet että arvot ovat merkkijonoja.
Syötämme sanakirjaan merkkijonopareja, jotka kertovat
sanan käännöksen suomesta englanniksi.
Metodi \texttt{put} lisää uuden avain-arvo-parin,
ja metodi \texttt{get} hakee arvon avaimen perusteella.

\begin{code}
HashMap<String,String> sanakirja = new HashMap<>();

sanakirja.put("apina","monkey");
sanakirja.put("banaani","banana");
sanakirja.put("cembalo","harpsichord");

System.out.println(sanakirja.get("banaani")); // banana
\end{code}

Hyödyllinen on myös metodi \texttt{containsKey},
jonka avulla voi tarkastaa, onko tietylle avaimelle
tallennettu arvoa:

\begin{code}
if (sanakirja.containsKey(sana)) {
    System.out.println("Käännös: " + sanakirja.get(sana));
} else {
    System.out.println("Sana puuttuu sanakirjasta!");
}
\end{code}

Koska \texttt{HashMap} on toteutettu hajautustaulun avulla,
sen operaatiot toimivat tehokkaasti keskimäärin $O(1)$-ajassa.

\subsection{\texttt{hashCode}-metodi}

Javan hajautustaulut perustuvat siihen, että olioissa
on metodi \texttt{hashCode}, jonka avulla olio kertoo
pyydettäessä hajautusarvonsa.
Voimme esimerkiksi selvittää merkkijonon \texttt{apina}
hajautusarvon näin:

\begin{code}
System.out.println("apina".hashCode());
\end{code}

Tämä koodi tulostaa luvun 93022541,
joka on siis merkkijonon \texttt{apina} hajautusarvo Javassa.
On tunnettua, että Java käyttää merkkijonon hajautusarvon laskemiseen
polynomista hajautusta vakiolla $A=31$,
joten voimme laskea Javan hajautusarvon myös itse kaavalla
\[31^4 \cdot 97+31^3 \cdot 112+31^2 \cdot 105+31^1 \cdot 110+31^0 \cdot 97=93022541.\]

Metodi \texttt{hashCode} on toteutettu valmiiksi Javan
sisäisiin tyyppeihin, kuten \texttt{Integer} ja \texttt{String},
joten voimme käyttää niitä suoraan hajautustauluissa.
Kuitenkin jos meillä on itse tehty luokka, jonka olioita
haluamme käyttää hajautustauluissa, meidän on toteutettava
itse metodi \texttt{hashCode}.

Esimerkiksi jos meillä on luokka \texttt{Piste},
jossa on kenttinä kokonaisluvut \texttt{x} ja \texttt{y},
voisimme toteuttaa metodin \texttt{hashCode} seuraavasti:

\begin{code}
public class Piste {
    public int x, y;

    int hashCode() {
        return 97*x+y;
    }
}
\end{code}

Tässä toteutuksessa siis pisteen $(x,y)$ hajautusarvo lasketaan
kaavalla $97x+y$, missä 97 on valitsemamme vakio, jolla ei ole
syvällistä merkitystä.
Nyt kun hajautusfunktio on kunnossa,
voimme luoda vaikkapa \texttt{HashSet}-rakenteen, jossa on pisteitä:

\begin{code}
HashSet<Piste> joukko = new HashSet<Piste>();
\end{code}

\section{Esimerkki: Yhteiset sanat}

\section{Hajautuksen rikkominen}
