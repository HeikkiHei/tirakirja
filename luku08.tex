\chapter{Algoritmien suunnittelu}

Kuinka voi suunnitella hyvän algoritmin?
On selvää, ettei tähän kysymykseen ole yhtä helppoa vastausta.
Yhtä hyvin voisi kysyä, kuinka voi kirjoittaa hyvän kirjan
tai säveltää hyvää musiikkia.
Algoritmien suunnittelu on taito, jonka oppiminen vie aikaa.

Algoritmisen ongelman ratkaisemisessa on usein kaksi vaihetta.
Ensim\-mäinen vaihe on keksiä algoritmin yleisidea,
mikä vaatii havaintoja ja oivalluksia ongelmasta.
Tämän jälkeen toinen vaihe on löytää hyvä ja tehokas tapa
toteuttaa algoritmi.
Tässä voimme käyttää apuna järjestämistä, tietorakenteita
ja muita tekniikoita.

Kuten aiemminkin, haluamme saada aikaan tehokkaita algoritmeja,
jotka vievät aikaa $O(n)$ tai $O(n \log n)$.
Tämä tarkoittaa käytännössä sitä, että voimme käydä läpi ja
järjestää syötettä sekä käyttää tietorakenteita,
joissa on tehokkaita operaatioita.
Tämä rajaa sitä, mitä voimme tehdä algoritmissa, ja ohjaa
algoritmin suunnittelua.

\section{Ratkaisun vaiheet}

Tarkastellaan esimerkkinä tehtävää,
jossa $n$ lasta haluaa mennä maailmanpyörään.
Jokaisessa korissa voi istua yksi tai kaksi lasta.
Tiedämme jokaisen lapsen painon,
ja jokaisessa korissa suurin istujien
yhteispaino saa olla $x$.
Mikä on pienin mahdollinen määrä koreja,
joka riittää lapsille?
Oletamme, ettei yhdenkään lapsen paino ylitä
korin maksimipainoa.

Esimerkiksi jos lasten määrä on $n=5$,
lasten painot ovat $[2,2,4,5,8]$ ja korin painoraja on $x=8$,
pienin mahdollinen korien määrä on kolme.
Tässä tapauksessa voimme muodostaa korit
$[2,4]$, $[2,5]$ ja $[8]$.
Tämä on optimaalinen ratkaisu, koska selvästikään
ei riitä, että koreja olisi vain kaksi.

\subsubsection{Vaihe 1: Yleisidean keksiminen}

On valtava määrä mahdollisia tapoja,
miten voimme sijoittaa lapsia koreihin,
minkä vuoksi olisi liian hidasta käydä läpi
kaikkia vaihtoehtoja.
Jotta saamme aikaan tehokkaan algoritmin,
meidän tulee keksiä jokin periaate,
jonka avulla voimme päättää nopeasti,
ketkä lapset ovat yhdessä koreissa.

Itse asiassa meidän riittää keskittyä ongelmaan,
jossa haluamme löytää \emph{seuraavaan} koriin
tulevat lapset.
Jos onnistumme tässä, voimme vain toistaa samaa,
kunnes kaikki lapset ovat koreissa.
Vaikeutena on kuitenkin, kuinka saamme tehtyä valinnan niin,
että tuloksena on varmasti optimaalinen ratkaisu.
Jos valitsemme väärällä tavalla koriin tulevat lapset,
saatamme vahingossa käyttää liikaa koreja.

Osoittautuu, että tässä tehtävässä toimiva algoritmi
on valita aina seuraavaan koriin \emph{painavin} lapsi sekä sen pariksi
jokin toinen lapsi niin, että painojen summa ei ylitä
korin maksimipainoa.
Jos ei ole mitään tapaa valita toista lasta,
laitamme painavimman lapsen koriin yksin.
Tällainen algoritmi on \emph{ahne}, eli se tekee aina jonkin
hyvältä tuntuvan valinnan, joka vie ratkaisua eteenpäin,
eikä peruuta koskaan tehtyjä valintoja.

Tarkastellaan taas esimerkkiä,
jossa lasten painot ovat $[2,2,4,5,8]$
ja korin maksimipaino on 8.
Kun käytämme yllä kuvattua algoritmia,
aloitamme lapsesta, jonka paino on 8.
Tämä lapsi saa oman korin, koska emme voi laittaa
samaan koriin ketään toista lasta.
Tämän jälkeen vuoroon tulee lapsi, jonka paino on 5,
ja se saa pariksi lapsen, jonka paino on 2.
Lopuksi käsittelemme lapsen, jonka paino on 4,
ja sen pariksi tulee lapsi, jonka paino on 2.
Tuloksena on ratkaisu, jossa on korit $[8]$, $[2,5]$ ja $[2,4]$.

Mutta miksi tämä ahne algoritmi toimii?
Tässä auttaa tarkastella, mitä tapahtuu,
kun algoritmi tekee ensimmäisen valintansa.
Painavin lapsi täytyy sijoittaa johonkin koriin,
ja meidän kannattaa tietenkin laittaa samaan koriin toinenkin lapsi,
jos tämä on mahdollista.
Tässä ei ole väliä, minkä toisen lapsen valitsemme,
koska jos jokin lapsi on riittävän kevyt toimiakseen
parina painavimman lapsen kanssa, niin se voi toimia parina
myös minkä tahansa muun lapsen kanssa.
Niinpä algoritmin ensimmäinen askel on optimaalinen.
Tämän jälkeen voimme toistaa vastaavan päättelyn
algoritmin seuraavissa askelissa, mikä tarkoittaa,
että koko algoritmi toimii oikein.

\subsubsection{Vaihe 2: Tehokas toteutus}

Meillä on nyt toimiva algoritmi,
mutta meidän täytyy vielä keksiä hyvä tapa toteuttaa se.
Jotta algoritmista tulee tehokas,
meidän tulee joka askeleella löytää nopeasti seuraavaan
koriin tuleva painavin lapsi sekä mahdollinen sen pariksi tuleva lapsi.
Ehkä helpoin tapa saavuttaa tämä tavoite on käyttää apuna järjestämistä.

Seuraava algoritmi järjestää ensin lasten painot ja alkaa sitten
jakaa lapsi koreihin.
Muuttuja $a$ lähtee liikkeelle taulukon alusta ja
osoittaa aina kevyimmän lapsen painoon.
Muuttuja $b$ puolestaan lähtee liikkeelle taulukon lopusta ja
osoittaa aina painavimman lapsen painoon.
Algoritmi laskee muuttujaan $k$, montako koria tarvitaan yhteensä.
Jos kevyimmän ja painavimman lapsen
painojen summa on enintään $x$, lapset sijoitetaan samaan koriin,
$a$ liikkuu oikealle ja $b$ liikkuu vasemmalle.
Jos taas painojen summa on suurempi kuin $x$,
painavin lapsi saa oman korin ja vain $b$ liikkuu vasemmalle.

\begin{code}
sort(painot)
a = 0, b = n-1
k = 0
while a <= b
    if painot[a]+painot[b] <= x
        a++, b--
    else
        b--
    k++
print(k)
\end{code}

Algoritmi järjestää ensin taulukon, missä menee aikaa $O(n \log n)$.
Tämän jälkeen \texttt{while}-silmukka vie aikaa $O(n)$,
koska joka kierroksella muuttujat $a$ ja $b$ siirtyvät
ainakin askeleen lähemmäs toisiaan.
Niinpä algoritmin kokonais\-aikavaativuus on $O(n \log n)$.

\section{Algoritmien aineksia}

Seuraavaksi käymme läpi \emph{aineksia},
joita esiintyy usein tehokkaissa algoritmeissa.
Nämä ainekset muodostavat hyvän perustan algoritmien
suunnittelemiseen: kun saamme vastaamme uuden ongelman,
voimme miettiä, voisimmeko hyödyntää aineksia jotenkin
ongelman ratkaisemisessa.

\subsection{Järjestäminen}

\index{järjestäminen}

Tehokas algoritmi perustuu usein tavalla tai
toisella järjestämiseen, joka voi näyttäytyä
monella tavalla algoritmissa.

Tarkastellaan esimerkkinä tehtävää, jossa annettuna on
$n$ kolikkoa ja haluamme löytää pienimmän rahamäärän,
jota \emph{emme} voi muodostaa summana kolikoista.
Jokaisella kolikolla on tietty kokonaislukuarvo, ja
muodostettava rahamäärä on myös kokonaisluku.
Esimerkiksi jos kolikot ovat $[1,2,2,7]$,
voimme muodostaa rahamäärät 1, 2, 3, 4 ja 5,
mutta emme voi muodostaa rahamäärää 6,
joten oikea vastaus on 6.

Algoritmien suunnittelussa auttaa usein
lähteä liikkeelle helpoista tapauksista.
Kun meillä on käytössämme tietyt kolikot,
hyvä ensimmäinen tavoite on koettaa muodostaa rahamäärä $1$.
Jotta onnistumme tässä, meillä on pakko olla kolikko,
jonka arvo on $1$.
Entä milloin voimme muodostaa rahamäärän $2$,
jos tiedämme, että voimme muodostaa rahamäärän $1$?
Tässä on kaksi vaihtoehtoa: meillä täytyy olla
toinen kolikko, jonka arvo on $1$, jolloin saamme
summan $1+1=2$, tai sitten kolikko, jonka arvo on $2$.

Tämä on hyvää päättelyä, mutta jotta saamme aikaan algoritmin,
meidän täytyy pystyä yleistämään se kaikkiin tapauksiin.
Voimme ajatella asiaa hieman toisesta näkökulmasta:
Meillä on joukko kolikoita, joiden avulla voimme muodostaa
rahamäärät $1,2,\dots,k$.
Miten voisimme muodostaa myös rahamäärän $k+1$?
Ratkaisu on, että tarvitsemme uuden kolikon,
jonka arvo on \emph{enintään} $k+1$.
Kun uuden kolikon arvo on $u \le k+1$,
voimme tämän jälkeen muodostaa rahamäärät $1,2,\dots,k+u$.
Tämän havainnon ansiosta voimme alkaa muodostaa ratkaisua
kolikko kerrallaan.
Lisäksi jos mahdollisia uusia kolikoita on useita,
voimme aina valita ahneesti \emph{pienimmän} kolikon,
koska pystymme valitsemaan suuremmat kolikot myöhemminkin.

Nyt meillä on kaikki ainekset tehokasta algoritmia varten.
Järjes\-tämme ensin kolikot ja muodostamme sitten ratkaisun
käymällä kolikot läpi pienimmästä suurimpaan.
Aloitamme tyhjästä ratkaisusta, jossa $k=0$.
Jokaisen kolikon kohdalla tiedämme,
että voimme muodostaa tällä hetkellä rahamäärät $1,2,\dots,k$,
joten voimme parantaa ratkaisua kolikon avulla,
jos sen arvo on enintään $k+1$.
Muuten lopetamme ratkaisun muodostamisen,
koska kaikki tulevat kolikot ovat vielä suurempia.
Lopuksi toteamme, että $k+1$ on pienin rahamäärä,
jota emme voi muodostaa.

\begin{code}
sort(kolikot)
k = 0
for i = 0 to n-1
    u = kolikot[i]
    if u <= k+1
        k += u
    else
        break
print(k+1)
\end{code}

Algoritmi järjestää ensin kolikot ajassa $O(n \log n)$
ja tämän jälkeen käy ne läpi ajassa $O(n)$,
joten algoritmin aikavaativuus on $O(n \log n)$.

\subsection{Tietorakenteet}

\index{tietorakenne}

Olemme tutustuneet kirjassa jo moniin tietorakenteisiin:
listaan, hajautustauluun, binäärihakupuuhun ja kekoon.
Näissä tietorakenteissa kannattaa kiinnittää erityisesti huomiota siihen,
mitkä operaatiot toimivat tehokkaasti $O(1)$- tai $O(\log n)$-ajassa.
Nämä ovat operaatioita, joita voimme käyttää tehokkaissa algoritmeissa.

Tarkastellaan esimerkkinä tehtävää, jossa haluamme laskea,
montako tapaa on valita taulukosta yhtenäinen osataulukko,
jossa lukujen summa on $x$.
Esimerkiksi jos taulukko on $[3,1,3,4,5]$ ja $x=4$,
niin tapoja on kolme: $[3,1]$, $[1,3]$ ja $[4]$.
On helppoa ratkaista tehtävä kahdella silmukalla ajassa $O(n^2)$,
mutta miten saisimme aikaan tehokkaan algoritmin?

Tässä auttaa muotoilla hieman toisin, mitä tarkoittaa,
että osataulukolla on tietty summa.
Merkitään $s(i)$:llä osataulukon summaa taulukon alusta
kohtaan $i$ asti, ja oletetaan lisäksi, että $s(-1)=0$.
Tätä merkintää käyttäen osataulukon summa
kohdasta $a$ kohtaan $b$ on
\[s(b)-s(a-1),\]
eli meidän riittää itse asiassa keskittyä vain taulukon alusta
alkavien osataulukoiden summiin.

Koska haluamme saada tehokkaan algoritmin,
hyvä tavoite olisi käydä taulukko läpi vain kerran.
Kun olemme taulukon kohdassa $i$,
monessako tähän kohtaan päättyvässä osataulukossa
lukujen summa on $x$?
Tämä tarkoittaa, että haluamme etsiä kohdat $j \le i$,
joille pätee
\[s(i)-s(j-1)=x\]
eli
\[s(j-1)=s(i)-x.\]
Saamme laskettua tällaisten kohtien määrän tehokkaasti,
kun pidämme taulukon läpikäynnissä kirjaa,
montako kertaa mikäkin summa on esiintynyt taulukon alkuosassa.
Voimme toteuttaa algoritmin seuraavasti:

\begin{code}
summat[0] = 1
laskuri = 0
summa = 0
for i = 0 to n-1
    summa += taulu[i]
    laskuri += summat[summa-x]
    summat[summa]++
print(laskuri)
\end{code}

Joka askeleella muuttuja \texttt{summa} sisältää
summan $s(i)$.
Rakenne \texttt{summat} pitää kirjaa,
montako kertaa mikäkin alkuosan summa on esiintynyt tähän mennessä.
Koska summat voivat olla suuria, tavallinen taulukko ei kelpaa,
mutta voimme käyttää hajautustauluun tai binäärihakupuuhun
perustuvaa hakemistoa.
Näin saamme aikaan ratkaisun, joka vie aikaa $O(n)$ tai $O(n \log n)$
riippuen valitusta tietorakenteesta.

\subsection{Binäärihaku}

\index{binäärihaku}

Binäärihaun tunnetuin käyttötarkoitus on alkion etsiminen
järjestetystä taulukosta ajassa $O(\log n)$.
Tämä on kuitenkin vain alkusoittoa sille,
mitä binää\-rihaulla pystyy tekemään ja mikä on sen
merkitys algoritmien suunnittelussa.
Binääri\-haun todellinen hyöty piilee siinä,
että pystymme etsimään sen avulla tehokkaasti funktion \emph{muutoskohdan}.

Oletetaan, että meillä on funktio $\texttt{ok}(x)$,
joka kertoo, onko $x$ kelvollinen ratkaisu tehtävään.
Lisäksi pätee $\texttt{ok}(x)=\texttt{false}$, kun $x<k$,
ja $\texttt{ok}(x)=\texttt{true}$, kun $x \ge k$.
Binäärihaun avulla voimme etsiä tehokkaasti,
mikä on funktion muutoskohta $k$
eli ensimmäinen kohta, jossa funktio saa arvon \texttt{true}.
Seuraava koodi toteuttaa haun, kun oletamme, että $k$ on välillä $1 \dots N$:

\begin{code}
a = 1, b = N
while a < b
    u = (a+b)/2
    if ok(u)
        b = u
    else
        a = u+1
k = a
\end{code}

Haun joka vaiheessa tiedämme, että muutoskohta on välillä $[a,b]$.
Laskemme keskikohdan $u=\lfloor (a+b)/2 \rfloor$ ja tutkimme funktion arvoa kohdassa $u$.
Jos pätee $\texttt{ok}(u)$, niin muutoskohdan on oltava välillä $[a,u]$,
ja muuten sen täytyy olla välillä $[u+1,b]$.
Lopulta välillä on vain yksi alkio, jolloin olemme löytäneet muutoskohdan.
Koska välin koko puolittuu joka askeleella,
kutsumme funktiota \texttt{ok} yhteensä $O(\log N)$ kertaa.

\begin{figure}
\center
\begin{tikzpicture}[scale=0.6]
\draw[->] (-1,1.5) -- (10,1.5);
\foreach \x in {0,...,8} \draw (\x,1.40) -- (\x,1.60);
\foreach \x in {0,...,8} \node at (\x,2) {\scriptsize $\x$};
\node at (-2,0) {kone $1$};
\draw[|-|] (0.05,0) -- (1.95,0);
\draw[|-|] (2.05,0) -- (3.95,0);
\draw[|-|] (4.05,0) -- (5.95,0);
\draw[|-|] (6.05,0) -- (7.95,0);
\node at (-2,-1.5) {kone $2$};
\draw[|-|] (0.05,-1.5) -- (2.95,-1.5);
\draw[|-|] (3.05,-1.5) -- (5.95,-1.5);
\node at (-2,-3) {kone $3$};
\draw[|-|] (0.05,-3) -- (6.95,-3);
\end{tikzpicture}
\caption{Optimaalinen tapa valmistaa 7 tavaraa vie 8 minuuttia,
kun koneiden nopeudet ovat $[2,3,7]$.}
\label{fig:optkon}
\end{figure}

Mutta mitä hyötyä on siitä, että löydämme tehokkaasti funktion muutoskohdan?
Tämä selviää seuraavassa tehtävässä:
Käytössämme on $n$ konetta
ja haluamme valmistaa niiden avulla $m$ tavaraa.
Tiedämme jokaisesta koneesta,
montako minuuttia kestää valmistaa yksi tavara konetta käyttäen,
ja haluamme löytää aikataulun, jota seuraamalla pystymme valmistamaan
$m$ tavaraa mahdollisimman nopeasti.

Kuva \ref{fig:optkon} näyttää parhaan aikataulun esimerkkitilanteessa,
jossa koneiden nopeudet ovat $[2,3,7]$ ja haluamme
valmistaa seitsemän tavaraa (eli $m=7$).
Käynnistämme koneen 1 neljästi kahden minuutin välein,
koneen 2 kahdesti kolmen minuutin välein ja koneen 3 kerran.
Viimeisenä pysähtyy kone 1, kun aloittamisesta
on kulunut kahdeksan minuuttia.

Voimme pukea tehtävän binäärihaulle sopivaan muotoon määrittämällä,
että $\texttt{ok}(x)=\texttt{true}$ tarkalleen silloin, kun voimme valmistaa
\emph{ainakin} $m$ tavaraa ajassa $x$.
Tällöin funktion muutoskohta $k$ vastaa tehtävän ratkaisua.
Entä miten voimme laskea funktion \texttt{ok} arvon?
Jos meillä on $u$ minuuttia aikaa ja koneella $i$ kestää $x_i$
minuuttia valmistaa yksi tavara, pystymme valmistamaan
$\lfloor u/x_i \rfloor$ tavaraa kyseistä konetta käyttäen.
Kun sitten käytössämme on kaikki koneet,
pystymme valmistamaan yhteensä
\[ s = \sum_{i=1}^n \lfloor u/x_i \rfloor \]
tavaraa. Niinpä $\texttt{ok}(u)=\texttt{false}$, jos $s<m$,
ja $\texttt{ok}(u)=\texttt{true}$, jos $s \ge m$.
Voimme toteuttaa tämän käytännössä seuraavasti:

\begin{code}
function ok(u)
    s = 0
    for i = 1 to n
        s += u/x[i]
    return s >= m
\end{code}

Voimme kytkeä tämän funktion suoraan binäärihakuun,
jolloin tuloksena on tehokas algoritmi tehtävän ratkaisemiseen.
Meidän täytyy kuitenkin vielä valita arvo $N$,
joka on jokin yläraja kohdalle $k$.
Tässä tehtävässä helppo valinta on
\[N = x_1 \cdot m,\]
mikä vastaa ratkaisua, jossa käytämme vain ensimmäistä konetta.
On varmaa, että oikea $k$:n arvo on korkeintaan $N$,
joten binäärihaku kutsuu $O(\log N)$ kertaa funktiota $\texttt{ok}$.
Koska jokainen funktion kutsu vie aikaa $O(n)$,
tuloksena on algoritmi, jonka aikavaativuus on $O(n \log N)$.

Huomaa, että $\log N$ on käytännössä pieni luku riippumatta
siitä, kuinka suuri luku $N$ on.
Niinpä meidän ei tarvitse murehtia siitä,
kuinka suuria $x_1$ ja $m$ ovat,
vaan voimme luottaa siihen, että algoritmi on tehokas.

\subsection{Tasoitettu analyysi}

\index{tasoitettu analyysi}

Voimme yleensä määrittää algoritmin aikavaativuuden
helposti katsomalla jokaisesta silmukasta,
montako kertaa siinä olevaa koodia suoritetaan.
Joskus näin suoraviivainen analyysi ei anna kuitenkaan
oikeaa kuvaa algoritmin tehokkuudesta,
koska silmukan suorituskertojen määrä saattaa vaihdella
algoritmin eri vaiheissa.
Tutustumme seuraavaksi tekniikkaan nimeltä
\emph{tasoitettu analyysi}, jossa koetamme arvioida tarkemmin,
montako kertaa silmukassa olevaa koodia suoritetaan
\emph{yhteensä} algoritmin aikana.

\index{lähin pienempi edeltäjä}

Tasoitettuun analyysiin liittyy yleensä jokin tietorakenne,
jonka operaatioiden määrää haluamme arvioida.
Tarkastellaan esimerkkinä tehtävää,
jossa meillä on $n$ lukua sisältävä taulukko
ja haluamme muodostaa toisen taulukon,
jossa on jokaisen luvun \emph{lähin pienempi edeltäjä}.
Tämä tarkoittaa, että haluamme löytää jokaiselle luvulle
pienemmän luvun, joka on mahdollisimman lähellä aiemmin taulukossa.
Esimerkiksi taulukon $[1,4,5,2,3,2]$
lähimmät pienemmät edeltäjät ovat $[-,1,4,1,2,1]$.
Koska luvulla $1$ ei ole pienempää edeltäjää,
sen kohdalla on merkki $-$.

\begin{figure}
\center
\begin{tikzpicture}[scale=0.6]
\newcommand\pino[3]{
\node[draw,rectangle,minimum size=12pt] (#1) at (#2+0.5,-0.75) {};
\node at (#2+0.5,-0.75) {#3};
}
\begin{scope}
\fill[color=lightgray] (0,0) rectangle (1,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\node at (3,-2) {vaihe $1$};
\end{scope}
\begin{scope}[xshift=10cm]
\fill[color=lightgray] (1,0) rectangle (2,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\pino{2}{1}{4}
\draw[thick,->] (1) -- (2);
\node at (3,-2) {vaihe $2$};
\end{scope}
\begin{scope}[yshift=-4.5cm]
\fill[color=lightgray] (2,0) rectangle (3,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\pino{2}{1}{4}
\pino{3}{2}{5}
\draw[thick,->] (1) -- (2);
\draw[thick,->] (2) -- (3);
\node at (3,-2) {vaihe $3$};
\end{scope}
\begin{scope}[yshift=-4.5cm,xshift=10cm]
\fill[color=lightgray] (3,0) rectangle (4,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\pino{2}{3}{2}
\draw[thick,->] (1) -- (2);
\node at (3,-2) {vaihe $4$};
\end{scope}
\begin{scope}[yshift=-9cm]
\fill[color=lightgray] (4,0) rectangle (5,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\pino{2}{3}{2}
\pino{3}{4}{3}
\draw[thick,->] (1) -- (2);
\draw[thick,->] (2) -- (3);
\node at (3,-2) {vaihe $5$};
\end{scope}
\begin{scope}[yshift=-9cm,xshift=10cm]
\fill[color=lightgray] (5,0) rectangle (6,1);
\draw (0,0) grid (6,1);
\foreach \i/\x in {0/1,1/4,2/5,3/2,4/3,5/2} \node at (\i+0.5,0.5) {\x};
\pino{1}{0}{1}
\pino{2}{5}{2}
\draw[thick,->] (1) -- (2);
\node at (3,-2) {vaihe $6$};
\end{scope}
\end{tikzpicture}
\caption{Etsimme lähimmät pienemmät edeltäjät pinon avulla.}
\label{fig:pielah}
\end{figure}

Saamme ratkaistua tehtävän tehokkaasti algoritmilla,
joka käy läpi taulukkoa vasemmalta oikealle ja pitää yllä \emph{pinoa},
jossa on lista taulukon lukuja.
Pino on muodostettu niin, että jokainen alkio on edellistä suurempi.
Jokaisessa kohdassa $i$ poistamme ensin pinon lopusta lukuja
niin kauan kuin pinon viimeinen luku on suurempi tai yhtä
suuri kuin kohdan $i$ luku.
Tämän jälkeen kirjaamme muistiin, että kohdan $i$ luvun
lähin pienempi edeltäjä on pinon viimeinen luku (jos pino ei ole tyhjä) ja
lisäämme kohdan $i$ luvun pinon loppuun.
Tuloksena on seuraava algoritmi:

\begin{code}
pino = []
for i = 0 to n-1
    while not pino.empty() and pino.top() >= taulu[i]
        pino.pop()
    if not pino.empty()
        edeltaja[i] = pino.top()
    pino.push(taulu[i])
\end{code}

Kuva \ref{fig:pielah} näyttää, kuinka algoritmi käsittelee taulukon $[1,4,5,2,3,2]$.
Alussa pino on tyhjä, joten toteamme, ettei luvulla 1
ole lähintä pienempää edeltäjää ja lisäämme sen pinoon.
Sitten vuoroon tulee luku 4, jonka lähin pienempi edeltäjä
on pinon päällä oleva luku 1. Tämän jälkeen lisäämme luvun 4 pinoon.
Vastaavasti luvun 5 lähin pienempi edeltäjä on luku 4,
ja lisäämme luvun 5 pinoon.
Luvun 2 kohdalla poistamme pinosta luvut 5 ja 4
ja toteamme, että luvun 2 lähin pienempi edeltäjä on luku 1.
Lopuksi käsittelemme vielä vastaavasti luvut 3 ja 2.

Algoritmin tehokkuus riippuu siitä, montako kertaa suoritamme
\texttt{while}-silmukassa olevan koodin.
Oleellinen havainto on, että voimme poistaa pinosta
korkeintaan niin monta alkiota kuin olemme lisänneet siihen,
eli emme voi kutsua \texttt{pop}-funktiota useammin kuin \texttt{push}-funktiota.
Koska lisäämme pinoon $n$ alkiota, suoritamme \texttt{while}-silmukassa
olevaa koodia siis enintään $n$ kertaa algoritmin aikana.
Niinpä koko algoritmi vie aikaa vain $O(n)$.
