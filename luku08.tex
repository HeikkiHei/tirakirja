\chapter{Peruuttava haku}

\index{backtracking}
\emph{Peruuttava haku} (\emph{backtracking}) on menetelmä,
jossa on ideana käydä läpi kaikki mahdolliset tavat 
ratkaista annettu tehtävä.
Peruuttava haku on luontevaa toteuttaa rekursion avulla,
jolloin jokainen rekursion haara vastaa yhtä tapaa
viedä ratkaisua eteenpäin.

Tässä luvussa tutustumme ensin peruuttavan haun algoritmeihin,
jotka käyvät läpi lukujen yhdistelmiä.
Tämän jälkeen näemme, miten peruuttavaa hakua voi käyttää
kahdessa vaikeammassa ongelmassa ja miten hakua voi optimoida.
Lopuksi toteutamme pelin tekoälyn minmax-algoritmilla,
joka perustuu peruuttavaan hakuun.

\section{Silmukoista rekursioon}

Aloitamme tehtävästä,
jossa haluamme käydä läpi kaikki $n$ luvun yhdistelmät,
joissa jokainen luku on kokonaisluku väliltä $1 \dots m$.
Tällaisia yhdistelmiä on yhteensä $m^n$,
koska kohtia on $n$ ja joka kohdassa luvun voi valita $m$ tavalla.
Esimerkiksi jos $n=3$ ja $m=4$, yhdistelmät ovat
$[1,1,1]$, $[1,1,2]$, $[1,1,3]$, $[1,1,4]$, $[1,2,1]$,
$[1,2,2]$, $[1,2,3]$, $[1,2,4]$, jne.

Luonteva tapa ratkaista tehtävä tietylle $n$:n arvolle on
luoda $n$ sisäkkäistä silmukkaa, joista jokainen käy $m$ lukua läpi.
Esimerkiksi seuraava koodi käy läpi kaikki yhdistelmät
tapauksessa $n=3$:

\begin{code}
for a = 1 to m
    for b = 1 to m
        for c = 1 to m
            print(a,b,c)
\end{code}

Tämä on sinänsä mainio ratkaisu, mutta siinä on yksi ongelma:
lukujen määrä $n$ vaikuttaa silmukoiden määrään.
Jos haluaisimme muuttaa $n$:n arvoa, meidän täytyisi muuttaa
koodin silmukoiden määrää, mikä ei ole hyvä asia.
Peruuttavan haun avulla voimme kuitenkin toteuttaa ratkaisun
rekursiivisesti niin, että sama koodi toimii kaikille $n$:n arvoille.

\subsection{Haun toteuttaminen}

Seuraava rekursiivinen proseduuri \texttt{haku} muodostaa
yhdistelmiä peruuttavan haun avulla.
Parametri $k$ tarkoittaa kohtaa, johon seuraava luku asetetaan.
Jos $k=n$, jokin yhdistelmä on valmistunut, jolloin se tulostetaan.
Muuten haku käy läpi kaikki tavat sijoittaa kohtaan $k$ luku $1 \dots m$
ja jatkaa rekursiivisesti kohtaan $k+1$.
Haku lähtee käyntiin kutsulla \texttt{haku}(0),
ja \texttt{luvut} on $n$-kokoinen taulukko, johon yhdistelmä muodostetaan.

\begin{code}
procedure haku(k)
    if k == n
        print(luvut)
    else
        for i = 1 to m
            luvut[k] = i
            haku(k+1)
\end{code}

Kuva \ref{fig:perhak} näyttää, miten haku lähtee liikkeelle
tapauksessa $n=3$ ja $m=4$.
Merkki "$-$" tarkoittaa lukua, jota ei ole vielä valittu.
Haun ensimmäinen taso valitsee yhdistelmän
ensimmäisen luvun kohtaan $0$.
Tämän valintaan on neljä vaihtoehtoa,
koska mahdolliset luvut ovat $1 \dots 4$,
joten haku haarautuu neljään osaan.
Tämän jälkeen haku jatkaa rekursiivisesti eteenpäin
ja valitsee muihin kohtiin tulevat luvut.

\begin{figure}
\center
\begin{tikzpicture}[scale=.65]
    \draw (0,0) grid (3,1);
    \foreach \x/\v in {0/-,1/-,2/-} \node at (\x+0.5,0.5) {$\v$};

    \draw (7,-3) grid (10,-2);
    \foreach \x/\v in {0/1,1/-,2/-} \node at (\x+7.5,3.5) {$\v$};
    \draw (7,-1) grid (10,0);
    \foreach \x/\v in {0/2,1/-,2/-} \node at (\x+7.5,1.5) {$\v$};
    \draw (7,1) grid (10,2);
    \foreach \x/\v in {0/3,1/-,2/-} \node at (\x+7.5,-0.5) {$\v$};
    \draw (7,3) grid (10,4);
    \foreach \x/\v in {0/4,1/-,2/-} \node at (\x+7.5,-2.5) {$\v$};

    \draw[->,thick] (3.2,0.5) -- (6.8,3.5);
    \draw[->,thick] (3.2,0.5) -- (6.8,1.5);
    \draw[->,thick] (3.2,0.5) -- (6.8,-0.5);
    \draw[->,thick] (3.2,0.5) -- (6.8,-2.5);
    
    \foreach \y in {3.5,1.5,-0.5,-2.5} \foreach \z in {0.6,0.2,-0.2,-0.6}
        \draw[->,thick] (10.2,\y) -- (13.8,\y+\z);
\end{tikzpicture}
\caption{Yhdistelmien muodostaminen alkaa ($n=3$ ja $m=4$).}
\label{fig:perhak}
\end{figure}

Voimme arvioida algoritmin tehokkuutta laskemalla,
montako kertaa proseduuria \texttt{haku} kutsutaan yhteensä haun aikana.
Proseduuria kutsutaan kerran parametrilla $0$,
$m$ kertaa parametrilla $1$, $m^2$ kertaa parametrilla $2$, jne.,
joten kutsujen määrä on yhteensä
\[
1+m+m^2+\dots+m^n = \frac{m^{n+1}-1}{m-1} = O(m^n).
\]
Tästä näkee, että kutsujen yhteismäärä on samaa luokkaa kuin
viimeisen tason kutsujen määrä.
Viimeisellä tasolla tehdäänkin enemmän kutsuja kuin
kaikilla muilla tasoilla yhteensä.

\subsection{Osajoukkojen läpikäynti}

Tarkastellaan sitten ongelmaa,
jossa haluamme käydä läpi kaikki $n$ alkion
joukon \emph{osajoukot}.
Osajoukkoja on yhteensä $2^n$,
koska jokainen alkio joko kuuluu tai ei kuulu osajoukkoon.
Esimerkiksi joukon $\{2,3,5,9\}$ osajoukkoja ovat
$\{2,5\}$ ja $\{3,5,9\}$.

Osoittautuu, että voimme ratkaista tehtävän
käymällä läpi kaikki $n$ luvun yhdistelmät,
joissa jokainen luku on 0 tai 1.
Ideana on, että jokainen yhdistelmän luku kertoo,
kuuluuko tietty alkio osajoukkoon,
Alkio kuuluu osajoukkoon tarkalleen silloin,
kun sen kohdalla on luku 1.
Esimerkiksi kun joukkona on $\{2,3,5,9\}$,
yhdistelmä $[1,0,1,0]$ vastaa
osajoukkoa $\{2,5\}$ ja
yhdistelmä $[0,1,1,1]$ vastaa osajoukkoa $\{3,5,9\}$.

Seuraava koodi näyttää, miten voimme käydä osajoukot
läpi peruuttavan haun avulla.
Proseduuri \texttt{haku} valitsee,
otetaanko kohdassa $k$ oleva alkio mukaan osajoukkoon vai ei,
ja merkitsee tämän tiedon taulukkoon \texttt{valinta}.
Kuten ennenkin, haku lähtee käyntiin kutsulla \texttt{haku}$(0)$.

\begin{code}
procedure haku(k)
    if k == n
        // käsittele osajoukko
    else
        for i = 0 to 1
            valinta[k] = i
            haku(k+1)
\end{code}

\subsection{Permutaatioiden läpikäynti}

Peruuttavan haun avulla voimme myös käydä läpi joukon
\emph{permutaatiot} eli erilaiset järjestykset.
Kun joukossa on $n$ alkiota, siitä voidaan muodostaa
kaikkiaan $n!$ permutaatiota.
Esimerkiksi joukon $\{1,2,3,4\}$ permutaatioita ovat
$\{2,4,1,3\}$ ja $\{4,3,1,2\}$.

Tässä tilanteessa haluamme käydä läpi $n$ luvun yhdistelmiä,
joissa jokainen luku on väliltä $1 \dots n$
ja lisäksi mikään luku ei toistu.
Saamme tämän aikaan lisäämällä hakuun uuden taulukon
\texttt{mukana}, joka kertoo, onko tietty luku jo mukana.
Joka vaiheessa haku voi valita yhdistelmään vain sellaisia lukuja,
joita ei ole valittu siihen aiemmin.

\begin{code}
procedure haku(k)
    if k == n
        print(luvut)
    else
        for i = 1 to n
            if not mukana[i]
                mukana[i] = true
                luvut[k] = i
                haku(k+1)
                mukana[i] = false
\end{code}


\section{Esimerkki: Kuningatarongelma}

Seuraava tehtävämme on laskea, monellako tavalla
$n \times n$ -shakkilaudalle voidaan asettaa $n$ kuningatarta
niin, etteivät mitkään kaksi kuningatarta uhkaa toisiaan.
Shakissa kuningattaret voivat uhata toisiaan
vaaka-, pysty- tai vinosuuntaisesti.
Esimerkiksi tapauksessa $n=4$ mahdollisia sijoitustapoja on kaksi,
jotka on esitetty kuvassa \ref{fig:kuning}.


\begin{figure}
\center
\begin{tikzpicture}[scale=.65]
  \begin{scope}
    \draw (0, 0) grid (4, 4);
    \node at (1.5,3.5) {$\symqueen$};
    \node at (3.5,2.5) {$\symqueen$};
    \node at (0.5,1.5) {$\symqueen$};
    \node at (2.5,0.5) {$\symqueen$};

    \draw (6, 0) grid (10, 4);
    \node at (6+2.5,3.5) {$\symqueen$};
    \node at (6+0.5,2.5) {$\symqueen$};
    \node at (6+3.5,1.5) {$\symqueen$};
    \node at (6+1.5,0.5) {$\symqueen$};
  \end{scope}
\end{tikzpicture}
\caption{Kuningatarongelman ratkaisut tapauksessa $n=4$.}
\label{fig:kuning}
\end{figure}

\subsection{Haun toteuttaminen}

Voimme ratkaista tehtävän toteuttamalla algoritmin,
joka käy laudan läpi ylhäältä alaspäin ja asettaa yhden kuningattaren
jokaiselle riville.
Kuva \ref{fig:hakupuu} esittää haun toimintaa tapauksessa $n=4$.
Ensimmäisen rivin kuningatar voidaan asettaa mihin tahansa sarakkeeseen,
mutta seuraavilla riveillä aiemmat valinnat rajoittavat hakua.
Kuvassa näkyy toisen kuningattaren sijoittaminen,
kun ensimmäinen kuningatar on sarakkeessa 2.
Tällöin ainoa vaihtoehto on, että toinen kuningatar on sarakkeessa 4,
koska kaikissa muissa tapauksissa kuningattaret uhkaisivat toisiaan.


\begin{figure}
\center
\begin{tikzpicture}[scale=.55]
  \begin{scope}
    \draw (0, 0) grid (4, 4);

    \draw (-9, -6) grid (-5, -2);
    \draw (-3, -6) grid (1, -2);
    \draw (3, -6) grid (7, -2);
    \draw (9, -6) grid (13, -2);

    \node at (-9+0.5,-3+0.5) {$\symqueen$};
    \node at (-3+1+0.5,-3+0.5) {$\symqueen$};
    \node at (3+2+0.5,-3+0.5) {$\symqueen$};
    \node at (9+3+0.5,-3+0.5) {$\symqueen$};

    \draw (2,0) -- (-7,-2);
    \draw (2,0) -- (-1,-2);
    \draw (2,0) -- (5,-2);
    \draw (2,0) -- (11,-2);

    \draw (-11, -12) grid (-7, -8);
    \draw (-6, -12) grid (-2, -8);
    \draw (-1, -12) grid (3, -8);
    \draw (4, -12) grid (8, -8);
    \draw[white] (11, -12) grid (15, -8);
    \node at (-11+1+0.5,-9+0.5) {$\symqueen$};
    \node at (-6+1+0.5,-9+0.5) {$\symqueen$};
    \node at (-1+1+0.5,-9+0.5) {$\symqueen$};
    \node at (4+1+0.5,-9+0.5) {$\symqueen$};
    \node at (-11+0+0.5,-10+0.5) {$\symqueen$};
    \node at (-6+1+0.5,-10+0.5) {$\symqueen$};
    \node at (-1+2+0.5,-10+0.5) {$\symqueen$};
    \node at (4+3+0.5,-10+0.5) {$\symqueen$};

    \draw (-1,-6) -- (-9,-8);
    \draw (-1,-6) -- (-4,-8);
    \draw (-1,-6) -- (1,-8);
    \draw (-1,-6) -- (6,-8);
    
    \node at (-9,-13) {\ding{55}};
    \node at (-4,-13) {\ding{55}};
    \node at (1,-13) {\ding{55}};
    \node at (6,-13) {\ding{51}};    
  \end{scope}
\end{tikzpicture}
\caption{Peruuttavan haun toiminta kuningatarongelmassa.}
\label{fig:hakupuu}
\end{figure}


Seuraava proseduuri \texttt{haku} esittää peruuttavan haun algoritmin,
joka laskee kuningatarongelman ratkaisut:

\begin{code}
procedure haku(y)
    if y == n
        laskuri++
    else
        for x = 0 to n-1
            if voi_sijoittaa(y,x)
                kohta[y] = x
                haku(y+1)
\end{code}

Oletamme, että laudan rivit ja sarakkeet on numeroitu $0 \dots n-1$.
Parametri $y$ kertoo, mille riville seuraava kuningatar tulee sijoittaa,
ja haku lähtee käyntiin kutsulla \texttt{haku}$(0)$.
Jos rivinä on $n$, kaikki kuningattaret on jo sijoitettu,
joten yksi ratkaisu on löytynyt.
Muuten suoritetaan silmukka, joka käy läpi mahdolliset sarakkeet
muuttujan $x$ avulla.
Jos kuningatar voidaan sijoittaa sarakkeeseen $x$
eli se ei uhkaa mitään aiemmin sijoitettua kuningatarta,
merkitään taulukkoon \texttt{kohta},
että kuningatar $y$ on sarakkeessa $x$,
ja haku jatkuu eteenpäin rekursiivisesti.

Lisäksi täytyy toteuttaa funktio \texttt{voi\_sijoittaa},
joka tutkii, voidaanko uusi kuningatar sijoittaa
rivin $y$ sarakkeelle $x$.
Tämä voidaan selvittää taulukon \texttt{kohta} avulla näin:

\begin{code}
function voi_sijoittaa(y,x)
    for i = 0 to y-1
        if kohta[i] == x
            return false
        if abs(i-y) == abs(kohta[i]-x)
            return false
    return true
\end{code}

Funktio käy läpi kaikki aiemmin sijoitetut kuningattaret.
Jos aiemmin sijoitettu kuningatar olisi samassa sarakkeessa
(ensimmäinen ehto) tai samalla vinorivillä (toinen ehto)
kuin uusi kuningatar, tällaista sijoitusta ei voida tehdä
ja funktio palauttaa \texttt{false}.
Jos taas mikään aiempi kuningatar ei uhkaa uutta kuningatarta,
funktio palauttaa \texttt{true}.
Huomaa jälkimmäisessä ehdossa kätevä tapa tarkastaa,
ovatko kuningattaret samalla vinorivillä itseisarvon
(funktio \texttt{abs}) avulla.
Kuningattaret ovat samalla vinorivillä tarkalleen silloin,
kun niiden vaaka- ja pystysuuntaiset erot ovat samat.

\begin{table}
\center
\begin{tabular}{rr}
laudan koko $n$ & ratkaisujen määrä \\
\hline
1 & 1 \\
2 & 0 \\
3 & 0 \\
4 & 2 \\
5 & 10 \\
6 & 4 \\
7 & 40 \\
8 & 92 \\
9 & 352 \\
10 & 724 \\
\end{tabular}
\caption{Kuningatarongelman ratkaisujen määriä.}
\label{tab:kuning}
\end{table}

Nyt meillä on valmis algoritmi, jonka avulla voimme
käydä läpi kuningatarongelman ratkaisuja.
Taulukko \ref{tab:kuning} näyttää ratkaisujen määrät
tapauksissa $n=1 \dots 10$.
Esimerkiksi tavallisella $8 \times 8$ -shakkilaudalla
on 92 tapaa asettaa 8 kuningatarta niin,
etteivät ne uhkaa toisiaan.

\subsection{Haun tehostaminen}

Tässä kuvattu peruuttavan haun algoritmi toimii hyvin nopeasti
tapauksissa $n=1 \dots 10$,
mutta vähänkin suuremmilla $n$:n arvoilla
algoritmi alkaa viedä paljon aikaa.
Syynä tähän on, että kuningatarten sijoitustapojen
määrä kasvaa eksponentiaalisesti.
Esimerkiksi tapauksessa $n=15$ sijoitustapoja on
noin 2 miljoonaa ja tapauksessa $n=20$ niitä on noin 39 miljardia.

\index{symmetria}
Voimme kuitenkin koettaa nopeuttaa algoritmia parantamalla
sen toteutusta.
Yksi helposti toteutettava tehostus on hyödyntää \emph{symmetriaa}.
Jokaista kuningatarongelman ratkaisua vastaa toinen ratkaisu,
joka saadaan peilaamalla ratkaisu vaakasuuntaisesti.
Esimerkiksi kuvassa \ref{fig:kuning} ratkaisut voidaan muuttaa
toisikseen peilaamalla.
Tämän havainnon ansiosta voimme puolittaa algoritmin suoritusajan
lisäämällä vaatimuksen, että ensimmäinen kuningatar asetetaan
laudan vasempaan puoliskoon, ja kertomalla lopuksi vastauksen kahdella.
Jos laudan koko on pariton, täytyy vielä käsitellä erikseen tapaus,
jossa ensimmäinen kuningatar sijoitetaan keskisarakkeeseen.

Toinen mahdollinen tehostus olisi toteuttaa funktio
\texttt{voi\_sijoittaa} paremmin.
Tällä hetkellä se käy läpi kaikki aiemmin sijoitetut kuningattaret
ja vie aikaa $O(n)$, mutta funktio on mahdollista toteuttaa myös
ajassa $O(1)$ ottamalla käyttöön uusia aputaulukoita, joissa on tietoa,
mitkä sarakkeet ja vinorivit ovat uhattuina.
Tämä tehostus on vaikeampi toteuttaa kuin symmetristen lautojen karsinta.

Kuningatarongelma on kuitenkin pohjimmiltaan vaikea ongelma,
eikä sen ratkaisuun tunneta mitään oleellisesti raakaa voimaa
parempaa tapaa.
Tällä hetkellä suurin tapaus, jonka ratkaisu tunnetaan, on $n=27$.
Tämän tapauksen käsittely vei aikaa noin vuoden laskentaklusterilla,
jossa oli suuri määrä rinnakkain laskevia
suorittimia\footnote{27-Queens Puzzle: Massively Parellel Enumeration and Solution Counting.
\url{https://github.com/preusser/q27}}.


\section{Esimerkki: Pakkaaminen}

Annettuna on $n$ tavaraa, joilla jokaisella on tietty paino.
Tehtävänä on jakaa tavarat laatikoihin niin,
että jokaisen laatikon paino on enintään $x$ ja
laatikoiden määrä on mahdollisimman pieni.
Esimerkiksi jos $n=5$, painot ovat $[2,3,3,7,8]$ ja $x=9$,
paras ratkaisu on muodostaa laatikot $[2,7]$, $[3,3]$ ja $[8]$,
jolloin tarvitaan 3 laatikkoa.

Parhaan jakotavan löytäminen on vaikea tehtävä,
johon ei tunneta mitään tehokasta algoritmia.
Voimme kuitenkin toteuttaa peruuttavan haun algoritmin,
joka käy läpi kaikki mahdolliset ratkaisut.

\subsection{Haun toteuttaminen}

Tässä tehtävässä on monta luontevaa tapaa toteuttaa
peruuttavan haun algoritmi.
Seuraavassa toteutuksessa proseduuri \texttt{haku} saa kaksi parametria:
$k$ kertoo, mikä tavara pakataan seuraavaksi,
ja $c$ kertoo, montako laatikkoa on jo käytössä.
Haku lähtee käyntiin kutsulla \texttt{haku}$(0,0)$.
Taulukko \texttt{paino} kertoo jokaisen tavaran painon,
ja taulukko \texttt{summa} sisältää puolestaan
jokaisesta laatikosta siinä olevien tavaroiden painojen summan.
Lisäksi muuttujassa $p$ on laatikoiden määrä pienimmässä ratkaisussa
tähän mennessä.
Tämän muuttujan arvona on alussa $\infty$,
koska mitään ratkaisua ei ole vielä löytynyt.

\begin{code}
procedure haku(k,c)
    if k == n
        p = min(p,c)
        return
    for i = 0 to c-1
        if summa[i]+paino[k] <= x
            summa[i] += paino[k]
            haku(k+1,c)
            summa[i] -= paino[k]
    summa[c] = paino[k]
    haku(k+1,c+1)
\end{code}

Jos $k=n$, jokin ratkaisu on löytynyt ja $c$ sisältää
laatikoiden määrän tässä ratkaisussa.
Tässä vaiheessa muuttuja $p$ päivittyy,
jos uusi ratkaisu on aiempaa pienempi.
Jos ratkaisu ei ole valmis, haku käy läpi kaikki
nykyiset laatikot ja koettaa jokaisen laatikon
kohdalla pakata seuraavan tavaran sinne.
Jos tavara mahtuu laatikkoon,
se lisätään sinne ja haku jatkuu rekursiivisesti.
Tämän jälkeen tavara poistetaan laatikosta.
Lopuksi käsitellään vielä tapaus, jossa tavara laitetaan
uuteen laatikkoon, jolloin $c$ kasvaa yhdellä.

\subsection{Haun tehostaminen}

Yllä kuvattu algoritmi on toimiva, mutta \emph{hyvin hidas},
koska se käy läpi valtavan määrän ratkaisuja.
Käytännössä monet ratkaisut ovat huonoja, koska niissä on
paljon laatikoita, jotka jäävät tyhjilleen.
Voimmekin tehostaa algoritmia huomattavasti keskeyttämällä
ratkaisun muodostamisen, jos on selvää, ettei siitä voi
tulla aiemmin löydettyä ratkaisua parempi.

Koska muistissa on aina laatikoiden määrä parhaassa
löydetyssä ratkaisussa ($p$),
saamme tästä \emph{ylärajan} sille, montako laatikkoa tarvitaan.
Toisaalta laatikoiden määrä nykyisessä ratkaisussa ($c$) on
\emph{alaraja} sille, montako laatikkoa muodosteilla oleva
ratkaisu tulee sisältämään.
Jos alaraja on yhtä suuri tai suurempi kuin yläraja,
emme voi saada aiempaa parempaa ratkaisua,
joten ei kannata jatkaa ratkaisun muodostamista.
Tämä onnistuu lisäämällä algoritmin alkuun seuraava tarkastus:

\begin{code}
procedure haku(k,c)
    if c >= p
        return
    ...
\end{code}

Tämä on jo merkittävä tehostus, mutta voimme vielä parantaa
alarajaa, koska voimme arvioida, montako laatikkoa
lisää ainakin vielä tarvitaan. Tämä selviää kaavalla
\[
\frac{s_T-s_L}{x},
\]
missä $s_T$ on vielä lisäämättä olevien tavaroiden yhteispaino ja
$s_L$ kertoo, miten paljon painoa nykyisiin laatikoihin
voisi vielä laittaa lisää.
Niinpä $s_T-s_L$ ilmaisee, miten paljon painoa meidän täytyy
laittaa varmasti uusiin laatikoihin.
Ihannetilanteessa jokaiseen laatikkoon tulee painoa $x$,
joten saamme kaavasta alarajan sille, montako laatikkoa tarvitaan vielä.
Voimme luoda kaavasta funktion \texttt{arvio},
jonka voi yhdistää hakuun näin:

\begin{code}
procedure haku(k,c)
    if c+arvio(k,c) >= p
        return
    ...
\end{code}

\index{branch and bound}
Nyt meillä on aiempaa parempi alaraja tarvittavien laatikoiden määrälle,
koska laskemme yhteen, montako laatikkoa on jo käytetty ja montako
tarvitaan vielä lisää.

\index{branch and bound}
Tällaista peruuttavan haun toteutusta kutsutaan joskus nimellä
\emph{branch and bound}.
Tässä \emph{branch} tarkoittaa, että haku haarautuu,
ja \emph{bound} viittaa siihen, että haku hyödyntää
ylä- ja alarajoja.

\section{Pelin tekoäly}

\subsection{Minmax-algoritmi}

\subsection{Alfa-beta-karsinta}
