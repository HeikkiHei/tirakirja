\chapter{Syklittömät verkot}

Verkon käsittelyssä keskeinen haaste ovat verkossa olevat syklit.
Jos voimme olettaa, että verkossa ei ole syklejä,
voimme ratkaista monia ongelmia helpommin kuin yleisissä verkoissa,
joissa saattaa olla syklejä.

Tässä luvussa keskitymme verkkoihin, jotka ovat suunnattuja
ja syklit\-tömiä.
Englanniksi tällaisia verkkoja kutsutaan usein nimellä \emph{dag},
joka tulee sanoista \emph{directed acyclic graph}.
Tässä tapauksessa voimme muodostaa verkolle topologisen
järjestyksen ja käyttää sen jälkeen dynaamista ohjelmointia
verkko-ongelmien ratkaisemiseen.

\section{Topologinen järjestys}

Suunnatun verkon \emph{topologinen järjestys} on solmujen järjestys,
jossa pätee, että jos solmusta $a$ on kaari solmuun $b$,
niin solmu $a$ on ennen solmua $b$ järjestyksessä.
Topologinen järjestys voidaan esittää listana,
joka sisältää kaikki verkon solmut sopivassa järjestyksessä.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\end{scope}
\begin{scope}[xshift=7cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (3) at (2,-1) {$3$};
\node[draw, circle] (5) at (4,-1) {$5$};
\node[draw, circle] (2) at (6,-1) {$2$};
\node[draw, circle] (4) at (8,-1) {$4$};
\path[draw,thick,->] (1) edge [bend right] (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) edge [bend left] (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) edge [bend left] (4);
\path[draw,thick,->] (5) edge [bend right] (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja yksi sen topologinen järjestys $[1,3,5,2,4]$.}
\label{fig:topjar}
\end{figure}

Kuvassa \ref{fig:topjar} on esimerkkinä verkko ja yksi sen topologinen
järjestys $[1,3,5,2,4]$.
Huomaa, että verkolla on usein monta mahdollista
topologista järjestystä.
Esimerkiksi tässä verkossa myös $[5,1,3,2,4]$,
$[1,5,3,2,4]$ ja $[1,3,2,5,4]$
ovat topologisia järjestyksiä, koska voimme valita monella tavalla,
missä vaiheessa solmu $5$ on järjestyksessä.

Jos suunnattu verkko on syklitön, voimme muodostaa sille
aina topologisen järjestyksen.
Toisaalta jos verkossa on sykli,
topologista järjestystä ei voi olla olemassa,
koska emme voi valita mitään syklissä olevaa solmua
järjestykseen ennen toista.
Seuraavaksi tutustumme algoritmiin,
jonka avulla voimme muodostaa topologisen järjestyksen
tai todeta, että verkossa on sykli eikä järjestys ole mahdollinen.

\subsection{Järjestyksen muodostaminen}

Voimme muodostaa topologisen järjestyksen käyttämällä
muunnettua syvyyshakua, jossa jokaisella solmulla on kolme tilaa:

\begin{itemize}
\item tila 0 (valkoinen): solmussa ei ole käyty
\item tila 1 (harmaa): solmun käsittely on kesken
\item tila 2 (musta): solmun käsittely on valmis
\end{itemize}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{white}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{white}{gray}{white}
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{gray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{gray}{gray}{gray}{gray}{white}
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{gray}{gray}{gray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki topologisen järjestyksen muodostamisesta.}
\label{fig:topesi}
\end{figure}

Algoritmin alussa jokainen solmu on valkoinen.
Käymme läpi kaikki verkon solmut ja aloitamme aina syvyyshaun
solmusta, jos se on valkoinen.
Aina kun saavumme uuteen solmuun, sen väri muuttuu
valkoisesta harmaaksi.
Sitten kun olemme käsitelleet kaikki solmusta lähtevät
kaaret, sen väri muuttuu harmaasta mustaksi.

Algoritmin aikana luomme listan, johon lisäämme solmun
aina silloin, kun sen väri muuttuu mustaksi.
Tämä lista käänteisessä järjestyksessä on verkon
topologinen järjestys.
Kuitenkin jos saavumme jossain vaiheessa uudestaan harmaaseen solmuun,
verkossa on sykli eikä topologista järjestystä voi muodostaa.

Kuva \ref{fig:topesi} näyttää, kuinka algoritmi muodostaa topologisen
järjestyksen esimerkkiverkossamme.
Tässä tapauksessa syvyyshakuja on kaksi,
joista ensimmäinen alkaa solmusta 1 ja toinen alkaa solmusta 5.
Algoritmin tuloksena on lista $[4,2,3,1,5]$,
joten käänteinen lista $[5,1,3,2,4]$ on verkon topologinen järjestys.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Topologista järjestystä ei voi muodostaa syklin takia.}
\label{fig:topsyk}
\end{figure}

Kuva \ref{fig:topsyk} näyttää puolestaan esimerkin tilanteesta,
jossa topologista järjestystä ei voi muodostaa verkossa
olevan syklin takia.
Tässä verkossa on sykli $2 \rightarrow 4 \rightarrow 3 \rightarrow 2$,
jonka olemassaolon huomaamme siitä, että tulemme uudestaan
harmaaseen solmuun 2.

Algoritmin toiminta vastaa syvyyshakua, joten se vie aikaa $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

Miten voimme tietää, että tässä kuvattu algoritmi toimii
oikein kaikissa mahdollisissa tilanteissa?

Tarkastellaan ensin tilannetta, jossa verkossa on sykli.
Jos algoritmi saapuu uudestaan harmaaseen solmuun $x$,
on selvää, että verkossa on sykli,
koska algoritmi on onnistunut pääsemään solmusta $x$
takaisin itseensä kulkemalla jotain polkua verkossa.

Toisaalta jos verkossa on sykli, algoritmi saapuu
jossain vaiheessa ensimmäistä kertaa johonkin sykliin
kuuluvaan solmuun $x$. Sen jälkeen se käy läpi solmusta
lähtevät kaaret ja aikanaan saapuu varmasti toista reittiä
solmuun $x$. Niinpä algoritmi onnistuu tunnistamaan,
jos verkossa on sykli.

Jos sitten verkossa ei ole sykliä, algoritmi lisää jokaisen
solmun listaan sen jälkeen, kun se on käsitellyt
kaikki solmusta lähtevät kaaret.
Jos siis verkossa on mikä tahansa kaari $a \rightarrow b$,
solmu $b$ lisätään listaan ennen solmua $a$.
Lopuksi lista käännetään, jolloin solmu $a$
tulee ennen solmua $b$.
Tämän ansiosta jokaiselle kaarelle $a \rightarrow b$ pätee,
että solmu $a$ on järjestyksessä ennen solmua $b$.

\section{Esimerkki: Kurssivalinnat}

Yliopiston kurssit ja niiden esitietovaatimukset voidaan esittää 
suunnattuna verkkona, jonka solmut ovat kursseja ja kaaret kuvaavat,
missä järjestyksessä kurssit tulisi suorittaa.
Kuvassa \ref{fig:kuresi} on esimerkkinä joitakin
tietojenkäsittely\-tieteen kandiohjelman kursseja.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {OHPE};
\node[draw, rectangle] (2) at (-4,-2) {OHJA};
\node[draw, rectangle] (3) at (4,-2) {TITO};
\node[draw, rectangle] (4) at (0,-2) {TIPE};
\node[draw, rectangle] (5) at (-8,-2) {JYM};
\node[draw, rectangle] (6) at (-4,-4) {TIRA};
\node[draw, rectangle] (7) at (-4,-6) {LAMA};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) -- (6);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (5) -- (7);
\path[draw,thick,->] (6) -- (7);
\end{tikzpicture}
\end{center}
\caption{Kurssien esitietovaatimukset verkkona.}
\label{fig:kuresi}
\end{figure}

Tällaisen verkon topologinen järjestys kertoo meille
yhden tavan suorittaa kurssit esitietovaatimusten mukaisesti.
Kuva \ref{fig:kurjar} näyttää, kuinka voimme suorittaa
kurssit esimerkkitilanteessamme.
Mahdollinen suoritusjärjestys on siis
OHPE, OHJA, TIPE, TITO, JYM, TIRA, LAMA.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {OHPE};
\node[draw, rectangle] (2) at (2.5,0) {OHJA};
\node[draw, rectangle] (4) at (5,0) {TIPE};
\node[draw, rectangle] (3) at (7.5,0) {TITO};
\node[draw, rectangle] (5) at (10,0) {JYM};
\node[draw, rectangle] (6) at (12.5,0) {TIRA};
\node[draw, rectangle] (7) at (15,0) {LAMA};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) edge [bend left] (3);
\path[draw,thick,->] (1) edge [bend right] (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) edge [bend left] (6);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (5) edge [bend right] (7);
\path[draw,thick,->] (6) -- (7);
\end{tikzpicture}
\end{center}
\caption{Topologinen järjestys antaa kurssien suoritusjärjestyksen.}
\label{fig:kurjar}
\end{figure}

On selvää, että kurssien ja esitietovaatimusten muodostaman
verkon tulee olla syklitön.
Jos verkossa on sykli, topologista järjestystä ei ole olemassa
eikä meillä ole mitään mahdollisuutta suorittaa kursseja
esitietovaatimusten mukaisesti.

\section{Dynaaminen ohjelmointi}

Kun tiedämme, että suunnattu verkko on syklitön,
voimme ratkaista monia verkko-ongelmia tehokkaasti
dynaamisen ohjelmoinnin avulla.
Esimerkkejä tällaisista ongelmista ovat:

\begin{itemize}
\item Kuinka pitkä on lyhin polku solmusta $a$ solmuun $b$?
\item Kuinka pitkä on pisin polku solmusta $a$ solmuun $b$?
\item Montako erilaista polkua on solmusta $a$ solmuun $b$?
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} verkossa on kolme
mahdollista polkua solmusta 1 solmuun 4:
$1 \rightarrow 2 \rightarrow 4$,
$1 \rightarrow 3 \rightarrow 2 \rightarrow 4$ ja
$1 \rightarrow 3 \rightarrow 4$.
Lyhin polun pituus on 2 ja pisin polun pituus on 3.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Mahdolliset polut solmusta 1 solmuun 4.}
\label{fig:verpol}
\end{figure}

Osoittautuu, että voimme ratkaista
kaikki yllä mainitut ongelmat
ajassa $O(n+m)$ dynaamisella ohjelmoinnilla,
kun oletamme, että verkko on suunnattu ja syklitön.
Yleisessä verkossa tilanne on toinen:
voimme etsiä lyhimmän polun Dijkstran algoritmilla
ajassa $O(m \log n)$, mutta pisimmän polun etsimiseen
tai polkujen yhteismäärän laskemiseen ei tunneta
mitään tehokasta menetelmää.

\subsection{Polkujen käsittely}

Jotta voimme käyttää dynaamista ohjelmointia,
meidän täytyy määritellä ongelmat rekursiivisesti.
Sopivat funktiot ovat seuraavat:

\begin{itemize}
\item $\texttt{lyhin}(x)$: lyhimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{pisin}(x)$: pisimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{maara}(x)$: polkujen yhteismäärä solmusta $a$ solmuun $x$
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} tilanteessa lähtösolmu on $a=1$
ja funktiot saavat arvot $\texttt{lyhin}(4)=2$,
$\texttt{pisin}(4)=3$ ja $\texttt{maara}(4)=3$.

Funktioiden pohjatapaukset ovat seuraavat:

\begin{align*}
\texttt{lyhin}(a)&=0 \\
\texttt{pisin}(a)&=0 \\
\texttt{maara}(a)&=1
\end{align*}

Tämä tarkoittaa tilannetta, jossa haluamme kulkea solmusta $a$
solmuun $a$. Koska polulla ei ole yhtään kaaria,
sekä lyhimmän että pisimmän polun pituus on 0.
Polkujen määrä on 1, koska ainoa polku on tyhjä polku.

Seuraavaksi määrittelemme yleisen tapauksen solmulle $x$.
Oletamme, että solmuun $x$ pääsee kaarella $k$ solmusta,
joiden tunnukset ovat $u_1,u_2,\dots,u_k$.
Tällöin saamme seuraavat rekursiiviset kaavat:

\begin{align*}
\texttt{lyhin}(x)&=\min(\texttt{lyhin}(u_1),\texttt{lyhin}(u_2),\dots,\texttt{lyhin}(u_k))+1 \\
\texttt{pisin}(x)&=\max(\texttt{pisin}(u_1),\texttt{pisin}(u_2),\dots,\texttt{pisin}(u_k))+1 \\
\texttt{maara}(x)&=\texttt{maara}(u_1)+\texttt{maara}(u_2)+\dots+\texttt{maara}(u_k)
\end{align*}

Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $x$,
meidän tulee valita edellinen solmu niin,
että siihen on lyhin matka solmusta $a$.
Niinpä valitsemme minimin edellisistä arvoista
ja lisäämme siihen yhden.
Vastaavasti kun haluamme muodostaa pisimmän polun,
valitsemme maksimin edellisistä arvoista.
Kun taas haluamme laskea polkujen yhteismäärän,
laskemme yhteen kaikki solmuun johtavat polut.

Tarkastellaan esimerkkinä kuvan \ref{fig:verpol} verkkoa,
jossa tutkimme polkuja solmusta 1 solmuun 4.
Kun haluamme laskea funktioiden arvot solmulle 4,
otamme huomioon kaaret
$2 \rightarrow 4$, $3 \rightarrow 4$ ja $5 \rightarrow 4$,
joita kulkemalla pääsee muista solmuista solmuun 4.
Oletamme, että olemme laskeneet aiemmin funktioiden
arvot solmuille 2, 3 ja 5.

Nyt esimerkiksi lyhin polku solmusta 1 solmuun 4 on pituudeltaan
\[ \texttt{lyhin}(4)=\min(\texttt{lyhin}(2),\texttt{lyhin}(3),\texttt{lyhin}(5))+1.\]
Aiemmat arvot ovat $\texttt{lyhin}(2)=1$, $\texttt{lyhin}(3)=2$ ja $\texttt{lyhin}(5)=\infty$.
Valitsemme näistä pienimmän, eli tulemme solmuun 4 solmusta 2.
Tämä tuottaa polun, jonka pituus on $\texttt{lyhin}(2)+1=2$.

Huomaa, että jos solmuun $x$ ei tule kaarta mistään solmusta,
oletamme, että $\texttt{lyhin}(x)=\infty$ ja $\texttt{pisin}(x)=-\infty$.
Tämä on luonteva tulkinta, kun laskemme minimin tai maksimin
tyhjälle joukolle.
Tämän ansiosta emme koskaan muodosta polkua,
joka ei ala solmusta $a$.

Koska tiedämme, että verkko on syklitön,
voimme laskea rekursiivisten funktioiden arvot
tehokkaasti dynaamisella ohjelmoinnilla.
Oleellista on, että emme voi joutua koskaan silmukkaan
laskiessamme arvoja.
Tällä tavalla saamme kuhunkin ongelmaan ratkaisun, joka
vie aikaa $O(n+m)$.

\subsection{Ongelmat verkkoina}

Itse asiassa \emph{minkä tahansa} dynaamisen ohjelmoinnin ratkaisun voi
esittää suunnattuna syklittömänä verkkona.
Tällöin jokainen verkon solmu vastaa yhtä laskettavaa funktion arvoa,
ja kaaret näyttävät, miten funktion arvot riippuvat toisistaan.

Tarkastellaan esimerkkinä tuttua tehtävää,
jossa haluamme muodostaa rahasumman annetuista kolikoista.
Esimerkiksi jos kolikot ovat $\{1,3,4\}$ ja rahasumma on 6,
ratkaisut ovat seuraavat:

\begin{multicols}{2}
\begin{itemize}
\item $4+1+1$
\item $1+4+1$
\item $1+1+4$
\item $3+3$
\item $3+1+1+1$
\item $1+3+1+1$
\item $1+1+3+1$
\item $1+1+1+3$
\item $1+1+1+1+1+1$
\end{itemize}
\end{multicols}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (0) at (0,0) {$0$};
\node[draw, circle] (1) at (2,0) {$1$};
\node[draw, circle] (2) at (4,0) {$2$};
\node[draw, circle] (3) at (6,0) {$3$};
\node[draw, circle] (4) at (8,0) {$4$};
\node[draw, circle] (5) at (10,0) {$5$};
\node[draw, circle] (6) at (12,0) {$6$};
\path[draw,thick,->] (0) -- (1);
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (2) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (5);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (0) edge [bend left] (2);
\path[draw,thick,->] (1) edge [bend left] (3);
\path[draw,thick,->] (2) edge [bend left] (4);
\path[draw,thick,->] (3) edge [bend left] (5);
\path[draw,thick,->] (4) edge [bend left] (6);
\path[draw,thick,->] (0) edge [bend right] (3);
\path[draw,thick,->] (1) edge [bend right] (4);
\path[draw,thick,->] (2) edge [bend right] (5);
\path[draw,thick,->] (3) edge [bend right] (6);
\end{tikzpicture}
\end{center}
\caption{Kolikkotehtävä esitettynä verkkona.}
\label{fig:verkol}
\end{figure}

Voimme esittää tämän tehtävän verkkona niin,
että solmut ovat rahasummia ja kaaret kertovat,
kuinka voimme valita kolikkoja.
Esimerkiksi kuva \ref{fig:verkol} näyttää verkon,
joka vastaa yllä olevaa tapausta.
Tässä verkossa lyhin polku solmusta 0 solmuun 6
($0 \rightarrow 3 \rightarrow 6$)
vastaa ratkaisua $3+3$, jossa kolikoiden määrä on pienin,
ja polkujen yhteismäärä solmusta 0 solmuun 6 on 9,
joka on sama kuin kaikkien ratkaisuiden määrä.

Olemme saaneet siis uuden tavan luonnehtia dynaamista ohjelmointia:
voimme käyttää dynaamista ohjelmointia,
jos pystymme esittämään ongelman suunnattuna syklittömänä verkkona.

\section{Vahvasti yhtenäisyys}

Jos suunnatussa verkossa on sykli,
emme voi muodostaa sille topologista järjestystä
emmekä käyttää dynaamista ohjelmointia.
Mikä neuvoksi, jos kuitenkin haluaisimme tehdä näin?

Joskus voimme ratkaista asian etsimällä
verkon vahvasti yhtenäiset komponentit.
Vahvasti yhtenäinen komponentti on joukko verkon solmuja,
jossa pätee, että mistä tahansa solmusta on polku
mihin tahansa solmuun.
Kun esitämme jokaisen vahvasti yhtenäisen komponentin
yhtenä solmuna, saamme esille verkon syvärakenteen,
joka on aina syklitön verkko.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (0,-2) {$2$};
\node[draw, circle] (3) at (2,0) {$3$};
\node[draw, circle] (4) at (2,-2) {$4$};
\node[draw, circle] (5) at (4,0) {$5$};
\node[draw, circle] (6) at (4,-2) {$6$};

\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (3) -- (2);

\path[draw,thick,->] (5) edge [bend left] (6);
\path[draw,thick,->] (6) edge [bend left] (5);

\path[draw,thick,->] (3) -- (5);
\path[draw,thick,->] (4) -- (6);

\draw[red,dashed,thick,line width=2pt] (-0.75,0.75) rectangle (2.75,-2.75);
\draw[red,dashed,thick,line width=2pt] (3.25,0.75) rectangle (4.75,-2.75);

\node at (2,-3.5) {(a)};
\end{scope}
\begin{scope}[xshift=8cm,yshift=-1cm]
\node[draw,rectangle] (1) at (0,0) {$\{1,2,3,4\}$};
\node[draw,rectangle] (2) at (4,0) {$\{5,6\}$};
\path[draw,thick,->] (1) -- (2);
\node at (2,-2.5) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Verkon vahvasti yhtenäiset komponentit.
(b) Komponenttiverkko, joka kuvaa verkon syvärakenteen.}
\label{fig:vahkom}
\end{figure}

Kuvassa \ref{fig:vahkom} on esimerkkinä verkko, joka muodostuu
kahdesta vahvasti yhtenäisestä komponentista.
Ensimmäinen komponentti on $\{1,2,3,4\}$
ja toinen komponentti on $\{5,6\}$.
Komponenteista muodostuu syklitön komponenttiverkko,
jossa on kaari solmusta $\{1,2,3,4\}$ solmuun $\{5,6\}$.

Seuraavaksi tutustumme Kosarajun algoritmiin,
jonka avulla pystymme etsimään tehokkaasti suunnatun
verkon vahvasti yhtenäiset komponentit ja niitä
vastaavan komponenttiverkon.

\subsection{Kosarajun algoritmi}

Kosarajun algoritmi muodostuu kahdesta verkon läpikäynnistä.
Ensimmäinen läpikäynti muistuttaa topologisen järjestyksen
muodostamista ja tuottaa listan solmuista.
Toinen läpikäynti muodostaa vahvasti yhtenäiset komponentit
ensimmäisen läpikäynnin tuottaman listan avulla.

Algoritmin ensimmäinen läpikäynti aloittaa vuorollaan
syvyyshaun jokaisesta solmusta, jota ei ole vielä käsitelty.
Jokaisessa solmussa käymme ensin läpi kaikki
solmusta lähtevät kaaret ja lisäämme tämän jälkeen solmun listalle.
Toimimme siis kuten topologisen järjestyksen muodostamisessa,
mutta emme välitä, jos tulemme uudestaan samaan solmuun.

Algoritmin toisen läpikäynnin alussa
käännämme jokaisen verkon kaaren suunnan.
Tämän jälkeen käsittelemme ensimmäisen läpikäynnin tuottaman
solmujen listan kääntei\-sessä järjestyksessä.
Jokaisen solmun kohdalla muodostamme uuden vahvasti yhtenäisen
komponentin, jossa on kaikki vielä käsittelemät\-tömät solmut,
joihin pääsemme solmusta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[7]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (0,-2) {$2$};
\node[draw, circle, fill=#4] (3) at (2,0) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,0) {$5$};
\node[draw, circle, fill=#7] (6) at (4,-2) {$6$};

\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (5) edge [bend left] (6);
\path[draw,thick,->] (6) edge [bend left] (5);
\path[draw,thick,->] (3) -- (5);
\path[draw,thick,->] (4) -- (6);

\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{white}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{gray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{lightgray}{white}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{lightgray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\path[draw=red,thick,->,line width=2pt] (6) edge [bend left] (5);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{lightgray}{lightgray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (6);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{lightgray}{gray}{lightgray}{gray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{lightgray}{gray}{gray}{gray}{gray}{gray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kosarajun algoritmin ensimmäinen läpikäynti.}
\label{fig:koseka}
\end{figure}

Tarkastelemme seuraavaksi, kuinka Kosarajun algoritmi
toimii esimerkkiverkossamme.
Kuva \ref{fig:koseka} näyttää ensimmäisen läpikäynnin,
joka muodostaa solmuista listan $[2,5,6,4,3,1]$.
Tämän jälkeen käännämme kaikki verkon kaaret ja
käsittelemme solmut järjestyksessä $[1,3,4,6,5,2]$.
Kuva \ref{fig:kostok} näyttää toisen läpikäynnin.
Vahvasti yhtenäiset komponentit syntyvät
solmuista 1 ja 6 alkaen.
Kaarten kääntämisen ansiosta
solmusta 1 alkava
vahvasti yhtenäinen komponentti ei ''vuoda''
solmujen 5 ja 6 alueelle.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[7]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (0,-2) {$2$};
\node[draw, circle, fill=#4] (3) at (2,0) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,0) {$5$};
\node[draw, circle, fill=#7] (6) at (4,-2) {$6$};

\path[draw,thick,<-] (1) -- (3);
\path[draw,thick,<-] (3) -- (4);
\path[draw,thick,<-] (4) -- (2);
\path[draw,thick,<-] (2) -- (1);
\path[draw,thick,<-] (3) -- (2);
\path[draw,thick,<-] (5) edge [bend left] (6);
\path[draw,thick,<-] (6) edge [bend left] (5);
\path[draw,thick,<-] (3) -- (5);
\path[draw,thick,<-] (4) -- (6);

\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{lightgray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\draw[red,dashed,thick,line width=1.5pt] (-0.75,0.75) rectangle (2.75,-2.75);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{lightgray}{lightgray}{lightgray}{white}{lightgray}
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,<-,line width=2pt] (5) edge [bend left] (6);
\draw[red,dashed,thick,line width=1.5pt] (3.25,0.75) rectangle (4.75,-2.75);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kosarajun algoritmin toinen läpikäynti.}
\label{fig:kostok}
\end{figure}

Koska algoritmi muodostuu kahdesta verkon läpikäynnistä,
sen aikavaativuus on $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

Keskeinen kysymys Kosarajun algoritmiin liittyen on,
miten voimme olla varmoja, että saamme verkon toisessa läpikäynnissä
muodostettua vahvasti yhtenäisiä komponentteja,
joihin ei tule ylimääräisiä solmuja?

Voimme tarkastella asiaa muodostettavana olevan syklittömän
komponenttiverkon näkökulmasta.
Jos meillä on komponentti $A$, josta pääsee kaarella
komponenttiin $B$, 
algoritmin ensimmäinen läpikäynti takaa,
jokin $A$:n solmu lisätään listalle kaikkien $B$:n
solmujen jälkeen.
Kun sitten käymme läpi listan käänteisessä järjestyksessä,
jokin $A$:n solmu tulee vastaan ennen kaikkia $B$:n
solmuja.
Niinpä alamme rakentaa komponenttia $A$,
emmekä mene komponentin $B$ puolelle,
koska verkon kaaret on käännetty.

Vastaavasti jos meillä on komponentti $A$,
johon pääsee komponentista $B$,
muodostamme komponentin $B$ ennen komponenttia $A$.
Niinpä kun käänteisessä verkossa
komponentista $A$ on kaari komponenttiin $B$,
tämä ei haittaa, koska olemme jo muodostaneet
komponentin $B$ eikä komponenttiin $A$ tule ylimääräisiä solmuja
komponentista $B$.

\section{Esimerkki: Luolapeli}

Olemme pelissä luolastossa, joka muodostuu luolista ja niitä yhdistävistä
käytävistä. Jokainen käytävä on yksisuuntainen.
Jokaisessa luolassa on yksi aarre, jonka voimme ottaa mukaamme,
jos kuljemme luolan kautta.

Peli alkaa luolasta $a$ ja päättyy luolaan $b$.
Montako aarretta voimme saada, jos valitsemme parhaan
mahdollisen reitin?

\subsubsection{Ratkaisu}

Voimme mallintaa tilanteen verkkona, jonka solmut ovat luolia ja
kaaret ovat käytäviä. Haluamme löytää reitin solmusta $a$ solmuun $b$
niin, että kuljemme mahdollisimman monen solmun kautta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (2,-1) {$2$};
\node[draw, circle] (3) at (-2,0) {$3$};
\node[draw, circle] (4) at (0,-2) {$4$};
\node[draw, circle] (5) at (0,-4) {$5$};
\node[draw, circle] (6) at (-2,-2) {$6$};
\node[draw, circle] (7) at (-2,-4) {$7$};

\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (4) -- (2);
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (4) -- (6);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (6);
\path[draw,thick,->] (6) edge [bend left] (7);
\path[draw,thick,->] (7) edge [bend left] (6);
\path[draw,thick,->] (4) -- (5);
\path[draw,thick,->] (5) -- (7);
\end{tikzpicture}
\end{center}
\caption{Luolasto, jossa on 7 luolaa ja 10 käytävää.
Haluamme kulkea luolasta 1 luolaan 7 keräten mahdollisimman paljon aarteita.}
\label{fig:luopel}
\end{figure}

Esimerkiksi kuva \ref{fig:luopel} näyttää verkkona luolaston, joka muodostuu
7 luolasta ja 10 käytävästä.
Oletetaan, että haluamme liikkua luolasta 1 luolaan 7
keräten mahdollisimman paljon aarteita.
Tällöin yksi mahdollinen reitti on
$1 \rightarrow 4 \rightarrow 2 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 7$,
jonka avulla saamme kaikki aarteet paitsi luolassa 5 olevan aarteen.
Ei ole olemassa reittiä, jota seuraamalla saisimme kaikki luolaston aarteet.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, rectangle] (1) at (0,0) {$\{1,2,4\}$};
\node[draw, rectangle] (2) at (-4,-2) {$\{3\}$};
\node[draw, rectangle] (3) at (4,-2) {$\{5\}$};
\node[draw, rectangle] (4) at (0,-4) {$\{6,7\}$};

\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\end{tikzpicture}
\end{center}
\caption{Luolaston vahvasti yhtenäiset komponentit.}
\label{fig:luovah}
\end{figure}

Voimme ratkaista ongelman tehokkaasti määrittämällä ensin verkon
vahvasti yhtenäiset komponentit.
Tämän jälkeen meidän riittää löytää polku alkusolmun komponentista
loppusolmun komponenttiin niin, että komponenttien kokojen summa
on suurin mahdollinen.
Koska verkko on syklitön, tämä onnistuu dynaamisella ohjelmoinnilla.

Kuva \ref{fig:luovah} näyttää vahvasti yhtenäiset komponentit
esimerkkiverkossamme.
Tästä esityksestä näemme suoraan, että optimaalisia reittejä on kaksi:
voimme kulkea joko luolan 3 tai luolan 5 kautta.