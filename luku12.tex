\chapter{Syklittömät verkot}

Verkon käsittelyssä keskeinen haaste ovat verkossa olevat syklit.
Jos voimme olettaa, että verkossa ei ole syklejä,
voimme ratkaista monia ongelmia helpommin kuin yleisissä verkoissa,
joissa saattaa olla syklejä.

Tässä luvussa keskitymme verkkoihin, jotka ovat suunnattuja
ja syklit\-tömiä.
Englanniksi tällaisia verkkoja kutsutaan usein nimellä \emph{dag},
joka tulee sanoista \emph{directed acyclic graph}.
Tässä tapauksessa voimme muodostaa verkolle topologisen
järjestyksen ja käyttää sen jälkeen dynaamista ohjelmointia
verkko-ongelmien ratkaisemiseen.

\section{Topologinen järjestys}

Suunnatun verkon \emph{topologinen järjestys} on solmujen järjestys,
jossa pätee, että jos solmusta $a$ on kaari solmuun $b$,
niin solmu $a$ on ennen solmua $b$ järjestyksessä.
Topologinen järjestys voidaan esittää listana,
joka sisältää kaikki verkon solmut sopivassa järjestyksessä.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\end{scope}
\begin{scope}[xshift=7cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (3) at (2,-1) {$3$};
\node[draw, circle] (5) at (4,-1) {$5$};
\node[draw, circle] (2) at (6,-1) {$2$};
\node[draw, circle] (4) at (8,-1) {$4$};
\path[draw,thick,->] (1) edge [bend right] (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) edge [bend left] (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) edge [bend left] (4);
\path[draw,thick,->] (5) edge [bend right] (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja yksi sen topologinen järjestys $[1,3,5,2,4]$.}
\label{fig:topjar}
\end{figure}

Kuvassa \ref{fig:topjar} on esimerkkinä verkko ja yksi sen topologinen
järjestys $[1,3,5,2,4]$.
Huomaa, että verkolla on usein monta mahdollista
topologista järjestystä.
Esimerkiksi tässä verkossa myös $[5,1,3,2,4]$,
$[1,5,3,2,4]$ ja $[1,3,2,5,4]$
ovat topologisia järjestyksiä, koska voimme valita monella tavalla,
missä vaiheessa solmu $5$ on järjestyksessä.

Jos suunnattu verkko on syklitön, voimme muodostaa sille
aina topologisen järjestyksen.
Toisaalta jos verkossa on sykli,
topologista järjestystä ei voi olla olemassa,
koska emme voi valita mitään syklissä olevaa solmua
järjestykseen ennen toista.
Seuraavaksi tutustumme algoritmiin,
jonka avulla voimme muodostaa topologisen järjestyksen
tai todeta, että verkossa on sykli eikä järjestys ole mahdollinen.

\subsection{Järjestyksen muodostaminen}

Voimme muodostaa topologisen järjestyksen käyttämällä
muunnettua syvyyshakua, jossa jokaisella solmulla on kolme tilaa:

\begin{itemize}
\item tila 0 (valkoinen): solmussa ei ole käyty
\item tila 1 (harmaa): solmun käsittely on kesken
\item tila 2 (musta): solmun käsittely on valmis
\end{itemize}

Algoritmin alussa jokainen solmu on valkoinen.
Käymme läpi kaikki verkon solmut ja aloitamme aina syvyyshaun
solmusta, jos se on valkoinen.
Aina kun saavumme uuteen solmuun, sen väri muuttuu
valkoisesta harmaaksi.
Sitten kun olemme käsitelleet kaikki solmusta lähtevät
kaaret, sen väri muuttuu harmaasta mustaksi.

Algoritmin aikana luomme listan, johon lisäämme solmun
aina silloin, kun sen väri muuttuu mustaksi.
Tämä lista käänteisessä järjestyksessä on verkon
topologinen järjestys.
Kuitenkin jos saavumme jossain vaiheessa uudestaan harmaaseen solmuun,
verkossa on sykli eikä topologista järjestystä voi muodostaa.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{white}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{white}{gray}{white}
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{gray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{gray}{gray}{gray}{gray}{white}
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{gray}{gray}{gray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki topologisen järjestyksen muodostamisesta.}
\label{fig:topesi}
\end{figure}

Kuva \ref{fig:topesi} näyttää, kuinka algoritmi muodostaa topologisen
järjestyksen esimerkkiverkossamme.
Tässä tapauksessa syvyyshakuja on kaksi,
joista ensimmäinen alkaa solmusta 1 ja toinen alkaa solmusta 5.
Algoritmin tuloksena on lista $[4,2,3,1,5]$,
joten käänteinen lista $[5,1,3,2,4]$ on verkon topologinen järjestys.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Topologista järjestystä ei voi muodostaa syklin takia.}
\label{fig:topsyk}
\end{figure}

Kuva \ref{fig:topsyk} näyttää puolestaan esimerkin tilanteesta,
jossa topologista järjestystä ei voi muodostaa verkossa
olevan syklin takia.
Tässä verkossa on sykli $2 \rightarrow 4 \rightarrow 3 \rightarrow 2$,
jonka olemassaolon huomaamme siitä, että tulemme uudestaan
harmaaseen solmuun 2.

Algoritmin toiminta vastaa syvyyshakua, joten se vie aikaa $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

TODO

\section{Dynaaminen ohjelmointi}

Kun tiedämme, että suunnattu verkko on syklitön,
voimme ratkaista monia verkko-ongelmia tehokkaasti
dynaamisen ohjelmoinnin avulla.
Esimerkkejä tällaisista ongelmista ovat:

\begin{itemize}
\item Kuinka pitkä on lyhin polku solmusta $a$ solmuun $b$?
\item Kuinka pitkä on pisin polku solmusta $a$ solmuun $b$?
\item Montako erilaista polkua on solmusta $a$ solmuun $b$?
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} verkossa on kolme
mahdollista polkua solmusta 1 solmuun 4:
$1 \rightarrow 2 \rightarrow 4$,
$1 \rightarrow 3 \rightarrow 2 \rightarrow 4$ ja
$1 \rightarrow 3 \rightarrow 4$.
Lyhin polun pituus on 2 ja pisin polun pituus on 3.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Mahdolliset polut solmusta 1 solmuun 4.}
\label{fig:verpol}
\end{figure}

Osoittautuu, että voimme ratkaista
kaikki yllä mainitut ongelmat
ajassa $O(n+m)$ dynaamisella ohjelmoinnilla,
kun oletamme, että verkko on suunnattu ja syklitön.
Yleisessä verkossa tilanne on toinen:
voimme etsiä lyhimmän polun Dijkstran algoritmilla
ajassa $O(m \log n)$, mutta pisimmän polun etsimiseen
tai polkujen yhteismäärän laskemiseen ei tunneta
mitään tehokasta menetelmää.

\subsection{Polkujen käsittely}

Jotta voimme käyttää dynaamista ohjelmointia,
meidän täytyy määritellä ongelmat rekursiivisesti.
Sopivat funktiot ovat seuraavat:

\begin{itemize}
\item $\texttt{lyhin}(x)$: lyhimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{pisin}(x)$: pisimmän polun pituus solmusta $a$ solmuun $x$
\item $\texttt{maara}(x)$: polkujen yhteismäärä solmusta $a$ solmuun $x$
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} tilanteessa lähtösolmu on $a=1$
ja funktiot saavat arvot $\texttt{lyhin}(4)=2$,
$\texttt{pisin}(4)=3$ ja $\texttt{maara}(4)=3$.

Funktioiden pohjatapaukset ovat seuraavat:

\begin{align*}
\texttt{lyhin}(a)&=0 \\
\texttt{pisin}(a)&=0 \\
\texttt{maara}(a)&=1
\end{align*}

Tämä tarkoittaa tilannetta, jossa haluamme kulkea solmusta $a$
solmuun $a$. Koska polulla ei ole yhtään kaaria,
sekä lyhimmän että pisimmän polun pituus on 0.
Polkujen määrä on 1, koska ainoa polku on tyhjä polku.

Seuraavaksi määrittelemme yleisen tapauksen solmulle $x$.
Oletamme, että solmuun $x$ pääsee kaarella $k$ solmusta,
joiden tunnukset ovat $u_1,u_2,\dots,u_k$.
Tällöin saamme seuraavat rekursiiviset kaavat:

\begin{align*}
\texttt{lyhin}(x)&=\min(\texttt{lyhin}(u_1),\texttt{lyhin}(u_2),\dots,\texttt{lyhin}(u_k))+1 \\
\texttt{pisin}(x)&=\max(\texttt{pisin}(u_1),\texttt{pisin}(u_2),\dots,\texttt{pisin}(u_k))+1 \\
\texttt{maara}(x)&=\texttt{maara}(u_1)+\texttt{maara}(u_2)+\dots+\texttt{maara}(u_k)
\end{align*}

Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $x$,
meidän tulee valita edellinen solmu niin,
että siihen on lyhin matka solmusta $a$.
Niinpä valitsemme minimin edellisistä arvoista
ja lisäämme siihen yhden.
Vastaavasti kun haluamme muodostaa pisimmän polun,
valitsemme maksimin edellisistä arvoista.
Kun taas haluamme laskea polkujen yhteismäärän,
laskemme yhteen kaikki solmuun johtavat polut.

Tarkastellaan esimerkkinä kuvan \ref{fig:verpol} verkkoa,
jossa tutkimme polkuja solmusta 1 solmuun 4.
Kun haluamme laskea funktioiden arvot solmulle 4,
otamme huomioon kaaret
$2 \rightarrow 4$, $3 \rightarrow 4$ ja $5 \rightarrow 4$,
joita kulkemalla pääsee muista solmuista solmuun 4.
Oletamme, että olemme laskeneet aiemmin funktioiden
arvot solmuille 2, 3 ja 5.

Nyt esimerkiksi lyhin polku solmusta 1 solmuun 4 on pituudeltaan
\[ \texttt{lyhin}(4)=\min(\texttt{lyhin}(2),\texttt{lyhin}(3),\texttt{lyhin}(5))+1.\]
Aiemmat arvot ovat $\texttt{lyhin}(2)=1$, $\texttt{lyhin}(3)=2$ ja $\texttt{lyhin}(5)=\infty$.
Valitsemme näistä pienimmän, eli tulemme solmuun 4 solmusta 2.
Tämä tuottaa polun, jonka pituus on $\texttt{lyhin}(2)+1=2$.

Huomaa, että jos solmuun $x$ ei tule kaarta mistään solmusta,
oletamme, että $\texttt{lyhin}(x)=\infty$ ja $\texttt{pisin}(x)=-\infty$.
Tämä on luonteva tulkinta, kun laskemme minimin tai maksimin
tyhjälle joukolle.
Tämän ansiosta emme koskaan muodosta polkua,
joka ei ala solmusta $a$.

Koska tiedämme, että verkko on syklitön,
voimme laskea rekursiivisten funktioiden arvot
tehokkaasti dynaamisella ohjelmoinnilla.
Oleellista on, että emme voi joutua koskaan silmukkaan
laskiessamme arvoja.
Tällä tavalla saamme kuhunkin ongelmaan ratkaisun, joka
vie aikaa $O(n+m)$.

\subsection{Ongelmat verkkoina}

Itse asiassa \emph{minkä tahansa} dynaamisen ohjelmoinnin ratkaisun voi
esittää suunnattuna syklittömänä verkkona.
Tällöin jokainen verkon solmu vastaa yhtä laskettavaa funktion arvoa,
ja kaaret näyttävät, miten funktion arvot riippuvat toisistaan.

Tarkastellaan esimerkkinä tuttua tehtävää,
jossa haluamme muodostaa rahasumman annetuista kolikoista.
Esimerkiksi jos kolikot ovat $\{1,3,4\}$ ja rahasumma on 6,
ratkaisut ovat seuraavat:

\begin{multicols}{2}
\begin{itemize}
\item $4+1+1$
\item $1+4+1$
\item $1+1+4$
\item $3+3$
\item $3+1+1+1$
\item $1+3+1+1$
\item $1+1+3+1$
\item $1+1+1+3$
\item $1+1+1+1+1+1$
\end{itemize}
\end{multicols}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (0) at (0,0) {$0$};
\node[draw, circle] (1) at (2,0) {$1$};
\node[draw, circle] (2) at (4,0) {$2$};
\node[draw, circle] (3) at (6,0) {$3$};
\node[draw, circle] (4) at (8,0) {$4$};
\node[draw, circle] (5) at (10,0) {$5$};
\node[draw, circle] (6) at (12,0) {$6$};
\path[draw,thick,->] (0) -- (1);
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (2) -- (3);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (4) -- (5);
\path[draw,thick,->] (5) -- (6);
\path[draw,thick,->] (0) edge [bend left] (2);
\path[draw,thick,->] (1) edge [bend left] (3);
\path[draw,thick,->] (2) edge [bend left] (4);
\path[draw,thick,->] (3) edge [bend left] (5);
\path[draw,thick,->] (4) edge [bend left] (6);
\path[draw,thick,->] (0) edge [bend right] (3);
\path[draw,thick,->] (1) edge [bend right] (4);
\path[draw,thick,->] (2) edge [bend right] (5);
\path[draw,thick,->] (3) edge [bend right] (6);
\end{tikzpicture}
\end{center}
\caption{Kolikkotehtävä esitettynä verkkona.}
\label{fig:verkol}
\end{figure}

Voimme esittää tämän tehtävän verkkona niin,
että solmut ovat rahasummia ja kaaret kertovat,
kuinka voimme valita kolikkoja.
Esimerkiksi kuva \ref{fig:verkol} näyttää verkon,
joka vastaa yllä olevaa tapausta.
Tässä verkossa lyhin polku solmusta 0 solmuun 6
($0 \rightarrow 3 \rightarrow 6$)
vastaa ratkaisua $3+3$, jossa kolikoiden määrä on pienin,
ja polkujen yhteismäärä solmusta 0 solmuun 6 on 9,
joka on sama kuin kaikkien ratkaisuiden määrä.

Olemme saaneet siis uuden tavan luonnehtia dynaamista ohjelmointia:
voimme käyttää dynaamista ohjelmointia,
jos pystymme esittämään ongelman suunnattuna syklittömänä verkkona.

\section{Vahvasti yhtenäisyys}

