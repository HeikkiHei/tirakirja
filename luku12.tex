\chapter{Syklittömät verkot}

Verkon käsittelyssä keskeinen haaste ovat verkossa olevat syklit.
Jos voimme olettaa, että verkossa ei ole syklejä,
voimme ratkaista monia ongelmia helpommin kuin yleisissä verkoissa,
joissa saattaa olla syklejä.

Tässä luvussa keskitymme verkkoihin, jotka ovat suunnattuja
ja syklit\-tömiä.
Englanniksi tällaisia verkkoja kutsutaan usein nimellä \emph{dag},
joka tulee sanoista \emph{directed acyclic graph}.
Tässä tapauksessa voimme muodostaa verkolle topologisen
järjestyksen ja käyttää sen jälkeen dynaamista ohjelmointia
verkko-ongelmien ratkaisemiseen.

\section{Topologinen järjestys}

Suunnatun verkon \emph{topologinen järjestys} on solmujen järjestys,
jossa pätee, että jos solmusta $a$ on kaari solmuun $b$,
niin solmu $a$ on ennen solmua $b$ järjestyksessä.
Topologinen järjestys voidaan esittää listana,
joka sisältää kaikki verkon solmut sopivassa järjestyksessä.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\end{scope}
\begin{scope}[xshift=7cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (3) at (2,-1) {$3$};
\node[draw, circle] (5) at (4,-1) {$5$};
\node[draw, circle] (2) at (6,-1) {$2$};
\node[draw, circle] (4) at (8,-1) {$4$};
\path[draw,thick,->] (1) edge [bend right] (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) edge [bend left] (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) edge [bend left] (4);
\path[draw,thick,->] (5) edge [bend right] (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja yksi sen topologinen järjestys $[1,3,5,2,4]$.}
\label{fig:topjar}
\end{figure}

Kuvassa \ref{fig:topjar} on esimerkkinä verkko ja yksi sen topologinen
järjestys $[1,3,5,2,4]$.
Huomaa, että verkolla on usein monta mahdollista
topologista järjestystä.
Esimerkiksi tässä verkossa myös $[5,1,3,2,4]$,
$[1,5,3,2,4]$ ja $[1,3,2,5,4]$
ovat topologisia järjestyksiä, koska voimme valita monella tavalla,
missä vaiheessa solmu $5$ on järjestyksessä.

Jos suunnattu verkko on syklitön, voimme muodostaa sille
aina topologisen järjestyksen.
Toisaalta jos verkossa on sykli,
topologista järjestystä ei voi olla olemassa,
koska emme voi valita mitään syklissä olevaa solmua
järjestykseen ennen toista.
Seuraavaksi tutustumme algoritmiin,
jonka avulla voimme muodostaa topologisen järjestyksen
tai todeta, että verkossa on sykli eikä järjestys ole mahdollinen.

\subsection{Järjestyksen muodostaminen}

Voimme muodostaa topologisen järjestyksen käyttämällä
muunnettua syvyyshakua, jossa jokaisella solmulla on kolme tilaa:

\begin{itemize}
\item tila 0 (valkoinen): solmussa ei ole käyty
\item tila 1 (harmaa): solmun käsittely on kesken
\item tila 2 (musta): solmun käsittely on valmis
\end{itemize}

Algoritmin alussa jokainen solmu on valkoinen.
Käymme läpi kaikki verkon solmut ja aloitamme aina syvyyshaun
solmusta, jos se on valkoinen.
Aina kun saavumme uuteen solmuun, sen väri muuttuu
valkoisesta harmaaksi.
Sitten kun olemme käsitelleet kaikki solmusta lähtevät
kaaret, sen väri muuttuu harmaasta mustaksi.

Algoritmin aikana luomme listan, johon lisäämme solmun
aina silloin, kun sen väri muuttuu mustaksi.
Tämä lista käänteisessä järjestyksessä on verkon
topologinen järjestys.
Kuitenkin jos saavumme jossain vaiheessa uudestaan harmaaseen solmuun,
verkossa on sykli eikä topologista järjestystä voi muodostaa.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{white}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{gray}{white}{gray}{white}
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{gray}{lightgray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{gray}{gray}{gray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{gray}{gray}{gray}{gray}{white}
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{gray}{gray}{gray}{gray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{gray}{gray}{gray}{gray}{gray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki topologisen järjestyksen muodostamisesta.}
\label{fig:topesi}
\end{figure}

Kuva \ref{fig:topesi} näyttää, kuinka algoritmi muodostaa topologisen
järjestyksen esimerkkiverkossamme.
Tässä tapauksessa syvyyshakuja on kaksi,
joista ensimmäinen alkaa solmusta 1 ja toinen alkaa solmusta 5.
Algoritmin tuloksena on lista $[4,2,3,1,5]$,
joten käänteinen lista $[5,1,3,2,4]$ on verkon topologinen järjestys.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,-1) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (2,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (4,0) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (5) -- (4);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Topologista järjestystä ei voi muodostaa syklin takia.}
\label{fig:topsyk}
\end{figure}

Kuva \ref{fig:topsyk} näyttää puolestaan esimerkin tilanteesta,
jossa topologista järjestystä ei voi muodostaa verkossa
olevan syklin takia.
Tässä verkossa on sykli $2 \rightarrow 4 \rightarrow 3 \rightarrow 2$,
jonka olemassaolon huomaamme siitä, että tulemme uudestaan
harmaaseen solmuun 2.

Algoritmin toiminta vastaa syvyyshakua, joten se vie aikaa $O(n+m)$.

\subsection{Miksi algoritmi toimii?}

TODO

\section{Dynaaminen ohjelmointi}

Kun tiedämme, että suunnattu verkko on syklitön,
voimme ratkaista monia verkko-ongelmia tehokkaasti
dynaamisen ohjelmoinnin avulla.
Esimerkkejä tällaisista ongelmista ovat:

\begin{itemize}
\item Kuinka pitkä on lyhin polku solmusta $a$ solmuun $b$?
\item Kuinka pitkä on pisin polku solmusta $a$ solmuun $b$?
\item Montako erilaista polkua on solmusta $a$ solmuun $b$?
\end{itemize}

Esimerkiksi kuvan \ref{fig:verpol} verkossa on kolme
mahdollista polkua solmusta 1 solmuun 4:
$1 \rightarrow 2 \rightarrow 4$,
$1 \rightarrow 3 \rightarrow 2 \rightarrow 4$ ja
$1 \rightarrow 3 \rightarrow 4$.
Lyhin polun pituus on 2 ja pisin polun pituus on 3.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (5) -- (4);
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\path[draw=red,thick,->,line width=2pt] (3) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Mahdolliset polut solmusta 1 solmuun 4.}
\label{fig:verpol}
\end{figure}

Osoittautuu, että voimme ratkaista
suunnatussa syklittömässä verkossa kaikki yllä mainitut ongelmat
ajassa $O(n+m)$ dynaamisella ohjelmoinnilla.
Yleisessä verkossa tilanne on toinen:
voimme etsiä lyhimmän polun Dijkstran algoritmilla
ajassa $O(m \log n)$, mutta pisimmän polun etsimiseen
tai polkujen yhteismäärän laskemiseen ei tunneta
mitään tehokasta menetelmää.

\subsection{Polkujen käsittely}

Tarkastellaan aluksi tilannetta, jossa haluamme löytää
lyhimmän tai pisimmän polun solmusta $a$ solmuun $b$.
Voimme ratkaista molemmat tehtävät samalla tavalla,
ja keskitymme seuraavaksi lyhimmän polun etsimiseen.

Ideana on määritellä laske arvoja funktiolle $f(x)$,
joka kertoo, kuinka pitkä on lyhin polku solmusta
$a$ solmuun $x$.
Funktion arvo $f(b)$ kertoo siis,
kuinka pitkä on lyhin polku solmusta $a$ solmuun $b$.
Esimerkiksi kuvan \ref{fig:verpol}
verkossa $f(4)=2$, kun lähtösolmuna on $a=1$.

Kun haluamme selvittää vastauksen solmulle $x$,
meillä on kaksi mahdollista tapausta.
Pohjatapauksessa $x=a$ ja $f(x)=0$, koska pääsemme solmusta
$a$ solmuun $a$ kulkematta ollenkaan kaaria.
Yleisessä tapauksessa käymme läpi kaikki tavat,
kuinka olemme voineet saapua solmuun $x$.
Oletetaan, että solmuun $x$ pääsee kaarilla
solmuista $u_1,u_2,\dots,u_k$
ja tiedossamme on arvot $f(u_1),f(u_2),\dots,f(u_k)$.
Tällöin
\[f(x)=\min(f(u_1),f(u_2),\dots,f(u_k)).\]

Koska tiedämme, että verkko on syklitön, olemme saaneet
aikaan rekursiivisen funktion, jota voimme käyttää
dynaamisessa ohjelmoinnissa.
Oleellista on, että emme voi joutua koskaan silmukkaan
laskiessamme dynaamisen ohjelmoinnin arvoja.
Tuloksena oleva algoritmi vie aikaa $O(n+m)$.

Jos haluammekin selvittää pisimmän polun pituuden,
voimme käyttää kaavaa
\[f(x)=\max(f(u_1),f(u_2),\dots,f(u_k))\]
ja kaikki toimii muuten samalla tavalla.

Lopulta jos haluamme laskea eri polkujen määrän,
voimme määritellä $f(a)=1$ ja käyttää kaavaa
\[f(x)=f(u_1)+f(u_2)+f(u_k),\]


\subsection{Ongelmat verkkoina}

Itse asiassa minkä tahansa dynaamisen ohjelmoinnin ratkaisun voi
esittää suunnattuna syklittömänä verkkona.
Tällöin jokainen verkon solmu vastaa yhtä laskettavaa funktion arvoa,
ja kaaret näyttävät, miten funktion arvot riippuvat toisistaan.

\section{Vahvasti yhtenäisyys}

