\chapter{Verkkojen perusteet}

Voimme ratkaista monia algoritmisia ongelmia
esittämällä tilanteen \emph{verkkona} ja käyttämällä sitten
sopivaa verkkoalgoritmia.
Tyypillinen esimerkki verkosta on tieverkosto,
joka muodostuu kaupungeista ja niiden välisistä teistä.
Tällaisessa verkossa ongelmana voi olla selvittää vaikkapa,
kuinka voimme matkustaa kaupungista $a$ kaupunkiin $b$.

Tässä luvussa aloitamme verkkoihin tutustumisen
käymällä läpi verkkojen käsitteitä sekä tapoja
esittää verkkoja ohjelmoinnissa.
Tämän jälkeen näemme, miten voimme tutkia verkkojen rakennetta
ja ominaisuuksia syvyyshaun ja leveyshaun avulla.
Seuraavissa kirjan luvuissa jatkamme verkkojen käsittelyä ja
opimme lisää verkkoalgoritmeja.

\section{Verkkojen käsitteitä}

Verkko muodostuu \emph{solmuista} ja
niitä yhdistävistä \emph{kaarista}.
Esimerkiksi kuvassa \ref{fig:veresi} on verkko,
jossa on viisi solmua ja seitsemän kaarta.
Merkitsemme verkon solmujen
määrää kirjaimella $n$ ja kaarten määrää
kirjaimella $m$.
Lisäksi numeroimme verkon solmut kokonaisluvuin
$1,2,\dots,n$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (1) -- (4);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
\caption{Verkko, jossa on viisi solmua ja seitsemän kaarta.}
\label{fig:veresi}
\end{figure}

Sanomme, että kaksi solmua ovat \emph{vierekkäin} verkossa,
jos niiden välillä on kaari.
Solmun \emph{naapureja} ovat kaikki solmut,
joihin se on yhteydessä kaarella,
ja solmun \emph{aste} on sen naapureiden määrä.
Kuvassa \ref{fig:veresi} solmun 2 naapurit ovat 1, 4 ja 5,
joten solmun aste on 3.
Voimme kulkea solmusta 1 solmuun 5
esimerkiksi polkua $1 \rightarrow 2 \rightarrow 5$
tai $1 \rightarrow 3 \rightarrow 4 \rightarrow 5$.

\subsubsection{Polku ja sykli}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (1) -- (4);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);

\path[draw,thick,->,red,line width=2pt] (1) -- (2);
\path[draw,thick,->,red,line width=2pt] (2) -- (5);
\end{scope}
\begin{scope}[xshift=8cm]
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (1) -- (4);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);

\path[draw,thick,->,red,line width=2pt] (1) -- (3);
\path[draw,thick,->,red,line width=2pt] (3) -- (4);
\path[draw,thick,->,red,line width=2pt] (4) -- (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Kaksi polkua solmusta $1$ solmuun $5$.}
\label{fig:verpoe}
\end{figure}

Verkossa oleva \emph{polku} on kaaria pitkin kulkeva reitti
lähtösolmusta kohdesolmuun.
Kuva \ref{fig:verpoe} näyttää kaksi
mahdollista polkua solmusta $1$ solmuun $5$ esimerkkiverkossamme.
Ensimmäinen polku on $1 \rightarrow 2 \rightarrow 5$
ja toinen polku on $1 \rightarrow 3 \rightarrow 4 \rightarrow 5$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (1) -- (4);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);

\path[draw,thick,->,red,line width=2pt] (2) -- (4);
\path[draw,thick,->,red,line width=2pt] (4) -- (5);
\path[draw,thick,->,red,line width=2pt] (5) -- (2);
\end{tikzpicture}
\end{center}
\caption{Verkossa on sykli $2 \rightarrow 4 \rightarrow 5 \rightarrow 2$.}
\label{fig:versyk}
\end{figure}


Polku on \emph{sykli},
jos se alkaa ja päättyy samassa solmussa,
kulkee ainakin yhden toisen solmun kautta
eikä kulje kahta kertaa saman solmun tai kaaren kautta.
Kuvassa \ref{fig:versyk} on esimerkkinä sykli
$2 \rightarrow 4 \rightarrow 5 \rightarrow 2$.
Jos verkossa ei ole yhtään sykliä, sanomme, että verkko on \emph{syklitön}.

\subsubsection{Yhtenäisyys ja komponentit}

Verkko on \emph{yhtenäinen},
jos minkä tahansa kahden solmun välillä on polku.
Kuvan \ref{fig:veresi} verkko on yhtenäinen,
mutta kuvan \ref{fig:veryht} verkko ei ole yhtenäinen,
koska esimerkiksi solmujen $1$ ja $2$ välillä ei ole polkua.

Voimme esittää verkon aina kokoelmana yhtenäisiä \emph{komponentteja}.
Kuvassa \ref{fig:veryht} yhtenäiset komponentit
ovat $\{1,3\}$ ja $\{2,4,5\}$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
\caption{Verkon yhtenäiset komponentit ovat $\{1,3\}$ ja $\{2,4,5\}$.}
\label{fig:veryht}
\end{figure}

Verkko on \emph{puu}, jos se on sekä yhtenäinen
että syklitön.
Puussa kaarten määrä on aina yhden pienempi
kuin solmujen määrä, ja jokaisen kahden solmun
välillä on yksikäsitteinen polku.
Kuvassa \ref{fig:verpuu} on esimerkkinä puu,
jossa on viisi solmua ja neljä kaarta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (3) -- (4);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
\caption{Yhtenäinen, syklitön verkko eli puu.}
\label{fig:verpuu}
\end{figure}

\subsubsection{Suunnattu verkko}

\emph{Suunnatussa} verkossa
jokaisella kaarella on tietty suunta,
jonka mukaisesti meidän täytyy kulkea kaarta pitkin.
Suunnat rajoittavat siis kulkemistamme verkossa.
Kuvassa \ref{fig:versuu} on esimerkkinä
suunnattu verkko, jossa
voimme kulkea solmusta $1$ solmuun $5$
polkua $1 \rightarrow 2 \rightarrow 5$,
mutta emme voi kulkea mitenkään solmusta $5$ solmuun $1$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) -- (5);
\path[draw,thick,->] (4) -- (5);
\end{tikzpicture}
\end{center}
\caption{Suunnattu verkko.}
\label{fig:versuu}
\end{figure}

\subsubsection{Painotettu verkko}

\emph{Painotetussa} verkossa
jokaiseen kaareen liittyy jokin paino,
joka kuvaa tyypillisesti kaaren pituutta.
Kun kuljemme polkua painotetussa verkossa,
polun pituus on kaarten painojen summa.
Kuvassa \ref{fig:verpae} on esimerkkinä painotettu verkko.
Tässä verkossa polun $1 \rightarrow 2 \rightarrow 5$
paino on $5+8=13$ ja polun
$1 \rightarrow 3 \rightarrow 4 \rightarrow 5$
paino on $2+4+3=9$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,-] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=left:2] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:9] {} (4);
\path[draw,thick,-] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,-] (2) -- node[font=\small,label=above:8] {} (5);
\path[draw,thick,-] (4) -- node[font=\small,label=right:2] {} (2);
\path[draw,thick,-] (4) -- node[font=\small,label=below:3] {} (5);
\end{tikzpicture}
\end{center}
\caption{Painotettu verkko.}
\label{fig:verpae}
\end{figure}


\section{Verkot ohjelmoinnissa}

Verkon esittämiseen ohjelmoinnissa on monia mahdollisuuksia.
Sopivan esitystavan valintaan vaikuttaa,
miten haluamme käsitellä verkkoa algoritmissa,
koska jokaisessa esitystavassa on omat etunsa.
Seuraavaksi käymme läpi kolme tavallista esitystapaa.

\subsection{Vieruslistaesitys}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) -- (5);
\path[draw,thick,->] (4) -- (5);
\end{scope}
\begin{scope}[xshift=9cm,yshift=-0.5cm]
\draw (0,0) grid (1,5);
\foreach \x in {1,...,5} \node at (0.5,0.5-\x+5) {\x};
\draw[->,thick] (1,4.5) -- (2,4.5);
\draw[->,thick] (3,4.5) -- (4,4.5);
\draw[->,thick] (5,4.5) -- (6,4.5);
\draw[->,thick] (1,3.5) -- (2,3.5);
\draw[->,thick] (3,3.5) -- (4,3.5);
\draw[->,thick] (1,2.5) -- (2,2.5);
\draw[->,thick] (1,1.5) -- (2,1.5);
\node at (2.5,4.5) {$2$};
\node at (4.5,4.5) {$3$};
\node at (6.5,4.5) {$4$};
\node at (2.5,3.5) {$4$};
\node at (4.5,3.5) {$5$};
\node at (2.5,2.5) {$4$};
\node at (2.5,1.5) {$5$};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkon vieruslistaesitys.}
\label{fig:vervil}
\end{figure}

Vieruslistaesityksessä luomme kullekin verkon solmulle
\emph{vieruslistan}, joka kertoo, mihin solmuihin voimme
siirtyä solmusta kaaria pitkin.
Kuva \ref{fig:vervil} näyt\-tää esimerkkinä verkon
ja sitä vastaavan vieruslistaesityksen.
Jos haluamme tallentaa verkon vieruslistoina Javassa,
voimme luoda taulukon

\begin{code}
ArrayList<Integer>[] verkko = new ArrayList<>[n+1];
\end{code}

ja alustaa vieruslistat näin:

\begin{code}
for (int i = 1; i <= n; i++) {
    verkko[i] = new ArrayList<>();
}
\end{code}

Tämän jälkeen lisäämme kaaret listoille näin:

\begin{code}
verkko[1].add(2);
verkko[1].add(3);
verkko[1].add(4);
verkko[2].add(4);
verkko[2].add(5);
verkko[3].add(4);
verkko[4].add(5);
\end{code}

Vieruslistaesitys on monessa tilanteessa hyvä tapa tallentaa verkko,
koska haluamme usein selvittää,
mihin solmuihin pääsemme siirtymään tietystä solmusta kaaria pitkin.
Esimerkiksi seuraava koodi käy läpi solmut,
joihin voimme siirtyä solmusta $x$ kaarella:

\begin{code}
for (Integer s : verkko[x]) {
    // käsittele solmu s
}
\end{code}

Jos verkko on suuntaamaton, eli voimme kulkea kaaria molempiin suuntiin,
voimme tallentaa verkon vastaavalla tavalla,
kunhan tallennamme kunkin kaaren molempiin suuntiin.
Jos taas verkko on painotettu, voimme tallentaa jokaisesta
kaaresta sekä kohdesolmun että painon.

\subsection{Kaarilistaesitys}

Kaarilistaesityksessä luomme listan,
jossa on kaikki verkon kaaret.
Javassa voimme luoda listan

\begin{code}
ArrayList<Kaari> kaaret = new ArrayList<>();
\end{code}

jossa on seuraavanlaisia kaaria:

\begin{code}
public class Kaari {
    public int alku, loppu;

    public Kaari(int alku, int loppu) {
        this.alku = alku;
        this.loppu = loppu;
    }
}
\end{code}

Seuraava koodi luo esimerkkiverkkoamme vastaavan kaarilistan:

\begin{code}
kaaret.add(new Kaari(1,2));
kaaret.add(new Kaari(1,3));
kaaret.add(new Kaari(1,4));
kaaret.add(new Kaari(2,4));
kaaret.add(new Kaari(2,5));
kaaret.add(new Kaari(3,4));
kaaret.add(new Kaari(4,5));
\end{code}

Kaarilista on hyvä esitystapa algoritmeissa,
joissa meidän täytyy pystyä käymään helposti läpi
kaikki verkon kaaret eikä meillä ole tarvetta
selvittää tietystä solmusta lähteviä kaaria.

\subsection{Vierusmatriisiesitys}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\small
\begin{scope}
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- (2);
\path[draw,thick,->] (1) -- (3);
\path[draw,thick,->] (1) -- (4);
\path[draw,thick,->] (3) -- (4);
\path[draw,thick,->] (2) -- (4);
\path[draw,thick,->] (2) -- (5);
\path[draw,thick,->] (4) -- (5);
\end{scope}
\begin{scope}[xshift=9cm,yshift=-0.5cm]
\draw (0,0) grid (5,5);
\foreach \x in {1,...,5} \node at (-0.5,0.5-\x+5) {\x};
\foreach \x in {1,...,5} \node at (-0.5+\x,5.5) {\x};
\foreach \x/\v in {1/0,2/1,3/1,4/1,5/0} \node at (-0.5+\x,4.5) {\v};
\foreach \x/\v in {1/0,2/0,3/0,4/1,5/1} \node at (-0.5+\x,3.5) {\v};
\foreach \x/\v in {1/0,2/0,3/0,4/1,5/0} \node at (-0.5+\x,2.5) {\v};
\foreach \x/\v in {1/0,2/0,3/0,4/0,5/1} \node at (-0.5+\x,1.5) {\v};
\foreach \x/\v in {1/0,2/0,3/0,4/0,5/0} \node at (-0.5+\x,0.5) {\v};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkon vierusmatriisiesitys.}
\label{fig:vervim}
\end{figure}

Vierusmatriisi on kaksiulotteinen taulukko,
joka kertoo jokaisesta verkon kaaresta,
esiintyykö se verkossa.
Jos verkossa pääsee kaarella solmusta
$a$ solmuun $b$,
niin matriisin rivin $a$ sarakkeessa $b$
on sitä vastaava merkintä.
Kuvassa \ref{fig:vervim} on esimerkki
verkon vierusmatriisiesityksestä,
Jokaisessa matriisin kohdassa on luku ''0'' tai ''1''
sen mukaan, onko verkossa kyseistä kaarta.

Javassa voimme määritellä vierusmatriisin seuraavasti:

\begin{code}
int[][] verkko = new int[n+1][n+1];
\end{code}

Tämän jälkeen merkitsemme, miten voimme kulkea
solmujen välillä kaaria pitkin:

\begin{code}
verkko[1][2] = 1;
verkko[1][3] = 1;
verkko[1][4] = 1;
verkko[2][4] = 1;
verkko[2][5] = 1;
verkko[3][4] = 1;
verkko[4][5] = 1;
\end{code}

Vierusmatriisin etuna on, että voimme tarkastaa helposti,
onko tietty kaari verkossa.
Esitystapa kuluttaa kuitenkin paljon muistia,
eikä sitä voi käyttää, jos verkon solmujen määrä on suuri.

\section{Verkon läpikäynti}

Tutustumme seuraavaksi kahteen keskeiseen verkkoalgoritmiin,
jotka käyvät läpi verkossa olevia solmuja ja kaaria.
Ensin käsittelemme syvyyshakua, joka on yleiskäyttöinen algoritmi
verkon läpikäyntiin, ja sen jälkeen leveyshakua,
jonka avulla voimme löytää lyhimpiä polkuja verkossa.

\subsection{Syvyyshaku}

Syvyyshaku on verkkojen käsittelyn yleistyökalu,
jonka avulla voimme selvittää monia asioita verkon rakenteesta.
Kun alamme tutkia verkkoa syvyyshaulla,
meidän tulee päättää ensin, mistä solmusta haku lähtee liikkeelle.
Etenemme vuorollaan kaikkiin solmuihin, jotka ovat saavutettavissa
lähtösolmusta kulkemalla kaaria pitkin.

Syvyyshaku pitää yllä jokaisesta verkon solmusta tietoa,
onko se vielä vieraillut solmussa.
Kun haku saapuu solmuun, jossa se ei ole vieraillut aiemmin,
se merkitsee solmun vierailluksi ja alkaa käydä
solmusta lähteviä kaaria.
Jokaisen kaaren kohdalla haku etenee verkon niihin osiin,
joihin pääsee kaaren kautta.
Lopulta kun haku on käynyt läpi kaikki kaaret,
se perääntyy taaksepäin samaa reittiä kuin tuli solmuun.

Kuvassa \ref{fig:syvhak} on esimerkki syvyyshaun toiminnasta.
Jokaisessa vaiheessa harmaat solmut ovat solmuja,
joissa haku on jo vieraillut.
Tässä esimerkissä lähdemme liikkeelle solmusta 1,
josta pääsee kaarella solmuihin 2 ja 3.
Etenemme ensin solmuun 2, josta pääsemme edelleen
solmuihin 4 ja 5.
Koska emme pysty enää etenemään solmusta 5
uusiin solmuihin, peräännymme takaisin
kulkemaamme reittiä solmuun 1.
Tämän jälkeen käymme vielä solmussa 3,
josta ei pääse muihin solmuihin.
Nyt olemme käyneet läpi kaikki solmut,
joihin pääsee solmusta 1.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (0,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-1) {$5$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (1) -- (3);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{white}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (5);
\end{scope}
\begin{scope}[yshift=-5cm]
\verkko{5}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (5);
\path[draw=red,thick,->,line width=2pt] (5) -- (2);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\path[draw=red,thick,->,line width=2pt] (4) -- (5);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[yshift=-10cm]
\verkko{9}{lightgray}{lightgray}{white}{lightgray}{lightgray}
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki syvyyshaun toiminnasta.}
\label{fig:syvhak}
\end{figure}

Syvyyshaku on mukavaa toteuttaa rekursiivisesti seuraavaan tapaan:

\begin{code}
function haku(solmu)
    if vierailtu[solmu]
        return
    vierailtu[solmu] = true
    for naapuri in verkko[solmu]
        haku(naapuri)
\end{code}

Haku käynnistyy, kun kutsumme funktiota
\texttt{haku} parametrina haun lähtö\-solmu.
Jokaisessa kutsussa funktio tarkistaa ensin,
olemmeko jo käyneet parametrina annetussa solmussa,
ja päättyy heti tässä tilanteessa.
Muuten funktio merkitsee, että olemme nyt käyneet solmussa
ja etenee rekursiivisesti kaikkiin sen naapureihin.
Haku vie aikaa $O(n+m)$, koska käsittelemme jokaisen
solmun ja kaaren enintään kerran.

Mihin voisimme sitten käyttää syvyyshakua?
Seuraavassa on joitakin esimerkkejä syvyyshaun käyttökohteista:

\subsubsection{Polun etsiminen}

Syvyyshaun avulla voimme etsiä verkosta polun solmusta
$a$ solmuun $b$, jos tällainen polku on olemassa.
Tämä tapahtuu aloittamalla haku solmusta $a$
ja pysähtymällä, kun vastaan tulee solmu $b$.
Jos polkuja on useita, syvyyshaku löytää jonkin niistä
riippuen solmujen käsittelyjärjestyksestä.

\subsubsection{Yhtenäisyys ja komponentit}

Suuntaamaton verkko on yhtenäinen, 
jos kaikki solmut ovat yhteydessä toisiinsa.
Voimmekin tarkastaa verkon yhtenäisyyden aloittamalla
syvyyshaun jostakin solmusta ja tutkimalla,
saavuttaako haku kaikki verkon solmut.
Lisäksi voimme löytää verkon yhtenäiset komponentit
käymällä läpi solmut ja aloittamalla syvyyshaun aina,
kun vastaan tulee uusi solmu.
Jokainen syvyyshaku muodostaa yhden komponentin.

\subsubsection{Syklin etsiminen}

Jos suuntaamaton verkko sisältää syklin,
huomaamme tämän syvyyshaun aikana siitä,
että tulemme tulemme toista kautta johonkin solmuun,
jossa olemme käyneet jo aiemmin.
Niinpä löydämme syvyyshaun avulla jonkin verkossa olevan
syklin, jos sellainen on olemassa.

\subsection{Leveyshaku}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\scriptsize
\newcommand\verkko[6]{
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (2,0) {$2$};
\node[draw, circle, fill=#4] (3) at (0,-2) {$3$};
\node[draw, circle, fill=#5] (4) at (2,-2) {$4$};
\node[draw, circle, fill=#6] (5) at (4,-1) {$5$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (1) -- (3);
\node at (2,-3) {vaihe #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}{white}
\end{scope}
\begin{scope}[xshift=6cm]
\verkko{2}{lightgray}{lightgray}{white}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=12cm]
\verkko{3}{lightgray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=18cm]
\verkko{4}{lightgray}{lightgray}{lightgray}{white}{white}
\path[draw=red,thick,->,line width=2pt] (2) -- (1);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=0cm]
\verkko{5}{lightgray}{lightgray}{lightgray}{lightgray}{white}
\path[draw=red,thick,->,line width=2pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=6cm]
\verkko{6}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (2) -- (5);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=12cm]
\verkko{7}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (3) -- (1);
\end{scope}
\begin{scope}[yshift=-5cm,xshift=18cm]
\verkko{8}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (4) -- (2);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=0cm]
\verkko{9}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (4) -- (5);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=6cm]
\verkko{10}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (2);
\end{scope}
\begin{scope}[yshift=-10cm,xshift=12cm]
\verkko{11}{lightgray}{lightgray}{lightgray}{lightgray}{lightgray}
\path[draw=red,thick,->,line width=2pt] (5) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki leveyshaun toiminnasta.}
\label{fig:levhak}
\end{figure}

Leveyshaku käy syvyyshaun tavoin läpi kaikki verkon solmut,
joihin pääsee kulkemaan kaaria pitkin annetusta lähtösolmusta.
Erona on kuitenkin, missä järjestyksessä solmut käydään läpi.
Leveyshaku käy solmuja läpi \emph{kerroksittain} niin,
että se käsittelee solmut siinä järjestyksessä kuin ne
ovat tulleet ensimmäistä kertaa vastaan haun aikana.

Vaikka voisimme käyttää leveyshakua yleisenä
algoritmina verkon läpi\-käyntiin syvyyshaun tavoin,
käytämme sitä tavallisesti silloin,
kun olemme kiinnostuneita verkon \emph{lyhimmistä poluista}.
Leveyshaun avulla pystymme nimittäin määrit\-tämään
lyhimmän polun pituuden eli \emph{etäisyyden} lähtösolmusta
kuhunkin haun aikana kohtaamaamme solmuun.
Tässä oletamme, että polun pituus tarkoittaa sen
kaarten määrää eli lyhin polku on mahdollisimman vähän
kaaria sisältävä polku.

Kuvassa \ref{fig:levhak} on esimerkki leveyshaun toiminnasta,
kun aloitamme haun solmusta 1 lähtien.
Käsittelemme ensin solmun 1, josta pääsemme uusiin solmuihin 2 ja 3.
Tämä tarkoittaa, että lyhimmät polut solmuihin 2 ja 3
ovat $1 \rightarrow 2$ ja $1 \rightarrow 3$ eli etäisyys näihin solmuihin on 1.
Sitten käsittelemme solmun 2, josta pääsemme uusiin solmuihin 4 ja 5.
Tämä tarkoittaa, että lyhimmät polut solmuihin 4 ja 5
ovat $1 \rightarrow 2 \rightarrow 4$ ja $1 \rightarrow 2 \rightarrow 5$
eli etäisyys näihin solmuihin on 2.
Lopuksi käsittelemme vielä solmut 3, 4 ja 5,
joista emme kuitenkaan pääse enää uusiin solmuihin.

Tavallinen tapa toteuttaa leveyshaku on käyttää \emph{jonoa},
jossa on käsittelyä odottavia solmuja.
Jonon ansiosta pystymme käymään läpi solmut siinä
jär\-jestyksessä kuin olemme löytäneet ne leveyshaun aikana.
Oletamme, että jonossa on metodi \texttt{add},
joka lisää alkion jonon loppuun, sekä metodi \texttt{poll},
joka hakee ja poistaa jonon ensimmäisen alkion.
Seuraava koodi suorittaa leveyshaun lähtösolmusta \texttt{alku} alkaen:

\begin{code}
jono.add(alku)
vierailtu[alku] = true
etaisyys[alku] = 0
while jono.size() > 0
    solmu = jono.poll()
    for naapuri in verkko[solmu]
        if vierailtu[naapuri]
            continue
        jono.add(naapuri)
        vierailtu[naapuri] = true
        etaisyys[naapuri] = etaisyys[solmu]+1
\end{code}

Lisäämme ensin jonoon lähtösolmun ja merkitsemme,
että olemme vierailleet siinä ja että etäisyys siihen on $0$.
Tämän jälkeen alamme käsitellä solmuja siinä järjestyksessä kuin ne ovat jonossa.
Käsittelemme solmun käymällä läpi sen naapurit.
Jos emme ole aiemmin käyneet naapurissa, lisäämme sen jonoon
ja päivitämme taulukoita.
Haku vie aikaa $O(n+m)$, koska käsittelemme jokaisen
solmun ja kaaren enintään kerran.

\subsection{Esimerkki: Labyrintti}

Olemme labyrintissa ja haluamme päästä ruudusta $A$ ruutuun $B$.
Joka askeleella voimme siirtyä yhden ruudun verran ylöspäin, alaspäin,
vasemmalle tai oikealle.
Pystymmekö pääsemään ruudusta $A$ ruutuun $B$, ja jos pystymme, niin
mikä on lyhin mahdollinen reitti?
Esimerkiksi kuvassa \ref{fig:labrei}(a) lyhin reitti
ruudusta $A$ ruutuun $B$ muodostuu 9 askeleesta.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6]
\begin{scope}
\draw[fill=gray] (1,1) rectangle (2,2);
\draw[fill=gray] (1,3) rectangle (2,4);
\draw[fill=gray] (1,4) rectangle (2,5);
\draw[fill=gray] (3,1) rectangle (4,2);
\draw[fill=gray] (3,2) rectangle (4,3);
\draw[fill=gray] (3,3) rectangle (4,4);
\draw (0,0) grid (5,5);
\draw[->,thick,red,line width=2pt] (0.5,4.25) -- (0.5,2.5) -- (2.5,2.5) -- (2.5,0.5) -- (4.5,0.5) -- (4.5,1.25);
\node at (0.5,4.5) {$A$};
\node at (4.5,1.5) {$B$};
\node at (2.5,-1) {(a)};
\end{scope}
\begin{scope}[xshift=9cm,yshift=0.5cm]
\foreach \x in {0,1,2,3} \path[draw,thick,-] (0,\x) -- (0,\x+1);
\foreach \x in {0,1,2,3} \path[draw,thick,-] (2,\x) -- (2,\x+1);
\foreach \x in {0,1,2,3} \path[draw,thick,-] (4,\x) -- (4,\x+1);
\foreach \x in {0,1,2,3} \path[draw,thick,-] (\x,0) -- (\x+1,0);
\foreach \x in {0,1} \path[draw,thick,-] (\x,2) -- (\x+1,2);
\foreach \x in {2,3} \path[draw,thick,-] (\x,4) -- (\x+1,4);
\foreach \x in {0,1,2,3,4} \node[draw, circle, fill=white] at (0,\x) {};
\foreach \x in {0,2} \node[draw, circle, fill=white] at (1,\x) {};
\foreach \x in {0,1,2,3,4} \node[draw, circle, fill=white] at (2,\x) {};
\foreach \x in {0,4} \node[draw, circle, fill=white] at (3,\x) {};
\foreach \x in {0,1,2,3,4} \node[draw, circle, fill=white] at (4,\x) {};
\node at (2,-1.5) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a) Lyhin reitti labyrintissa ruudusta $A$ ruutuun $B$. (b)
Labyrintin esittäminen verkkona.}
\label{fig:labrei}
\end{figure}

Voimme esittää ongelman verkkona niin,
että jokainen labyrintin ruutu on yksi verkon solmuista
ja kahden solmun välillä on kaari,
jos vastaavat ruudut ovat vierekkäin labyrintissa.
Kuva \ref{fig:labrei}(b) näyttää esimerkkilabyrinttimme verkkona.
Tätä esitystapaa käyttäen ruudusta $A$ on reitti ruutuun $B$ tarkalleen silloin,
kun vastaavat verkon solmut kuuluvat samaan yhtenäiseen komponenttiin.
Voimme siis tarkastaa syvyyshaulla, onko ruudusta $A$ reittiä ruutuun $B$.
Jos haluamme löytää \emph{lyhimmän} reitin ruudusta $A$ ruutuun $B$,
voimme puolestaan käyttää leveyshakua, joka lähtee liikkeelle ruudusta $A$.

Huomaa, että meidän ei tarvitse erikseen muuttaa labyrinttia
verkoksi, vaan voimme toteuttaa haut \emph{implisiittiseen} verkkoon.
Tämä tarkoittaa, että teemme haun labyrinttiin sen omassa
esitysmuodossa. Käytännössä labyrintti on kätevää tallentaa kaksiulotteisena
taulukkona, joka kertoo, mitkä ruudut ovat seinäruutuja.
Tällöin voimme toteuttaa esimerkiksi syvyyshaun seuraavan tyylisesti:

\begin{code}
function haku(y,x)
    if y < 0 or x < 0 or y >= n or x >= n
        return
    if seina[y][x] or vierailtu[y][x]
        return
    vierailtu[y][x] = true
    haku(y+1,x)
    haku(y-1,x)
    haku(y,x+1)
    haku(y,x-1)
\end{code}