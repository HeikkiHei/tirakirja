\chapter{Algoritmien suunnittelu}

Kuinka voi suunnitella hyvän algoritmin?
On selvää, ettei tähän kysymykseen ole helppoa vastausta.
Yhtä hyvin voisi kysyä, kuinka voi kirjoittaa hyvän kirjan
tai säveltää hyvää musiikkia.

Tällä kurssilla usein esiintyvä tavoitteemme on
saada aikaan tehokas algoritmi, joka toimisi ajassa $O(n)$ tai $O(n \log n)$.
Kun tämä tavoite on tiedossa, voimme ottaa sen algoritmin
suunnittelun lähtökohdaksi ja rajata sen avulla mahdollisia
lähestymistapoja, joita voimme käyttää.

\section{Tehokkaat algoritmit}

Millainen on algoritmi, joka vie aikaa $O(n)$ tai $O(n \log n)$?
Vaadimme algoritmilta,
että kun sille annetaan syötteenä $n$ alkiota,
se saa käyttää jokaisen alkion käsittelyyn
vain pienen määrän aikaa.
Tämä tarkoittaa käytännössä, että algoritmissa saa
esiintyä seuraavan kaltaisia silmukoita:

\begin{code}
for (int i = 0; i < n; i++) {
    // tee jotain nopeaa
}
\end{code}

Tässä ''jotain nopeaa'' tarkoittaa koodia, joka vie aikaa
$O(1)$ tai $O(\log n)$.
Lisäksi koska järjestäminen vie aikaa $O(n \log n)$,
algoritmi voi tarvittaessa järjestää aineistoa.
Kovin paljon muuta tehokas algoritmi ei sitten voikaan tehdä.
Tämä rajoittaa paljon, mitä aineksia voimme laittaa algoritmiin,
mutta voimme ajatella asiaa myös myönteisesti:
vaatimus tehokkuudesta rajaa pois suuren määrän lähestymistapoja,
eli meidän on helpompaa löytää hyvä algoritmi,
kun vaihtoehtojen määrä on pienempi.

Algoritmien suunnittelussa keskeisiä ovat \emph{havainnot}:
haluamme saada käsityksen,
mitä ominaisuuksia ratkaistavaan ongelmaan liittyy,
jotta voimme käyttää niitä algoritmissa.
Voimme tehdä havaintoja tutkimalla ongelman pieniä tapauksia
ja etsimällä riippuvuuksia ja säännöllisyyksiä.
Jos käy hyvin, huomaamme asioita, jotka pätevät kaikissa ongelman
tapauksissa, ja voimme hyödyntää niitä koko tehtävän ratkaisemisessa.

Usein matka kohti tehokasta algoritmia etenee pienin askelin.
Esimerkiksi voimme ensin keksiä algoritmin, joka toimii ajassa $O(2^n)$,
parantaa sitten aikaan $O(n^2)$ ja lopuksi aikaan $O(n \log n)$.
Tässä tapauksessa molemmat askeleet ovat merkittäviä:
ensimmäinen askel muuttaa \emph{eksponentiaalisen} aikavaativuuden
\emph{polynomiseksi} ja toinen askel parantaa vielä aikavaativuutta niin,
että tuloksena on tehokas algoritmi.

\section{Esimerkkejä}

Seuraavaksi käymme läpi muutamia esimerkkejä,
joissa saamme aikaan tehokkaan algoritmin tehtävään
tekemällä havaintoja ja hyödyntämällä niitä algoritmin suunnittelussa.

\subsection{Kierrokset}

Annettuna on taulukko, joka sisältää luvut $1,2,\dots,n$
jossakin järjestyksessä.
Haluamme kerätä taulukosta luvut pienimmästä suurimpaan.
Joka kierroksella käymme läpi taulukon vasemmalta
oikealle ja keräämme mahdollisimman monta seuraavaa lukua.
Montako kierrosta tarvitsemme yhteensä?

Esimerkiksi jos taulukon sisältönä on $[4,3,1,5,2]$,
tarvitsemme kolme kierrosta.
Ensimmäisellä kierroksella keräämme luvut $1$ ja $2$,
toisella luvun $3$ ja kolmannella luvut $4$ ja $5$.

Suoraviivainen tapa ratkaista tehtävä on simuloida
kuvattua prosessia.
Seuraavassa koodissa muuttuja \texttt{luku} ilmaisee,
minkä luvun haluamme kerätä seuraavaksi,
ja muuttuja \texttt{laskuri} pitää kirjaa siitä, montako kertaa
olemme käyneet taulukon läpi.

\begin{code}
int luku = 1;
int laskuri = 0;
while (luku <= n) {
    laskuri++;
    for (int i = 0; i < n; i++) {
        if (taulu[i] == luku) luku++;
    }
}
System.out.println(laskuri);
\end{code}

Kuinka nopea tämä algoritmi on?
Tämä riippuu siitä, montako kierrosta teemme.
Pahin tapaus on, että taulukko on käänteisessä järjestyksessä,
jolloin teemme $n$ kierrosta.
Niinpä algoritmi vie aikaa $O(n^2)$.

Jotta voimme ratkaista tehtävän tehokkaasti,
meidän täytyy löytää nopeammin, missä on seuraava luku,
jonka haluamme kerätä.
Kätevä ratkaisu tähän on luoda aputaulukko,
joka kertoo jokaisen luvun kohdan:

\begin{code}
int[] kohta = new int[n+1];
for (int i = 0; i < n; i++) {
    kohta[taulu[i]] = i;
}
\end{code}

Nyt olemme jo lähellä tehokasta algoritmia, mutta
tarvitsemme vielä yhden havainnon.
Milloin aloitamme uuden kierroksen taulukossa?
Näin käy tarkalleen silloin, kun seuraavaksi kerättävä
luku on \emph{aiemmin} taulukossa kuin viimeksi
keräämämme luku.
Niinpä voimme laskea kierrosten määrän näin:

\begin{code}
int laskuri = 1;
for (int i = 2; i <= n; i++) {
    if (kohta[i-1] < kohta[i]) {
        laskuri++;
    }
}
\end{code}

Tässä algoritmissa on kaksi silmukkaa, jotka molemmat
vievät aikaa $O(n)$, joten algoritmin kokonaisaikavaativuus on $O(n)$.

\subsection{Kolikot}

Meillä on $n$ kolikkoa, jonka jokaisen arvo on positiivinen kokonaisluku,
ja haluamme selvittää pienimmän summan, jota \emph{ei} voi muodostaa
valitsemalla jonkin osajoukon kolikoista.
Esimerkiksi jos kolikot ovat $[1,2,2,9]$, voimme muodostaa summat
$1$, $2$, $1+2=3$, $2+2=4$ ja $1+2+2=5$,
mutta emme voi muodostaa summaa $6$.

Tässä tehtävässä vaikeutena on, että mahdollisten osajoukkojen
määrä on suuri: voimme muodostaa $n$ kolikosta $2^n$ osajoukkoa.
Niinpä ei ole mitenkään realistinen ratkaisu,
että alkaisimme käydä läpi osajoukkoja yksitellen,
vaan tarvitsemme jotain selvästi parempaa.

Tehtävän ratkaisua helpottaa, kun lähdemme liikkeelle pienistä summista.
Haluamme muodostaa ensin summan $1$, ja tähän tarvitsemme välttämättä
kolikon, jonka arvo on $1$.
Sitten haluamme muodostaa summan $2$, mihin tarvitsemme joko
toisen kolikon $1$ tai kolikon $2$, ja sen jälkeen summan $3$,
joka voi muodostua kolikoista $1+1+1$, $1+2$ tai $3$.
Voisimme jatkaa eteenpäin, mutta vaihtoehtoja alkaa tulla
paljon ja meidän on vaikeaa hallita niitä.

Meidän kannattaakin nyt alkaa miettiä ongelmaa yleisemmin.
Oletetaan, että meillä on joukko kolikoita,
joista voimme muodostaa kaikki summat $1,2,\dots,s$.
Voimmeko ottaa mukaan vielä uuden kolikon niin,
että saamme muodostettua myös summan $s+1$?
Tämä on mahdollista tarkalleen silloin, kun saatavilla on kolikko,
jonka arvo on $s+1$ tai \emph{pienempi}.
Jos uuden kolikon arvo on $u$, pystymme muodostamaan tämän jälkeen
kaikki summat $1,2,\dots,s+u$.
Lisäksi jos meillä on monia vaihtoehtoja valita uusi kolikko,
voimme valita minkä tahansa niistä.
Erityisesti voimme päättää, että valitsemme aina
\emph{pienimmän} mahdollisen kolikon.

Nyt meillä on koossa kaikki tarvittavat ainekset
tehokasta algoritmia varten.
Aloitamme tyhjästä joukosta ja lisäämme siihen kolikoita
pienimmästä suurimpaan niin kauan kuin mahdollista.
Lopuksi vastaus tehtävään on yhtä suurempi kuin kolikoiden
summa.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
Arrays.sort(kolikot);
long summa = 0;
for (int i = 0; i < n; i++) {
    if (kolikot[i] <= summa+1) {
        summa += kolikot[i];
    } else {
        break;
    }
}
System.out.println(summa+1);
\end{code}

Algoritmin aikavaativuus on $O(n \log n)$, koska se
järjestää ensin taulukon ja käy sitten läpi taulukon alkiot.

\subsection{Alitaulukot}

Annettuna on taulukko, jossa on $n$ kokonaislukua,
ja haluamme laskea, monellako tavalla voimme valita
taulukosta yhtenäisen alitaulukon, jossa lukujen summa on $0$.
Jotta tehtävä olisi kiinnostava, taulukossa voi olla
mitä tahansa kokonaislukuja, myös negatiivisia.

Tarkastellaan esimerkkinä taulukkoa $[1,-1,2,-1,3]$.
Tässä tapauksessa meillä on kaksi mahdollista tapaa
valita yhtenäinen alitaulukko, jossa lukujen summa on $0$:
$[1,-1]$ ja $[-1,2,-1]$.

Voimme ratkaista tehtävän helposti käymällä läpi
kaikki mahdolliset alitaulukot kahdella silmukalla:

\begin{code}
int laskuri = 0;
for (int i = 0; i < n; i++) {
    int summa = 0;
    for (int j = i; j < n; j++) {
        summa += taulu[j];
        if (summa == 0) laskuri++;
    }
}
System.out.println(laskuri);
\end{code}

Tämä ratkaisu ei ole kuitenkaan tyydyttävä,
koska se vie aikaa $O(n^2)$.

Ensimmäinen hyödyllinen havainto on,
että taulukossa voi olla \emph{paljon} alitaulukoita,
joiden summa on $0$.
Itse asiassa jos taulukossa on vain lukua $0$,
niin \emph{jokaisen} alitaulukon summa on $0$.
Tämä tarkoittaa, että haluttuja alitaulukoita voi olla
$O(n^2)$ kappaletta ja jos laskemme niitä yksitellen,
algoritmimme on auttamatta liian hidas.
Meidän täytyy siis keksiä keino, miten voimme laskea
alitaulukoita ryhmissä.

Merkitään $s(k)$ taulukon \emph{alkuosan} summaa
eli taulukon lukujen summaa taulukon alusta kohtaan $k$ asti
ja lisäksi $s(-1)=0$.
Nyt jos meillä on alitaulukko kohdasta $a$ kohtaan $b$,
voimme laskea sen summan kaavalla $s(b)-s(a-1)$.
Jos haluamme, että tämä summa on $0$, täytyy päteä
$s(a-1)=s(b)$.
Tämän havainnon ansiosta voimme muuttaa tehtävän
mukavampaan muotoon: meidän täytyy vain laskea,
monellako tavalla voimme valita kaksi taulukon alkuosaa
niin, että niiden summat ovat samat.

Tarkastellaan asiaa esimerkkitaulukossamme $[1,-1,2,-1,3]$.
Laskemme ensin alkuosien summat, jotka ovat $[0,1,0,2,1,4]$
(mukaan lukien tyhjä alkuosa ensimmäisenä).
Alitaulukon $[1,-1]$ tapauksessa $s(-1)=s(1)=0$ ja
alitaulukon $[-1,2,-1]$ tapauksessa $s(0)=s(3)$.
Nämä ovat ainoat tavat valita kaksi alkuosan summaa niin,
että molemmat summat ovat samat.

Jotta saamme aikaan tehokkaan algoritmin, tarvitsemme vielä
yhden aineksen: järjestämisen.
Kun olemme laskeneet kaikki alkuosien summat,
voimme järjestää ne, minkä jälkeen yhtä suuret summat
ovat vierekkäin. Tämän jälkeen voimme laskea tehokkaasti
jokaisesta summasta, monellako tavalla voimme valita
kaksi tällaista alkuosaa.

Seuraava koodi rakentaa taulukon, jossa on kaikki alkuosien summat:

\begin{code}
int[] summat = new int[n+1];
for (int i = 0; i < n; i++) {
    summat[i+1] = summat[i]+taulu[i];
}
\end{code}

Huomaa, että taulukko on yhden suurempi kuin alkuperäinen taulukko
ja sen ensimmäinen alkio on aina $0$: tyhjän alkuosan summa.

Tämän jälkeen voimme käydä summat läpi seuraavasti:

\begin{code}
Arrays.sort(summat);
int toisto = 0;
int laskuri = 0;
for (int i = 0; i < n+1; i++) {
    if (i == 0 || summat[i-1] != summat[i]) {
        toisto = 0;
    } else {
        toisto++;
    }
    laskuri += toisto;
}
System.out.println(laskuri);
\end{code}

Tässä muuttuja \texttt{toisto} pitää kirjaa, montako kertaa
taulukon nykyinen luku on esiintynyt aiemmin.
Tämä kertoo, monellako tavalla voimme valita parin,
jossa on nykyinen summa ja aiempi sama summa.
Tuloksena oleva algoritmi vie aikaa $O(n \log n)$,
koska sen työläin vaihe on taulukon järjestäminen.
