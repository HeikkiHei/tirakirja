\chapter{Algoritmien suunnittelu}

Kuinka voi suunnitella hyvän algoritmin?
On selvää, ettei tähän kysymykseen ole helppoa vastausta.
Yhtä hyvin voisi kysyä, kuinka voi kirjoittaa hyvän romaanin
tai säveltää hyvää musiikkia.

Tällä kurssilla usein esiintyvä tavoitteemme on
saada aikaan tehokas algoritmi, joka toimisi ajassa $O(n)$ tai $O(n \log n)$.
Kun tämä tavoite on tiedossa, voimme ottaa sen algoritmin
suunnittelun lähtökohdaksi ja rajata sen avulla mahdollisia
lähestymistapoja, joita voimme käyttää.

\section{Tehokkaat algoritmit}

Millainen on algoritmi, joka vie aikaa $O(n)$ tai $O(n \log n)$?
Vaadimme algoritmilta,
että kun sille annetaan syötteenä $n$ alkiota,
se saa käyttää jokaisen alkion käsittelyyn
vain pienen määrän aikaa.
Tämä tarkoittaa käytännössä, että algoritmissa saa
esiintyä seuraavan kaltaisia silmukoita:

\begin{code}
for (int i = 0; i < n; i++) {
    // tee jotain nopeaa
}
\end{code}

Tässä ''jotain nopeaa'' tarkoittaa koodia, joka vie aikaa
$O(1)$ tai $O(\log n)$.
Lisäksi koska järjestäminen vie aikaa $O(n \log n)$,
algoritmi voi tarvittaessa järjestää aineistoa.
Kovin paljon muuta tehokas algoritmi ei sitten voikaan tehdä.
Tämä rajoittaa paljon, mitä aineksia voimme laittaa algoritmiin,
mutta voimme ajatella asiaa myös myönteisesti:
vaatimus tehokkuudesta rajaa pois suuren määrän lähestymistapoja,
eli meidän on helpompaa löytää hyvä algoritmi,
kun vaihtoehtojen määrä on pienempi.

Algoritmien suunnittelussa keskeisiä ovat \emph{havainnot}:
haluamme saada käsityksen,
mitä ominaisuuksia ratkaistavaan ongelmaan liittyy,
jotta voimme käyttää niitä algoritmissa.
Voimme tehdä havaintoja tutkimalla ongelman pieniä tapauksia
ja etsimällä riippuvuuksia ja säännöllisyyksiä.
Jos käy hyvin, huomaamme asioita, jotka pätevät kaikissa ongelman
tapauksissa, ja voimme hyödyntää niitä koko tehtävän ratkaisemisessa.

Usein matka kohti tehokasta algoritmia etenee pienin askelin.
Esimerkiksi voimme ensin keksiä algoritmin, joka toimii ajassa $O(2^n)$,
parantaa sitten aikaan $O(n^2)$ ja lopuksi aikaan $O(n \log n)$.
Tässä tapauksessa molemmat askeleet ovat merkittäviä:
ensimmäinen askel muuttaa \emph{eksponentiaalisen} aikavaativuuden
\emph{polynomiseksi} ja toinen askel parantaa vielä aikavaativuutta niin,
että tuloksena on tehokas algoritmi.

\section{Esimerkkejä}

Seuraavaksi käymme läpi joukon esimerkkitehtäviä,
joissa haluamme saada aikaan tehokkaan algoritmin tehtävän ratkaisemiseen,
ja saavutamme tavoitteen tekemällä havaintoja ratkaistavasta ongelmasta.

\subsection{Kolikot}

Meillä on $n$ kolikkoa, joiden arvot ovat $x_0,x_1,\dots,x_{n-1}$,
ja haluamme selvittää pienimmän summan, jota \emph{ei} voi muodostaa kolikoista.
Jokaisen kolikon arvo on positiivinen kokonaisluku.
Esimerkiksi jos kolikot ovat $[1,2,2,9]$, voimme muodostaa summat
$1$, $2$, $1+2=3$, $2+2=4$ ja $1+2+2=5$,
mutta emme voi muodostaa summaa $6$.

\subsubsection{Havainto 1}

Tehtävän vastaus on aina muotoa $s+1$, missä $s$ on jokin kolikoista
saatava summa. Esimerkissä $s=1+2+2=5$.

Voimme siis ratkaista tehtävän
muodostamalla kaikki mahdolliset $n$ kolikon summat
ja etsimällä pienimmän puuttuvan summan.
Algoritmi on kuitenkin hidas, koska $n$ kolikosta voi
muodostaa summan $2^n$ tavalla ja joudumme käymään läpi kaikki tavat.

\subsubsection{Havainto 2}

Jos haluamme pystyä muodostamaan summan $1$,
meillä on oltava kolikko, jonka arvo on $1$.

Tämä havainto merkitsee sitä, että voimme ratkaista tehtävän
hyvin helposti, jos minkään kolikon arvo ei ole $1$,
koska vastaus on silloin suoraan $0$.
Entä jos jonkin kolikon arvo on $1$?

\subsubsection{Havainto 3}

Oletetaan, että meillä on joukko kolikoita,
joista voimme muodostaa kaikki summat $1,2,\dots,s$.
Voimmeko ottaa mukaan vielä uuden kolikon niin,
että voimme muodostaa myös summan $s+1$?

Tämä on mahdollista tarkalleen silloin, kun saatavilla on kolikko,
jonka arvo on $s+1$ tai \emph{pienempi}.
Jos tällaisen kolikon arvo on $u$, pystymme muodostamaan tämän jälkeen
kaikki summat $1,2,\dots,s+u$.

\subsubsection{Havainto 4}

Jos on olemassa useita vaihtoehtoja valita kolikko,
jonka arvo on $s+1$ tai pienempi,
voimme valita minkä tahansa vaihtoehdon.
Erityisesti voimme päättää, että valitsemme aina
\emph{pienimmän} kolikon.

Nyt meillä on koossa kaikki tarvittavat ainekset
tehokasta algoritmia varten.
Aloitamme tyhjästä joukosta ja lisäämme siihen kolikoita
pienimmästä suurimpaan niin kauan kuin mahdollista.
Lopuksi vastaus tehtävään on yhtä suurempi kuin kolikoiden
summa.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
Arrays.sort(x);
long summa = 0;
for (int i = 0; i < n; i++) {
    if (x[i] <= summa+1) {
        summa += x[i];
    } else {
        break;
    }
}
long vastaus = summa+1;
\end{code}

Algoritmin aikavaativuus on $O(n \log n)$, koska se
järjestää ensin taulukon ja käy sitten läpi taulukon alkiot.

\subsection{Tornit}

Meillä on $n$ tornia, joiden korkeudet ovat $x_0,x_1,\dots,x_{n-1}$.
Jokaisella siirrolla voimme valita yhden torneista ja
kasvattaa tai vähentää sen korkeutta yhdellä.
Mikä on pienin määrä siirtoja, joiden jälkeen jokaisen
tornin korkeus on sama?
Esimerkiksi jos korkeudet ovat $[1,3,4,4]$,
paras ratkaisu on muuttaa jokaisen tornin korkeudeksi $3$,
mihin kuluu neljä siirtoa.

\subsubsection{Havainto 1}

Paras yhteinen korkeus ei voi olla
pienempi kuin matalimman tornin korkeus eikä
suurempi kuin korkeimman tornin korkeus.

Kun tornien korkeudet ovat välillä $a \dots b$,
saamme tästä ratkaisun, joka vie aikaa $O(n (b-a))$:
käymme läpi kaikki mahdolliset korkeudet ja valitsemme
parhaan ratkaisun.

\subsubsection{Havainto 2}

Paras yhteinen korkeus on jokin korkeuksista $x_0,x_1,\dots,x_{n-1}$.
Jos näin ei olisi, muuttaisimme jokaisen tornin korkeutta
johonkin suuntaan, mikä ei kuitenkaan ole koskaan oikeasti tarpeen.

Tämän havainnon avulla saamme aikaan ratkaisun,
joka vie aikaa $O(n^2)$: käymme läpi kaikki korkeudet
$x_0,x_1,\dots,x_{n-1}$ yhteiseksi korkeudeksi ja valitsemme parhaan ratkaisun.

\subsubsection{Havainto 3}

Paras yhteinen korkeus on \emph{mediaani} korkeuksista
$x_0,x_1,\dots,x_{n-1}$.
Tämä johtuu siitä, että jos yhteinen korkeus on pienempi tai suurempi kuin mediaani,
voimme vähentää siirtojen määrää valitsemalla yhteisen korkeuden,
joka on lähempänä mediaania.

Nyt pystymme ratkaisemaan tehtävän tehokkaasti ajassa $O(n \log n)$:

\begin{code}
Arrays.sort(x);
int mediaani = x[n/2];
for (int i = 0; i < n; i++) {
    siirrot += Math.abs(x[i]-mediaani);
}
System.out.println(siirrot);
\end{code}