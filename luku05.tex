\chapter{Algoritmien suunnittelu}

Kuinka voi suunnitella hyvän algoritmin?
On selvää, ettei tähän kysymykseen ole helppoa vastausta.
Yhtä hyvin voisi kysyä, kuinka voi kirjoittaa hyvän romaanin
tai säveltää hyvää musiikkia.

Tällä kurssilla usein esiintyvä tavoitteemme on
saada aikaan tehokas algoritmi, joka toimisi ajassa $O(n)$ tai $O(n \log n)$.
Kun tämä tavoite on tiedossa, voimme ottaa sen algoritmin
suunnittelun lähtökohdaksi ja rajata sen avulla mahdollisia
lähestymistapoja, joita voimme käyttää.

\section{Tehokkaat algoritmit}

Millainen on algoritmi, joka vie aikaa $O(n)$ tai $O(n \log n)$?
Vaadimme algoritmilta,
että kun sille annetaan syötteenä $n$ alkiota,
se saa käyttää jokaisen alkion käsittelyyn
vain pienen määrän aikaa.
Tämä tarkoittaa käytännössä, että algoritmissa saa
esiintyä seuraavan kaltaisia silmukoita:

\begin{code}
for (int i = 0; i < n; i++) {
    // tee jotain nopeaa
}
\end{code}

Tässä ''jotain nopeaa'' tarkoittaa koodia, joka vie aikaa
$O(1)$ tai $O(\log n)$.
Lisäksi koska järjestäminen vie aikaa $O(n \log n)$,
algoritmi voi tarvittaessa järjestää aineistoa.
Kovin paljon muuta tehokas algoritmi ei sitten voikaan tehdä.
Tämä rajoittaa paljon, mitä aineksia voimme laittaa algoritmiin,
mutta voimme ajatella asiaa myös myönteisesti:
vaatimus tehokkuudesta rajaa pois suuren määrän lähestymistapoja,
eli meidän on helpompaa löytää hyvä algoritmi,
kun vaihtoehtojen määrä on pienempi.

Algoritmien suunnittelussa keskeisiä ovat \emph{havainnot}:
haluamme saada käsityksen,
mitä ominaisuuksia ratkaistavaan ongelmaan liittyy,
jotta voimme käyttää niitä algoritmissa.
Voimme tehdä havaintoja tutkimalla ongelman pieniä tapauksia
ja etsimällä riippuvuuksia ja säännöllisyyksiä.
Jos käy hyvin, huomaamme asioita, jotka pätevät kaikissa ongelman
tapauksissa, ja voimme hyödyntää niitä koko tehtävän ratkaisemisessa.

Usein matka kohti tehokasta algoritmia etenee pienin askelin.
Esimerkiksi voimme ensin keksiä algoritmin, joka toimii ajassa $O(2^n)$,
parantaa sitten aikaan $O(n^2)$ ja lopuksi aikaan $O(n \log n)$.
Tässä tapauksessa molemmat askeleet ovat merkittäviä:
ensimmäinen askel muuttaa \emph{eksponentiaalisen} aikavaativuuden
\emph{polynomiseksi} ja toinen askel parantaa vielä aikavaativuutta niin,
että tuloksena on tehokas algoritmi.

\section{Esimerkkejä}

Seuraavaksi käymme läpi muutamia esimerkkejä,
joissa saamme aikaan tehokkaan algoritmin tehtävään
tekemällä havaintoja ja hyödyntämällä niitä algoritmin suunnittelussa.

\subsection{Kierrokset}

Annettuna on taulukko, joka sisältää luvut $1,2,\dots,n$
jossakin järjestyksessä.
Haluamme kerätä taulukosta luvut pienimmästä suurimpaan.
Joka kierroksella käymme läpi taulukon vasemmalta
oikealle ja keräämme mahdollisimman monta seuraavaa lukua.
Montako kierrosta tarvitsemme yhteensä?

Esimerkiksi jos taulukon sisältönä on $[4,3,1,5,2]$,
tarvitsemme kolme kierrosta.
Ensimmäisellä kierroksella keräämme luvut $1$ ja $2$,
toisella luvun $3$ ja kolmannella luvut $4$ ja $5$.

Suoraviivainen tapa ratkaista tehtävä on simuloida
kuvattua prosessia.
Seuraavassa koodissa muuttuja \texttt{luku} ilmaisee,
minkä luvun haluamme kerätä seuraavaksi,
ja muuttuja \texttt{laskuri} pitää kirjaa siitä, montako kertaa
olemme käyneet taulukon läpi.

\begin{code}
int luku = 1;
int laskuri = 0;
while (luku <= n) {
    laskuri++;
    for (int i = 0; i < n; i++) {
        if (taulu[i] == luku) luku++;
    }
}
System.out.println(laskuri);
\end{code}

Kuinka nopea tämä algoritmi on?
Tämä riippuu siitä, montako kierrosta teemme.
Pahin tapaus on, että taulukko on käänteisessä järjestyksessä,
jolloin teemme $n$ kierrosta.
Niinpä algoritmi vie aikaa $O(n^2)$.

Jotta voimme ratkaista tehtävän tehokkaasti,
meidän täytyy löytää nopeammin, missä on seuraava luku,
jonka haluamme kerätä.
Kätevä ratkaisu tähän on luoda aputaulukko,
joka kertoo jokaisen luvun kohdan:

\begin{code}
int[] kohta = new int[n+1];
for (int i = 0; i < n; i++) {
    kohta[taulu[i]] = i;
}
\end{code}

Nyt olemme jo lähellä tehokasta algoritmia, mutta
tarvitsemme vielä yhden havainnon.
Milloin aloitamme uuden kierroksen taulukossa?
Näin käy tarkalleen silloin, kun seuraavaksi kerättävä
luku on \emph{aiemmin} taulukossa kuin viimeksi
keräämämme luku.
Niinpä voimme laskea kierrosten määrän näin:

\begin{code}
int laskuri = 1;
for (int i = 2; i <= n; i++) {
    if (kohta[i-1] < kohta[i]) {
        laskuri++;
    }
}
\end{code}

Tässä algoritmissa on kaksi silmukkaa, jotka molemmat
vievät aikaa $O(n)$, joten algoritmin kokonaisaikavaativuus on $O(n)$.

\subsection{Kolikot}

Meillä on $n$ kolikkoa, jonka jokaisen arvo on positiivinen kokonaisluku,
ja haluamme selvittää pienimmän summan, jota \emph{ei} voi muodostaa
valitsemalla jonkin osajoukon kolikoista.
Esimerkiksi jos kolikot ovat $[1,2,2,9]$, voimme muodostaa summat
$1$, $2$, $1+2=3$, $2+2=4$ ja $1+2+2=5$,
mutta emme voi muodostaa summaa $6$.

Tässä tehtävässä vaikeutena on, että mahdollisten osajoukkojen
määrä on suuri: voimme muodostaa $n$ kolikosta $2^n$ osajoukkoa.
Niinpä ei ole mitenkään realistinen ratkaisu,
että alkaisimme käydä läpi osajoukkoja yksitellen,
vaan tarvitsemme jotain selvästi parempaa.

Tehtävän ratkaisua helpottaa, kun lähdemme liikkeelle pienistä summista.
Haluamme muodostaa ensin summan $1$, ja tähän tarvitsemme välttämättä
kolikon, jonka arvo on $1$.
Sitten haluamme muodostaa summan $2$, mihin tarvitsemme joko
toisen kolikon $1$ tai kolikon $2$, ja sen jälkeen summan $3$,
joka voi muodostua kolikoista $1+1+1$, $1+2$ tai $3$.
Voisimme jatkaa eteenpäin, mutta vaihtoehtoja alkaa tulla
paljon ja meidän on vaikeaa hallita niitä.

Meidän kannattaakin nyt alkaa miettiä ongelmaa yleisemmin.
Oletetaan, että meillä on joukko kolikoita,
joista voimme muodostaa kaikki summat $1,2,\dots,s$.
Voimmeko ottaa mukaan vielä uuden kolikon niin,
että saamme muodostettua myös summan $s+1$?
Tämä on mahdollista tarkalleen silloin, kun saatavilla on kolikko,
jonka arvo on $s+1$ tai \emph{pienempi}.
Jos uuden kolikon arvo on $u$, pystymme muodostamaan tämän jälkeen
kaikki summat $1,2,\dots,s+u$.
Lisäksi jos meillä on monia vaihtoehtoja valita uusi kolikko,
voimme valita minkä tahansa niistä.
Erityisesti voimme päättää, että valitsemme aina
\emph{pienimmän} mahdollisen kolikon.

Nyt meillä on koossa kaikki tarvittavat ainekset
tehokasta algoritmia varten.
Aloitamme tyhjästä joukosta ja lisäämme siihen kolikoita
pienimmästä suurimpaan niin kauan kuin mahdollista.
Lopuksi vastaus tehtävään on yhtä suurempi kuin kolikoiden
summa.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
Arrays.sort(kolikot);
long summa = 0;
for (int i = 0; i < n; i++) {
    if (kolikot[i] <= summa+1) {
        summa += kolikot[i];
    } else {
        break;
    }
}
long vastaus = summa+1;
\end{code}

Algoritmin aikavaativuus on $O(n \log n)$, koska se
järjestää ensin taulukon ja käy sitten läpi taulukon alkiot.

\subsection{X}

\subsection{X}
