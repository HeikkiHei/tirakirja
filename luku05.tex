\chapter{Hajautustaulu}

Tämän luvun tavoitteemme on luoda tietorakenne,
jonka avulla voimme pitää yllä tehokkaasti alkioiden joukkoa,
jossa on seuraavat operaatiot:

\begin{itemize}
\item lisää alkio $x$ joukkoon
\item tarkista, onko alkio $x$ joukossa
\item poista alkio $x$ joukosta
\end{itemize}

Jos alkiot olisivat aina kokonaislukuja
välillä $0,1,\ldots,n-1$, voisimme ratkaista tehtävän
helposti luomalla $n$-kokoisen taulukon, jonka
jokaisessa kohdassa $x$ on luku 0 ($x$ ei ole taulukossa)
tai luku 1 ($x$ on taulukossa).
Tällaisen taulukon avulla voisimme toteuttaa
helposti kaikki yllä olevat operaatiot $O(1)$-ajassa
päivittämällä tai tutkimalla yhtä kohtaa taulukosta.

Tässä luvussa keskitymme kuitenkin yleisempään tilanteeseen,
jossa alkiot eivät ole välttämättä sopivan pieniä kokonaislukuja
vaan ne voivat olla minkä tahansa tyyppisiä, esimerkiksi merkkijonoja.
Osoittautuu, että voimme yleistää yllä olevan idean toteuttamalla
hajautustaulun, jossa jokaisen alkion sijainnin määrää sen hajautusarvo,
ja pystymme edelleen toteuttamaan kaikki operaatiot
tehokkaasti keskimäärin $O(1)$-aikaisesti.

\section{Hajautustaulun toteutus}

\emph{Hajautustaulu} on $n$-kokoinen taulukko,
joka pitää yllä alkioiden joukkoa.
Jokaisessa hajautustaulun kohdassa on lista,
jossa on jokin määrä alkioita.
Jotta voimme käyttää hajautustaulua,
meillä täytyy olla myös \emph{hajautusfunktio},
jonka avulla voimme laskea mille tahansa alkiolle
\emph{hajautusarvon} eli kohdan, johon alkio
tallennetaan hajautustaulussa.

\begin{figure}
\begin{tikzpicture}[scale=0.5]
\draw (0,0) grid (10,1);
\foreach \x in {0,1,...,9} \node at (0.5+\x,0.5) {\x};
\draw[->,thick] (2.5,0) -- (2.5,-1);
\draw[->,thick] (7.5,0) -- (7.5,-1);
\draw[->,thick] (2.5,-2) -- (2.5,-3);
\node at (2.5,-1.5) {\texttt{apina}};
\node at (7.5,-1.5) {\texttt{banaani}};
\node at (2.5,-3.5) {\texttt{cembalo}};
\end{tikzpicture}
\caption{Hajautustaulu, joka vastaa joukkoa $\{\texttt{apina},\texttt{banaani},\texttt{cembalo}\}$.
Merkkijonojen \texttt{apina} ja \texttt{cembalo} hajautusarvo on 2, ja merkkijonon
\texttt{banaani} hajautusarvo on 7.}
\label{fig:hajtau}
\end{figure}

Kuvassa \ref{fig:hajtau} on esimerkkinä hajautustaulu, jossa on
merkkijonot \texttt{apina}, \texttt{banaani} ja \texttt{cembalo}.
Tässä hajautustaulussa on kymmenen mahdollista kohtaa
($0,1,\ldots,9$), joihin voi tallentaa alkioita listaan.
Merkkijonojen \texttt{apina} ja \texttt{cembalo}
hajautusarvo on 2, joten ne ovat samassa listassa kohdassa 2.
Merkkijonon \texttt{banaani} hajautusarvo taas on 7,
joten se on yksin omassa listassaan.
Kaikki muut hajautustaulun listat ovat tällä hetkellä tyhjiä.

Kun olemme luoneet hajautustaulun, voimme tarkistaa,
onko tietty alkio joukossa, laskemalla sen hajautusarvon
ja käymällä läpi vastaavan listan.
Vastaavasti voimme lisätä alkion joukkoon
lisäämällä sen vastaavan listan loppuun ja poistaa
alkion joukosta poistamalla sen listasta.
Näiden operaatioiden aikavaativuus on $O(k)$,
missä $k$ on alkion hajautusarvoa vastaavan listan pituus,
koska meidän täytyy käydä läpi listalla olevat alkiot.
Hajautustaulun tehokkuus riippuukin siitä,
kuinka pitkiä listat ovat.

\subsection{Hajautusarvon laskeminen}

Hajautusfunktio määrittää, mihin kohtaan hajautustaulua
alkio sijoitetaan.
Sen täytyy antaa jokaiselle mahdolliselle alkiolle
hajautusarvo eli kokonaisluvu väliltä $0,1,\ldots,n-1$,
missä $n$ on hajautustaulun koko,
mutta meillä on muuten vapaat kädet hajautusfunktion suunnitteluun.
Ainoa välttämätön vaatimus on, että tietty alkio saa aina
saman hajautusarvon, jotta voimme löytää sen uudelleen
hajautustaulusta.

Jotta hajautustaulu olisi käyttökelpoinen, hajautusfunktioon
liittyy kuitenkin toinenkin vaatimus:
sen tulisi jakaa alkiot mahdollisimman \emph{tasaisesti}
eri puolille hajautustaulua.
Syynä tähän on, että hajautustaulun tehokkuus riippuu siitä,
miten tasaisesti alkiot ovat jakautuneet.
Jos alkiot ovat jakautuneet tasaisesti ja listat ovat lyhyitä,
voimme etsiä alkioita ja päivittää hajautustaulua tehokkaasti.

Käytännössä meidän riittää muodostaa hajautusfunktio,
joka muuttaa alkion epänegatiiviseksi kokonaisluvuksi,
koska tämän jälkeen saamme helposti kokonaisluvun
väliltä $0,1,\ldots,n-1$ laskemalla jakojäännöksen $n$:llä,
missä $n$ on hajautustaulun koko.
Tarkastelemme seuraavaksi esimerkkinä merkkijonon
hajautusarvon laskemista.

Merkkijonojen tapauksessa yksi mahdollinen hajautusfunktio
palauttaa merkkijonon pituuden.
Tällöin esimerkiksi merkkijono \texttt{apina} saa
hajautusarvon 5 ja merkkijono \texttt{banaani} saa
hajautusarvon 7.
Tällainen hajautusfunktio on sinänsä toimiva,
mutta sen huonona puolena on, että se antaa monelle
merkkijonolle saman hajautusarvon.
Esimerkiksi suomen kielessä on suuri määrä 5-kirjaimisia
sanoja ja ne kaikki saavat saman hajautusarvon tätä
hajautusfunktiota käyttämällä.

Kehittyneempi hajautusfunktio merkkijonoja varten
ottaa huomioon myös merkkijonon sisällön.
Esimerkiksi voimme sopia, että merkki \texttt{a} vastaa
lukua 1, merkki \texttt{b} vastaa lukua 2, jne.
Tämän jälkeen voimme käyttää hajautusarvona merkkijonon
merkkien koodien summaa.
Nyt esimerkiksi merkkijonon \texttt{apina} hajautusarvo
on $1+16+9+14+1=41$.
Tämä on selvästi parempi hajautusfunktio,
mutta ongelmana on vielä se, että jos kahdessa
merkkijonossa on samat merkit eri järjestyksessä,
ne saavat saman hajautusarvon.

Voimme parantaa hajautusfunktiota asettamalla eri
kohdissa oleville merkeille eri kertoimet.
Yleinen tapa on \emph{polynominen hajautus},
jossa kertoimet valitaan niin, että ne ovat muotoa
$A^k$, missä $A$ on vakio ja $k$ on merkin paikka
merkkijonossa lopusta lukien.
Esimerkiksi jos $A=3$, merkkijonon \texttt{apina}
hajautusarvoksi tulee
\[ 1\cdot3^4+16\cdot3^3+9\cdot3^2+14\cdot3^1+1\cdot3^0 = 637.\]

Polynominen hajautus on käytännössä hyvin toimiva tapa
määrittää hajautusarvo, ja se on käytössä esimerkiksi
Javan standardikirjastossa.

\subsection{Hajautustaulun tehokkuus}

\section{Hajautus Javassa}

Javassa on kaksi hajautustaulua käyttävää tietorakennetta:
\texttt{HashSet} ylläpitää tehokkaasti joukkoa alkioista
ja \texttt{HashMap} on yleistetty taulukko,
jossa voi olla avaimina minkä tahansa tyyppisiä alkioita.
Seuraavaksi tutustumme tarkemmin näihin rakenteisiin.

\subsection{\texttt{HashSet}}

Javan \texttt{HashSet}-rakenne pitää yllä joukkoa alkioista
hajautustaulun avulla.
Rakenteen tärkeimmät operaatiot ovat seuraavat:

\begin{itemize}
\item $\texttt{add}(x)$: lisää alkio $x$ joukkoon
\item $\texttt{contains}(x)$: tarkasta, onko alkio $x$ joukossa
\item $\texttt{remove}(x)$: poista alkio $x$ joukosta
\item $\texttt{size}()$: laske, montako alkiota on joukossa
\end{itemize}

Esimerkiksi seuraava koodi luo joukon, jossa voi olla
kokonaislukuja, ja lisää luvut 3, 5 ja 8 joukkoon.
Tämän jälkeen koodi tulostaa joukon sisällön.

\begin{code}
HashSet<Integer> joukko = new HashSet<Integer>();
joukko.add(3);
joukko.add(5);
joukko.add(8);
System.out.println(joukko); // [3, 5, 8]
\end{code}

Huomaa, että jokainen alkio voi esiintyä vain kerran joukossa.
Esimerkiksi vaikka seuraava koodi lisää luvun 5 kolmesti
joukkoon, se menee sinne vain ensimmäisellä kerralla ja
muut lisäykset jätetään huomiotta.

\begin{code}
HashSet<Integer> joukko = new HashSet<Integer>();
joukko.add(5);
joukko.add(5);
joukko.add(5);
System.out.println(joukko); // [5]
\end{code}

Olennainen seikka \texttt{HashSet}-rakenteessa on,
että operaatiot \texttt{add}, \texttt{contains} ja \texttt{remove}
toimivat kaikki keskimäärin tehokkaasti ajassa $O(1)$
hajautustaulun ansiosta.
Niinpä voimme tehdä mitä tahansa muutoksia ja hakuja
rakenteeseen ja koodi toimii nopeasti.
Tämä ei olisi mahdollista \texttt{ArrayList}-rakenteessa,
jossa operaatiot \texttt{contains} ja \texttt{remove}
vievät aikaa $O(n)$.

\subsection{\texttt{HashMap}}

\texttt{HashMap}-rakenne pitää yllä joukkoa avain-arvo-pareja.
Rakennetta voi ajatella taulukon yleistyksenä:
$n$ alkion taulukossa avaimet ovat aina kokonaisluvut
$0,1,\ldots,n-1$, mutta \texttt{HashMap} sallii
avaimina minkä tahansa tyyppisiä alkioita eikä niiden
tarvitse olla peräkkäisiä kokonaislukuja.

Esimerkiksi seuraava koodi luo sanakirjan, jossa sekä
avaimet että arvot ovat merkkijonoja.
Sanakirjaan voi syöttää merkkijonopareja, jotka kertovat
sanan käännöksen suomesta englanniksi.
Metodi \texttt{put} lisää uuden avain-arvo-parin,
ja metodi \texttt{get} hakee arvon avaimen perusteella.

\begin{code}
HashMap<String,String> sanakirja = new HashMap<String,String>();

sanakirja.put("apina","monkey");
sanakirja.put("banaani","banana");
sanakirja.put("cembalo","harpsichord");

System.out.println(sanakirja.get("banaani")); // banana
\end{code}

Hyödyllinen on myös metodi \texttt{containsKey},
jonka avulla voi tarkastaa, onko tietylle avaimelle
tallennettu arvoa:

\begin{code}
if (sanakirja.containsKey(sana)) {
    System.out.println("Käännös: " + sanakirja.get(sana));
} else {
    System.out.println("Sana puuttuu sanakirjasta!");
}
\end{code}

Koska \texttt{HashMap} on toteutettu hajautustaulun avulla,
sen operaatiot toimivat tehokkaasti keskimäärin $O(1)$-ajassa.

\subsection{Metodi \texttt{hashCode}}

Javan hajautustaulut perustuvat siihen, että olioissa
on metodi \texttt{hashCode}, jonka avulla olio kertoo
pyydettäessä hajautusarvonsa.
Voimme esimerkiksi selvittää merkkijonon \texttt{"ABC"}
hajautusarvon näin:

\begin{code}
System.out.println("ABC".hashCode());
\end{code}

Tämä koodi tulostaa luvun 64578,
joka on siis merkkijonon \texttt{"ABC"} hajautusarvo Javassa.

Metodi \texttt{hashCode} on toteutettu valmiiksi Javan
sisäisiin tyyppeihin, kuten \texttt{Integer} ja \texttt{String},
joten voimme käyttää niitä suoraan hajautustauluissa.
Kuitenkin jos meillä on itse tehty luokka, jonka olioita
haluamme käyttää hajautustauluissa, meidän on toteutettava
itse metodi \texttt{hashCode}.

Esimerkiksi jos meillä on luokka \texttt{Asiakas},
jossa on kenttinä merkkijonot
\texttt{etunimi} ja \texttt{sukunimi},
voisimme toteuttaa metodin \texttt{hashCode} seuraavasti:

\begin{code}
public class Asiakas {
    private String etunimi;
    private String sukunimi;

    int hashCode() {
        return etunimi.hashCode()+sukunimi.hashCode();
    }

    // ...
}
\end{code}
