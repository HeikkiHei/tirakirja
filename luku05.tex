\chapter{Algoritmien suunnittelu}

Kuinka voi suunnitella hyvän algoritmin?
On selvää, ettei tähän kysymykseen ole helppoa vastausta.
Yhtä hyvin voisi kysyä, kuinka voi kirjoittaa hyvän kirjan
tai säveltää hyvää musiikkia.

Tämän kurssin keskeinen tavoitteemme on saada aikaan tehokkaita algoritmeja,
jotka toimivat ajassa $O(n)$ tai $O(n \log n)$.
Kun tämä tavoite on tiedossa, voimme ottaa sen algoritmien
suunnittelun lähtökohdaksi ja kartoittaa sen avulla mahdollisia
lähestymistapoja, joita voimme käyttää.

\section{Perustekniikoita}

Millainen on algoritmi, joka vie aikaa $O(n)$ tai $O(n \log n)$?
Tämä tarkoittaa,
että kun algoritmille annetaan syötteenä $n$ alkiota,
se saa käyttää jokaisen alkion käsittelyyn
vain pienen määrän aikaa.
Niinpä algoritmissa tulisi esiintyä seuraavan kaltaisia silmukoita:

\begin{code}
for (int i = 0; i < n; i++) {
    // tee jotain nopeaa
}
\end{code}

Tässä ''jotain nopeaa'' tarkoittaa koodia, joka vie aikaa
$O(1)$ tai $O(\log n)$.
Algoritmi voi myös järjestää aineistoa,
koska tehokkaat järjestämisalgoritmit vievät aikaa $O(n \log n)$.
Kovin paljon muuta tehokas algoritmi ei sitten voikaan tehdä.
Tämä rajoittaa paljon, mitä aineksia voimme laittaa algoritmiin,
mutta voimme ajatella asiaa myös myönteisesti:
vaatimus tehokkuudesta rajaa pois suuren määrän lähestymistapoja,
eli meidän on helpompaa löytää hyvä algoritmi,
kun vaihtoehtojen määrä on pienempi.

Algoritmien suunnittelussa keskeisiä ovat \emph{havainnot}:
haluamme saada käsityksen,
mitä ominaisuuksia ratkaistavaan ongelmaan liittyy,
jotta voimme käyttää niitä algoritmissa.
Voimme tehdä havaintoja tutkimalla ongelman pieniä tapauksia
ja etsimällä riippuvuuksia ja säännöllisyyksiä.
Jos käy hyvin, huomaamme asioita, jotka pätevät kaikissa ongelman
tapauksissa, ja voimme hyödyntää niitä koko tehtävän ratkaisemisessa.

\subsection{Algoritmin tehostaminen}

Tavallinen tilanne algoritmien suunnittelussa on,
että meillä annetaan ongelma ja pystymme ratkaisemaan sen
helposti $O(n^2)$-ajassa ensimmäisellä mieleen tulevalla algoritmilla.
Haasteena on kuitenkin keksiä tehokkaampi algoritmi,
joka toimii ajassa $O(n)$ tai $O(n \log n)$.
Kokemus on osoittanut, että tämä on hyvä tilanne:
yleensä \emph{pystymme} tehostamaan
tavalla tai toisella algoritmia,
kunhan mietimme huolellisesti asiaa.

Tarkastellaan esimerkkinä seuraavaa tehtävää:
Annettuna on taulukko, joka sisältää luvut $1,2,\dots,n$
jossakin järjestyksessä,
ja haluamme kerätä luvut pienimmästä suurimpaan.
Joka kierroksella käymme läpi taulukon vasemmalta
oikealle ja keräämme mahdollisimman monta seuraavaa lukua.
Montako kierrosta tarvitsemme yhteensä?
Esimerkiksi taulukossa $[4,3,1,5,2]$
tarvitsemme kolme kierrosta:
ensin keräämme luvut $1$ ja $2$,
sitten luvun $3$ ja lopuksi luvut $4$ ja $5$.

Voimme ratkaista tehtävän helposti suoraviivaisesti $O(n^2)$-ajassa
simuloimalla tehtävänannon kuvaamaa prosessia:

\begin{code}
int luku = 1;
int laskuri = 0;
while (luku <= n) {
    laskuri++;
    for (int i = 0; i < n; i++) {
        if (taulu[i] == luku) luku++;
    }
}
System.out.println(laskuri);
\end{code}

Tässä muuttuja \texttt{luku} kertoo,
minkä luvun haluamme kerätä seuraavaksi,
ja muuttuja \texttt{laskuri} laskee,
montako kierrosta tarvitaan.
Kierroksia tarvitaan aina korkeintaan $n$,
koska saamme kerättyä joka kierroksella
ainakin yhden luvun,
joten algoritmi toimii ajassa $O(n^2)$.

Kuinka voisimme sitten tehostaa algoritmia niin,
että se veisi aikaa vain $O(n)$ tai $O(n \log n)$?
Algoritmin hitaus johtuu tällä hetkellä pohjimmiltaan siitä,
että sillä menee kauan aikaa löytää,
missä kohdassa taulukossa on seuraava luku,
jonka haluamme kerätä.
Niinpä jotta voimme ratkaista tehtävän tehokkaasti,
meidän täytyy jollakin tavalla löytää seuraava kerättävä luku nopeammin.
Kätevä ratkaisu tähän on luoda aputaulukko,
joka kertoo jokaisen luvun kohdan:

\begin{code}
int[] kohta = new int[n+1];
for (int i = 0; i < n; i++) {
    kohta[taulu[i]] = i;
}
\end{code}

Tämän taulukon avulla saamme selville $O(1)$-ajassa,
missä kohdassa taulukossa on seuraava kerättävä luku.
Entä mistä tiedämme, montako kierrosta tarvitsemme?
Meidän täytyy aloittaa uusi kierros aina silloin,
kun viimeksi keräämämme luku on myöhemmin taulukossa
kuin seuraava kerättävä luku.
Niinpä voimme laskea kierrosten määrän näin:

\begin{code}
int laskuri = 1;
for (int i = 2; i <= n; i++) {
    if (kohta[i-1] > kohta[i]) {
        laskuri++;
    }
}
System.out.println(laskuri);
\end{code}

Tuloksena on algoritmi, jossa on kaksi silmukkaa,
joista molemmat vievät aikaa vain $O(n)$.
Niinpä algoritmin aikavaativuus on $O(n)$,
eli olemme saavuttaneet tavoitteemme.

\subsection{Ahneet algoritmit}

Tehokkaan algoritmin saaminen aikaan vaatii usein,
että pystymme tekemään algoritmissa jotain \emph{ahneesti}.
Tämä tarkoittaa, että meidän ei tarvitse käydä läpi
kaikkia mahdollisia ratkaisuja vaan riittää muodostaa
yksi ratkaisu, jonka pystymme rakentamaan askel askeleelta
käsittelemällä syötteenä annetun aineiston jossain sopivassa järjestyksessä.

Tarkastellaan esimerkkinä seuraavaa tehtävää:
Meillä on $n$ kolikkoa, jonka jokaisen arvo on positiivinen kokonaisluku,
ja haluamme selvittää pienimmän summan, jota \emph{ei} voi muodostaa kolikoista.
Esimerkiksi jos kolikot ovat $[1,2,2,9]$, voimme muodostaa summat
$1$, $2$, $1+2=3$, $2+2=4$ ja $1+2+2=5$,
mutta emme voi muodostaa summaa $6$.

Tämä tehtävä vaikuttaa ensi silmäykseltä vaikealta,
koska mahdollisia tapoja summien muodostamiseen on niin paljon.
Kun meillä on $n$ kolikkoa, voimme valita $2^n$ tavalla
kolikoiden osajoukon, joista syntyy jokin summa.
On selvää, että algoritmista tulee liian hidas,
jos se käy läpi kaikki tavat summan muodostamiseen.
Jotta saisimme aikaan tehokkaan algoritmin,
meidän tulisi huomata ongelmasta jotain,
jonka ansiosta pystymme välttämään kolikoiden osajoukkojen läpikäymisen.

Yksi hyvä tapa lähestyä tehtävää ja saada jotain tietoa ongelman luonteesta
on lähteä ensin liikkeelle pienistä summista.
Haluamme muodostaa ensin summan $1$, ja tähän tarvitsemme välttämättä
kolikon, jonka arvo on $1$.
Sitten haluamme muodostaa summan $2$, mihin tarvitsemme joko
toisen kolikon $1$ tai kolikon $2$, ja sen jälkeen summan $3$,
joka voi muodostua kolikoista $1+1+1$, $1+2$ tai $3$.
Voisimme jatkaa eteenpäin, mutta vaihtoehtoja alkaa tulla
paljon ja meidän on vaikeaa hallita niitä.
Kuitenkin näyttää siltä, että meidän kannattaa aloittaa
summien muodostaminen pienistä kolikoista.

Seuraavaksi meidän kannattaa alkaa miettiä ongelmaa yleisemmin.
Oletetaan, että meillä on joukko kolikoita,
joista voimme muodostaa kaikki summat $1,2,\dots,s$.
Voisimmeko ottaa mukaan vielä jonkin uuden kolikon arvoltaan $u$ niin,
että saamme muodostettua myös summan $s+1$?
Tämä on mahdollista tarkalleen silloin, kun $u \le s+1$,
eli uuden kolikon arvo saa olla enintään $s+1$.
Jos tämä ehto pätee, voimme ottaa kolikon mukaan ja
pystymme muodostamaan tämän jälkeen kaikki summat $1,2,\dots,s+u$.
Esimerkiksi jos meillä on kolikot $[1,1,3]$, voimme muodostaa
niistä summat $1,2,\dots,5$ ja uuden kolikon arvon tulee olla enintään $6$.
Jos uuden kolikon arvo on vaikkapa $4$, voimme ottaa sen mukaan ja
pystymme muodostamaan sen jälkeen kolikoista $[1,1,3,4]$ summat $1,2,\dots,9$.

Lisäksi jos meillä on monia vaihtoehtoja valita uusi kolikko,
ei ole väliä, missä järjestyksessä otamme ne mukaan vaan
voimme valita seuraavaksi minkä tahansa niistä.
Erityisesti voimme päättää, että valitsemme aina
seuraavaksi ahneesti \emph{pienimmän} mahdollisen kolikon.
Nyt meillä on koossa kaikki tarvittavat ainekset
tehokasta algoritmia varten.
Aloitamme tyhjästä joukosta ja lisäämme siihen kolikoita
pienimmästä suurimpaan niin kauan kuin mahdollista.
Lopuksi vastaus tehtävään on yhtä suurempi kuin kolikoiden
summa.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
long summa = 0;
Arrays.sort(kolikot);
for (int i = 0; i < n; i++) {
    if (kolikot[i] <= summa+1) {
        summa += kolikot[i];
    } else {
        break;
    }
}
System.out.println(summa+1);
\end{code}

Kuten koodista näkyy, meidän ei tarvitse oikeastaan pitää yllä
kolikoiden joukkoa, vaan riittää säilyttää tietoa
joukossa olevien kolikoiden summasta muuttujassa \texttt{summa}.
Käymme läpi kolikot järjestyksessä pienimmästä suurimpaan
kasvatamme summaa, jos se on mahdollista.
Kun vastaan tulee ensimmäinen kolikko, jota emme voi ottaa mukaan,
silmukka päättyy.
Tuloksena on algoritmi, jonka aikavaativuus on $O(n \log n)$.

\section{Binäärihaku}

\emph{Binäärihaku} on tekniikka, joka pelastaa meidät monesta
kiipelistä algoritmien suunnittelussa.
Parhaiten tunnettu binäärihaun käyttötarkoitus on alkion
etsiminen järjestetystä taulukosta ajassa $O(\log n)$,
mutta tämä on vain alkusoittoa sille kaikelle,
mitä binäärihaun avulla pystyy tekemään.

Binäärihaun yleinen käyttötarkoitus on seuraava:
tiedämme, että jokin asia ei päde koskaan ennen kohtaa $k$
mutta pätee aina kohdasta $k$ alkaen,
ja haluamme löytää tehokkaasti kohdan $k$.
Binäärihaun avulla pystymme löytämään kohdan $k$
tarkistamalla vain $O(\log N)$ kohtaa,
kun mahdollisia kohtia on yhteensä $N$ kappaletta.

Ennen kuin voimme käyttää binäärihakua algoritmeissa,
meidän täytyy osata toteuttaa se toimivasti.
Seuraava koodi etsii kohdan $k$,
kun tiedämme etukäteen, että $k$ on välillä $1 \dots N$,
ja metodi $\texttt{ok}(u)$ kertoo, päteekö haluttu asia
kohdassa $u$.

\begin{code}
int a = 1, b = N;
while (a < b) {
    int u = (a+b)/2;
    if (ok(u)) b = u;
    else a = u+1;
}
int k = a;
\end{code}

Binäärihaku kutsuu $O(\log N)$ kertaa metodia \texttt{ok},
koska välin $a \dots b$ koko puolittuu jokaisella askeleella.

\subsection{Koneiden aikataulu}

Tarkastellaan esimerkkinä tehtävää, jossa käytössämme on $n$ konetta
ja haluamme valmistaa niiden avulla $m$ tavaraa.
Tiedossamme on myös arvot $[x_1,x_2,\dots,x_n]$:
jokaisesta koneesta tieto, montako minuuttia vie aikaa valmistaa
yksi tavara konetta käyttäen.
Haluamme löytää suunnitelman, jota seuraamalla pystymme valmistamaan
$m$ tavaraa mahdollisimman nopeasti.
Esimerkiksi jos $n=3$, $m=7$ ja koneiden nopeudet ovat $[2,3,7]$,
tavaroiden muodostaminen vie aikaa $8$ minuuttia.
Kuva \ref{fig:optkon} näyttää, miten voimme käyttää koneita optimaalisesti.
Käynnistämme koneen 1 neljästi hetkinä 0, 2, 4 ja 6,
koneen 2 kahdesti hetkinä 0 ja 3
ja koneen 3 kerran hetkenä 0.
Aikaa kuluu $8$ minuuttia, koska viimeisenä pysähtyy kone 1 hetkenä 8.

\begin{figure}
\center
\begin{tikzpicture}[scale=0.7]
\draw[->] (-1,1.5) -- (10,1.5);
\foreach \x in {0,2,4,6,8} \draw (\x,1.40) -- (\x,1.60);
\foreach \x in {0,2,4,6,8} \node at (\x,2) {\scriptsize $\x$};
\node at (-2,0) {kone $1$};
\draw[|-|] (0.05,0) -- (1.95,0);
\draw[|-|] (2.05,0) -- (3.95,0);
\draw[|-|] (4.05,0) -- (5.95,0);
\draw[|-|] (6.05,0) -- (7.95,0);
\node at (-2,-1.5) {kone $2$};
\draw[|-|] (0.05,-1.5) -- (2.95,-1.5);
\draw[|-|] (3.05,-1.5) -- (5.95,-1.5);
\node at (-2,-3) {kone $3$};
\draw[|-|] (0.05,-3) -- (6.95,-3);
\end{tikzpicture}
\caption{Optimaalinen tapa valmistaa 7 tavaraa vie 8 sekuntia,
kun koneiden nopeudet ovat $[2,3,7]$.}
\label{fig:optkon}
\end{figure}

Voimme pukea tämän tehtävän binäärihaulle sopivaan muotoon niin,
että haluamme löytää aikajanalta kohdan $k$, jossa ensimmäistä
kertaa pystymme muodostamaan $m$ tavaraa ajassa $k$.
Äskeisessä esimerkissä $k=8$, koska tarvitsemme ainakin 8
minuuttia aikaa 7 tavaran muodostamiseen.
Jotta voimme käyttää binäärihakua, meillä täytyy olla keino
tarkastaa mistä tahansa kohdasta $u$, voimmeko muodostaa
ainakin $m$ tavaraa, jos meillä on aikaa $u$ minuuttia.
Seuraava metodi hoitaa asian:

\begin{code}
boolean ok(int u) {
    int tavarat = 0;
    for (int i = 1; i <= n; i++) {
        tavarat += u/x[i];
    }
    return tavarat >= m;
}
\end{code}

Metodissa on ideana, että jos meillä on $u$ minuuttia aikaa
ja koneella kestää $x_i$ minuuttia valmistaa yksi tavara,
pystymme valistamaan $\lfloor u/x_i \rfloor$ tavaraa.
Tämän ansiosta voimme laskea ylärajan sille,
montako tavaraa pystymme muodostamaan.
Jos pystymme muodostamaan ainakin $m$ tavaraa,
tiedämme, että $u$ minuuttia riittää tavaroiden muodostamiseen
eli $k \le u$.

Voimme kytkeä tämän metodin suoraan binäärihakuun,
jolloin tuloksena on tehokas algoritmi tehtävän ratkaisemiseen.
Meidän täytyy kuitenkin vielä valita arvo $N$,
joka on jokin yläraja kohdalle $k$.
Tässä tehtävässä helppo valinta on
\[N = x_1 \cdot m,\]
mikä vastaa ratkaisua, jossa käytämme vain ensimmäistä konetta.
On varmaa, että oikea $k$:n arvo on korkeintaan $N$,
joten binäärihaku kutsuu $O(\log N)$ kertaa metodia $\texttt{ok}$.
Koska jokainen metodin kutsu vie aikaa $O(n)$,
tuloksena on algoritmi, jonka aikavaativuus on $O(n \log N)$.

Huomaa, että $\log N$ on käytännössä pieni luku riippumatta
siitä, kuinka suuri luku $N$ on.
Niinpä meidän ei tarvitse murehtia siitä,
kuinka suuria arvot $x_1$ ja $m$ ovat,
vaan voimme luottaa siihen, että algoritmi on tehokas.

\subsection{Alitaulukot}

Tarkastellaan sitten tehtävää, jossa annettuna on $n$
positiivista kokonaislukua sisältävä taulukko ja lisäksi kokonaisluku $x$.
Haluamme selvittää, monessako yhtenäisessä alitaulukossa
lukujen summa on $x$.
Esimerkiksi jos taulukko on $[3,2,1,1,3,1]$ ja $x=4$,
niin halutut alitaulukot ovat $[2,1,1]$, $[1,3]$ ja $[3,1]$,
eli vastaus on tässä tapauksessa $3$.

Voimme ratkaista tehtävän helposti ajassa $O(n^2)$
käymällä läpi kaikki yhtenäiset alitaulukot seuraavasti:

\begin{code}
int laskuri = 0;
for (int i = 0; i < n; i++) {
    int summa = 0;
    for (int j = i; j < n; j++) {
        summa += taulu[j];
        if (summa == x) laskuri++;
    }
}
System.out.println(laskuri);
\end{code}

Binäärihaun avulla voimme kuitenkin parantaa algoritmia niin,
että aikaa kuluu vain $O(n \log n)$.
Ideana on korvata yllä olevan koodin sisempi silmukka
binäärihaulla, joka etsii tehokkaasti kohdasta $i$
alkavan alitaulukon, jonka summa on $x$, jos tällainen alitaulukko on olemassa.
Voimme käyttää binäärihakua, koska tiedämme, että taulukon kaikki
luvut ovat positiivisia.
Niinpä voimme etsiä ensimmäisen kohdan $j$,
jossa alitaulukon summa on ainakin $x$.
Jos summa on tasan $x$, olemme löytäneet halutun alitaulukon,
ja muuten tällaista alitaulukkoa ei ole olemassa.

Jotta voimme toteuttaa tehokkaan ratkaisun,
tarvitsemme kuitenkin vielä yhden aineksen:
meidän täytyy pystyä laskemaan tehokkaasti,
mikä on alitaulukon summa,
kun tiedämme alitaulukon alku- ja loppukohdan.
Tällainen rakenne on \emph{summataulukko},
johon on laskettu etukäteen summa jokaisesta taulukon alkuosasta.
Toisin sanoen summataulukon kohdassa $k$ on taulukon
lukujen summa taulukon alusta kohtaan $k$ asti.

Voimme muodostaa summataulukon ajassa $O(n)$ seuraavasti:

\begin{code}
summa[0] = taulu[0];
for (int i = 1; i < n; i++) {
    summa[i] = summa[i-1]+taulu[i];
}
\end{code}

Tämän jälkeen pystymme laskemaan $O(1)$-ajassa minkä tahansa
alitaulukon summan kohdasta $a$ kohtaan $b$ seuraavasti:

\begin{code}
int summa(int a, int b) {
    if (a == 0) return summa[b];
    else return summa[b]-summa[a-1];
}
\end{code}

Nyt voimme toteuttaa binäärihaun seuraavasti:

\begin{code}
int laskuri = 0;
for (int i = 0; i < n; i++) {
    int a = i, b = n-1;
    while (a < b) {
        int u = (a+b)/2;
        int s = summa(i,u);
        if (s >= x) b = u;
        else a = u+1;
    }
    if (summa(i,a) == x) laskuri++;
}
System.out.println(laskuri);
\end{code}

Jokaisessa kohdassa $i$ etsimme binäärihaulla väliltä $[i,n-1]$
ensimmäisen kohdan, jossa alitaulukon summa on ainakin $x$.
Sitten tarkastamme, onko summa tasan $x$,
ja jos on, kasvatamme laskuria yhdellä.
Tuloksena olevan algoritmin aikavaativuus on $O(n \log n)$,
koska jokainen binäärihaku vie summataulukon ansiosta
aikaa vain $O(\log n)$.

\section{Tasoitettu analyysi}

Tähän mennessä olemme arvioineet algoritmien tehokkuutta
lähinnä määrit\-tämällä jokaiselle silmukalle ylärajan,
montako kertaa siinä olevaa koodia suoritetaan.
Tämä onkin yleensä hyvä tapa laskea aikavaativuus,
mutta joskus ongelmaksi voi tulla, että silmukan kierrosten
määrä vaihtelee algoritmin eri vaiheissa eikä yläraja
anna oikeaa kuvaa tehokkuudesta.

Seuraavaksi tutustumme tekniikkaan nimeltä
\emph{tasoitettu analyysi}, jossa koetamme arvioida tarkemmin,
montako kertaa silmukassa olevaa koodia suoritetaan
\emph{yhteensä} algoritmin suorituksen aikana.
Tämän avulla pystymme joskus määrittämään algoritmin
aikavaativuuden tarkemmin.

\subsection{Alitaulukot}

Tarkastelemme uudestaan tehtävää, jossa meille on annettu
$n$ positiivisen kokonaisluvun taulukko ja haluamme laskea,
monenko yhtenäisen alitaulukon summa on $x$.
Olemme jo ratkaisseet tehtävän ajassa $O(n \log n)$
binäärihaun ja summataulukon avulla,
mutta nyt ratkaisemme tehtävän vielä tehokkaammin
ajassa $O(n)$ esimerkkinä tasoitetusta analyysista.

Ideana on, että meillä on kaksi muuttujaa $i$ ja $j$,
jotka osoittavat taulukkoon.
Muuttujat aloittavat taulukon alusta,
ja jokaisella vuorolla $i$ siirtyy askeleen oikealle
ja $j$ siirtyy oikealle niin kauan, kunnes välin $[i,j]$
lukujen summa on ainakin $x$.
Jos lukujen summa on tasan $x$, olemme löytäneet yhden
alitaulukon, jonka summa on $x$.
Seuraava koodi toteuttaa algoritmin:

\begin{code}
int j = -1;
int summa = 0;
int laskuri = 0;
for (int i = 0; i < n; i++) {
    while (j+1 < n && summa < x) {
        j++;
        summa += taulu[j];
    }
    if (summa == x) laskuri++;
    summa -= taulu[i];
}
System.out.println(laskuri);
\end{code}

Tästä koodista on ensin näkemältä vaikeaa määrittää algoritmin
aikavaativuutta, koska ei ole varmaa, montako kierrosta
\texttt{while}-silmukkaa suoritetaan milloinkin.
Voimme kuitenkin huomata, että muuttujan $j$ arvo on aluksi $-1$,
jokaisella silmukan kierroksella $j$ kasvaa yhdellä
ja silmukkaan mennään vain jos $j$ on enintään $n-1$.
Niinpä voimme päätellä, että silmukassa oleva koodi suoritetaan \emph{yhteensä}
vain $O(n)$ kertaa, mikä tarkoittaa sitä,
että koko algoritmin aikavaativuus on $O(n)$.

\subsection{X}


% \subsection{Alitaulukot}
% 
% Annettuna on taulukko, jossa on $n$ kokonaislukua,
% ja haluamme laskea, monellako tavalla voimme valita
% taulukosta yhtenäisen alitaulukon, jossa lukujen summa on $0$.
% Jotta tehtävä olisi kiinnostava, taulukossa voi olla
% mitä tahansa kokonaislukuja, myös negatiivisia.
% 
% Tarkastellaan esimerkkinä taulukkoa $[1,-1,2,-1,3]$.
% Tässä tapauksessa meillä on kaksi mahdollista tapaa
% valita yhtenäinen alitaulukko, jossa lukujen summa on $0$:
% $[1,-1]$ ja $[-1,2,-1]$.
% 
% Voimme ratkaista tehtävän helposti käymällä läpi
% kaikki mahdolliset alitaulukot kahdella silmukalla:
% 
% \begin{code}
% int laskuri = 0;
% for (int i = 0; i < n; i++) {
%     int summa = 0;
%     for (int j = i; j < n; j++) {
%         summa += taulu[j];
%         if (summa == 0) laskuri++;
%     }
% }
% System.out.println(laskuri);
% \end{code}
% 
% Tämä ratkaisu ei ole kuitenkaan tyydyttävä,
% koska se vie aikaa $O(n^2)$.
% 
% Ensimmäinen hyödyllinen havainto on,
% että taulukossa voi olla \emph{paljon} alitaulukoita,
% joiden summa on $0$.
% Itse asiassa jos taulukossa on vain lukua $0$,
% niin \emph{jokaisen} alitaulukon summa on $0$.
% Tämä tarkoittaa, että haluttuja alitaulukoita voi olla
% $O(n^2)$ kappaletta ja jos laskemme niitä yksitellen,
% algoritmimme on auttamatta liian hidas.
% Meidän täytyy siis keksiä keino, miten voimme laskea
% alitaulukoita ryhmissä.
% 
% Merkitään $s(k)$ taulukon \emph{alkuosan} summaa
% eli taulukon lukujen summaa taulukon alusta kohtaan $k$ asti
% ja lisäksi $s(-1)=0$.
% Nyt jos meillä on alitaulukko kohdasta $a$ kohtaan $b$,
% voimme laskea sen summan kaavalla $s(b)-s(a-1)$.
% Jos haluamme, että tämä summa on $0$, täytyy päteä
% $s(a-1)=s(b)$.
% Tämän havainnon ansiosta voimme muuttaa tehtävän
% mukavampaan muotoon: meidän täytyy vain laskea,
% monellako tavalla voimme valita kaksi taulukon alkuosaa
% niin, että niiden summat ovat samat.
% 
% Tarkastellaan asiaa esimerkkitaulukossamme $[1,-1,2,-1,3]$.
% Laskemme ensin alkuosien summat, jotka ovat $[0,1,0,2,1,4]$
% (mukaan lukien tyhjä alkuosa ensimmäisenä).
% Alitaulukon $[1,-1]$ tapauksessa $s(-1)=s(1)=0$ ja
% alitaulukon $[-1,2,-1]$ tapauksessa $s(0)=s(3)$.
% Nämä ovat ainoat tavat valita kaksi alkuosan summaa niin,

% että molemmat summat ovat samat.
% 
% Jotta saamme aikaan tehokkaan algoritmin, tarvitsemme vielä
% yhden aineksen: järjestämisen.
% Kun olemme laskeneet kaikki alkuosien summat,
% voimme järjestää ne, minkä jälkeen yhtä suuret summat
% ovat vierekkäin. Tämän jälkeen voimme laskea tehokkaasti
% jokaisesta summasta, monellako tavalla voimme valita
% kaksi tällaista alkuosaa.
% 
% Seuraava koodi rakentaa taulukon, jossa on kaikki alkuosien summat:
% 
% \begin{code}
% int[] summat = new int[n+1];
% for (int i = 0; i < n; i++) {
%     summat[i+1] = summat[i]+taulu[i];
% }
% \end{code}
% 
% Huomaa, että taulukko on yhden suurempi kuin alkuperäinen taulukko
% ja sen ensimmäinen alkio on aina $0$: tyhjän alkuosan summa.
% 
% Tämän jälkeen voimme käydä summat läpi seuraavasti:
% 
% \begin{code}
% Arrays.sort(summat);
% int toisto = 0;
% int laskuri = 0;
% for (int i = 0; i < n+1; i++) {
%     if (i == 0 || summat[i-1] != summat[i]) {
%         toisto = 0;
%     } else {
%         toisto++;
%     }
%     laskuri += toisto;
% }
% System.out.println(laskuri);
% \end{code}
% 
% Tässä muuttuja \texttt{toisto} pitää kirjaa, montako kertaa
% taulukon nykyinen luku on esiintynyt aiemmin.
% Tämä kertoo, monellako tavalla voimme valita parin,
% jossa on nykyinen summa ja aiempi sama summa.
% Tuloksena oleva algoritmi vie aikaa $O(n \log n)$,
% koska sen työläin vaihe on taulukon järjestäminen.
