\chapter{Komponentit ja virittävät puut}

Tähän mennessä olemme tarkastelleet verkkoja,
joiden rakenne säilyy samana koko algoritmin ajan.
Mitä tapahtuu sitten, jos verkkoon tuleekin \emph{muutoksia},
kuten lisäämme verkkoon uusia kaaria?

Tutustumme tässä luvussa union-find-rakenteeseen,
joka on hyödyl\-linen työkalu verkkojen käsittelyssä.
Rakenteen avulla voimme pitää kirjaa verkon yhtenäisistä
komponenteista ja päivittää rakennetta tehokkaasti,
kun lisäämme verkkoon kaaria.
Voimme esimerkiksi tarkkailla, montako yhte\-näistä
komponenttia verkossa on milläkin hetkellä.

Käsittelemme myös pienimmän virittävän puun ongelmaa,
jossa haluamme kytkeä verkon solmut toisiinsa kaaria käyttäen niin,
että kaarten yhteispaino on pienin.
Voimme ratkaista ongelman tehokkaasti Kruskalin algoritmilla,
joka perustuu union-find-rakenteeseen,
tai Primin algoritmilla, joka muistuttaa Dijkstran algoritmia.

\section{Union-find-rakenne}

Union-find-rakenne on tietorakenne, joka
pitää yllä kokoelmaa alkioiden joukkoja ja tarjoaa
seuraavat tehokkaat operaatiot:

\begin{itemize}
\item yhdistä kaksi joukkoa samaksi joukoksi
\item tarkista, ovatko kaksi alkiota samassa joukossa
\end{itemize}

Oletamme, että alkiot ovat $1,2,\dots,n$,
ja jokainen alkio kuuluu tarkalleen yhteen joukkoon.
Esimerkiksi kun $n=8$, joukot voivat olla vaikkapa
$A=\{1,4\}$, $B=\{2,5,6\}$ ja $C=\{3,7,8\}$.
Kun yhdistämme sitten joukot $A$ ja $B$,
niistä syntyy joukko $\{1,2,4,5,6\}$.
Ennen yhdistämistä alkiot $1$ ja $2$ olivat eri joukoissa,
mutta järjestämisen jälkeen ne ovat samassa joukossa.

\subsection{Rakenteen toteutus}

Toteutamme union-find-rakenteen niin, että jokaisessa joukossa
yksi alkioista on joukon \emph{edustaja} ja muut alkiot viittaavat
edustajaan suoraan tai muiden alkioiden kautta.
Kun haluamme tarkastaa, ovatko kaksi alkiota samassa joukossa,
selvitämme niiden edustajat ja vertaamme niitä toisiinsa.

Jokaisella joukon alkiolla $x$ on arvo $\texttt{seuraava}[x]$,
joka kertoo seuraavan alkion viittauksien ketjussa.
Jos $\texttt{seuraava}[x]=x$, alkio on joukon edustaja.
Tämän ansiosta saamme selville mille tahansa alkiolle $x$,
mikä on vastaavan joukon edustaja, kulkemalla läpi viittausten ketjun.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (4) at (0,-2) {$4$};

\node[draw, circle] (2) at (3,-2) {$2$};
\node[draw, circle] (5) at (4,0) {$5$};
\node[draw, circle] (6) at (5,-2) {$6$};

\node[draw, circle] (3) at (8,0) {$3$};
\node[draw, circle] (7) at (8,-2) {$7$};
\node[draw, circle] (8) at (8,-4) {$8$};

\path[draw,thick,->] (4) -- (1);
\path[draw,thick,->] (2) -- (5);
\path[draw,thick,->] (6) -- (5);
\path[draw,thick,->] (7) -- (3);
\path[draw,thick,->] (8) -- (7);
\end{tikzpicture}
\end{center}
\caption{Union-find-rakenne joukoille $\{1,4\}$, $\{2,5,6\}$ ja $\{3,7,8\}$.}
\label{fig:unifin}
\end{figure}

Kuvassa \ref{fig:unifin} on union-find-rakenne,
joka vastaa joukkoja $A=\{1,4\}$, $B=\{2,5,6\}$ ja $C=\{3,7,8\}$.
Tässä tapauksessa joukkojen edustajat ovat 1, 5 ja 3.
Esimerkiksi $\texttt{seuraava}[1]=1$, koska alkio $1$ on joukon edustaja,
ja $\texttt{seuraava}[2]=5$, koska alkio $2$ osoittaa alkioon $5$.
Saamme selville, mikä on alkion 8 joukon edustaja, kulkemalla ketjua
$8 \rightarrow 7 \rightarrow 3$.

Seuraava operaatio \texttt{edustaja} selvittää alkion $x$ joukon edustajan:

\begin{code}
int edustaja(int x) {
    while (x != seuraava[x]) {
        x = seuraava[x];
    }
    return x;
}
\end{code}

Tämän avulla voimme luoda operaation \texttt{sama}, joka tarkastaa,
ovatko alkiot $a$ ja $b$ samassa joukossa.
Alkiot ovat samassa joukossa täsmälleen silloin, kun niillä
on sama edustaja:

\begin{code}
boolean sama(int a, int b) {
    return edustaja(a) == edustaja(b);
}
\end{code}

\subsection{Tehokas yhdistäminen}

Viimeinen tarvittava operaatio on \texttt{yhdista}, joka yhdistää alkioita
$a$ ja $b$ vastaavat joukot.
Tämän operaation toteutus ratkaisee, kuinka tehokas rakenteemme on.
Haluamme, että alkioiden viittausten ketjut ovat lyhyitä,
jotta pystymme selvittämään nopeasti alkioiden edustajia.
Saavutamme tämän tavoitteen asettamalla \emph{pienemmän} joukon
edustajan osoittamaan \emph{suuremman} joukon edustajaan.
Jos joukot ovat yhtä suuria, voimme toteuttaa yhdistämisen
kummin päin vain haluamallamme tavalla.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (0,-2) {$4$};
\node[draw, circle] (3) at (4,0) {$5$};
\node[draw, circle] (4) at (3,-2) {$2$};
\node[draw, circle] (5) at (5,-2) {$6$};
\path[draw,thick,->] (2) -- (1);
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (5) -- (3);
\path[draw,thick,->,dashed] (1) -- (3);
\end{tikzpicture}
\end{center}
\caption{Tehokas yhdistäminen. Alkion $1$ joukon koko on 2
ja alkion $5$ joukon koko on 3,
joten yhdistämme alkion 1 alkioon 5.}
\label{fig:tehyhd}
\end{figure}

Kuva \ref{fig:tehyhd} näyttää, mitä tapahtuu, kun yhdistämme joukot
$A=\{1,4\}$ ja $B=\{2,5,6\}$.
Joukon $A$ edustaja on $1$ ja joukon $B$ edustaja on $5$.
Koska joukko $A$ on pienempi, asetamme joukon $A$
edustajan osoittamaan joukon $B$ edustajaan.
Tämän jälkeen kaikki alkiot kuuluvat samaan joukkoon ja
alkio $5$ on tästä lähtien koko joukon edustaja.

Jotta voimme toteuttaa yhdistämisen tehokkaasti,
meidän täytyy myös pitää kirjaa kunkin joukon koosta.
Seuraavassa toteutuksessa $\texttt{koko}[x]$ kertoo,
montako alkiota alkion $x$ edustama joukko sisältää.
Selvitämme ensin joukkojen edustajat ja yhdistämme sitten joukot.

\begin{code}
void yhdista(int a, int b) {
    a = edustaja(a);
    b = edustaja(b);
    if (koko[a] < koko[b]) {
        seuraava[a] = b;
        koko[b] += koko[a];
    } else {
        seuraava[b] = a;
        koko[a] += koko[b];
    }
}
\end{code}

Kun toteutamme yhdistämiset tällä tavalla, jokainen
alkioiden ketju sisäl\-tää vain $O(\log n)$ alkiota.
Tämä johtuu siitä, että aina kun kuljemme ketjussa
askeleen eteenpäin alkiosta $a$ alkioon $b$,
$\texttt{koko}[b] \ge 2 \cdot \texttt{koko}[a]$ eli
edustajaa vastaavan joukon koko ainakin \emph{kaksinkertaistuu}.
Koska joukossa on enintään $n$ alkiota,
kuljemme siis yhteensä enintään $O(\log n)$ askelta.
Niinpä operaatio \texttt{edustaja} toimii ajassa $O(\log n)$,
ja sen myötä myös operaatiot \texttt{sama} ja \texttt{yhdista}
toimivat ajassa $O(\log n)$.

\subsection{Ketjun tiivistäminen}

Pystymme saamaan union-find-rakenteen vielä tehokkaammaksi
toteuttamalla \texttt{edustaja}-operaation seuraavasti:

\begin{code}
int edustaja(int x) {
    return seuraava[x] = edustaja(x);
}
\end{code}

Tässä ideana on \emph{tiivistää} ketjua samalla,
kun kuljemme eteenpäin ketjussa.
Asetamme jokaisen ketjun alkion \texttt{seuraava}-arvoksi sen edustajan,
minkä ansiosta pääsemme suoraan edustajaan,
jos kuljemme samaa ketjua myöhemmin.
Kuva \ref{fig:poltii} näyttää esimerkin ketjun tiivistämisestä.
Kuljemme aluksi ketjua $4 \rightarrow 3 \rightarrow 2 \rightarrow 1$,
jolloin kaikki alkiot asetetaan viittaamaan edustajaan $1$.
Kun haluamme selvittää seuraavan kerran alkion $4$ edustajan,
pääsemme suoraan alkiosta $4$ edustajaan $1$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (-2,0) {$2$};
\node[draw, circle] (3) at (-4,0) {$3$};
\node[draw, circle] (4) at (-6,0) {$4$};
\path[draw,thick,->] (4) -- (3);
\path[draw,thick,->] (3) -- (2);
\path[draw,thick,->] (2) -- (1);
\node at (-8,0) {(a)};
\end{scope}
\begin{scope}[yshift=-2.5cm]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (-2,0) {$2$};
\node[draw, circle] (3) at (-4,0) {$3$};
\node[draw, circle] (4) at (-6,0) {$4$};
\path[draw,thick,->] (4) edge [bend left] (1);
\path[draw,thick,->] (3) edge [bend right] (1);
\path[draw,thick,->] (2) -- (1);
\node at (-8,0) {(b)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Ketjun tiivistäminen. (a) Alkuperäinen ketju $4 \rightarrow 3 \rightarrow 2 \rightarrow 1$.
(b) Tiivistetty ketju, jossa kaikki alkiot viittaavat suoraan edustajaan.}
\label{fig:poltii}
\end{figure}

On mahdollista osoittaa, että ketjujen tiivistämisen ansiosta
$\texttt{edustaja}$-ope\-raatiot vievät tasoitetusti aikaa vain
$O(\alpha(n))$, missä $\alpha(n)$ on hyvin hitaasti kasvava
\emph{käänteinen Ackermannin funktio}.
Funktiosta tiedetään, että $\alpha(n)<5$, kun $n$ on mikä tahansa
käytännössä esiintyvä joukon koko.
Tämä tarkoittaa, että voimme ajatella union-find-rakenteen
operaatioiden olevan käytännössä \emph{vakioaikaisia}.
Tämän tuloksen osoittaminen on kuitenkin vaikeaa,
emmekä käsittele asiaa tarkemmin tällä kurssilla.

\section{Esimerkki: Kaupungit}

Bittimaassa on $n$ kaupunkia, joiden välillä ei ole vielä yhtään tietä.
Sitten teitä aletaan rakentaa yksi kerrallaan, yhteensä $m$ tietä.
Jokainen tie yhdistää kaksi kaupunkia toisiinsa.
Minkä tien rakentamisen jälkeen kaikki kaupungit ovat ensimmäistä
kertaa yhteydessä toisiinsa?

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\small
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}
\path[draw,thick,-] (1) -- (2);
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
\path[draw,thick,-] (4) -- (5);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\verkko{6}
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (2) -- (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki kaupunkien yhdistämisestä teillä. Vaiheen 5 jälkeen
kaikki kaupungit ovat yhteydessä toisiinsa.}
\label{fig:kauesi}
\end{figure}


Kuva \ref{fig:kauesi} näyttää esimerkkitapauksen, jossa $n=5$, $m=6$
ja tiet rakennetaan järjestyksessä $(1,2)$, $(1,3)$, $(2,3)$, $(4,5)$, $(2,4)$ ja $(2,5)$.
Kaikki kaupungit ovat yhteydessä toisiinsa vaiheen 5 jälkeen.

\subsubsection{Ratkaisu 1: Union-find-rakenne}

Voimme ratkaista tehtävän union-find-rakenteen avulla.
Esitämme verkon yhtenäiset komponentit joukkoina niin,
että kukin joukko sisältää komponentin solmut.
Alussa joukot ovat $\{1\},\{2\},\dots,\{n\}$
eli jokainen solmu on omassa komponentissaan.
Sitten jokaisen kaaren kohdalla tarkastamme,
ovatko sen päätesolmut eri joukoissa,
ja jos ovat, yhdistämme joukot.
Kun lopulta kaikki solmut ovat samassa joukossa,
verkko on tullut yhtenäiseksi.

Luomme ensin jokaiselle solmulle oman komponentin ja
suoritamme sitten jokaisen kaaren kohdalla yhden
\texttt{sama}-operaation
ja mahdollisesti yhden \texttt{yhdista}-operaation.
Tuloksena oleva algoritmi vie aikaa $O(n+m \alpha(n))$,
kun käytämme union-find-rakennetta, jossa on
tehokas yhdistäminen ja ketjujen tiivistäminen.

\subsubsection{Ratkaisu 2: Binäärihaku}

Toinen tapa ratkaista tehtävä on hyödyntää \emph{binäärihakua}.
Jos meillä on arvaus, että kaikki kaupungit ovat yhteydessä
$x$ lisäyksen jälkeen, voimme tarkistaa helposti,
pitääkö arvaus paikkansa:
lisäämme ensin $x$ ensimmäistä tietä verkkoon ja tarkastamme
sitten, onko verkko yhtenäinen. Tämä vie aikaa $O(n+m)$
käyttäen esimerkiksi syvyyshakua.

Tämän jälkeen voimme etsiä binäärihaun avulla suurimman arvon
$x$, jolle pätee, että kaikki kaupungit eivät ole yhteydessä
$x$ lisäyksen jälkeen. Tästä voimme päätellä, että kaupungit
ovat ensi kertaa yhteydessä $x+1$ lisäyksen jälkeen.
Koska mahdolliset $x$:n arvot ovat $1,2,\ldots,n$,
binäärihaku suorittaa $O(\log n)$ askelta ja ratkaisu vie
aikaa $O((n+m) \log n)$.

\section{Pienin virittävä puu}

Verkon \emph{virittävä} puu on kokoelma verkon kaaria,
jotka kytkevät kaikki verkon solmut toisiinsa.
Kuten puut yleensäkin, virittävä puu on syklitön eli
jokaisen kahden solmun välillä on yksikäsitteinen reitti.
Kuvassa \ref{fig:virpuu} on esimerkkinä verkko ja yksi sen virittävistä puista.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (3) -- (5);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
%\path[draw,thick,-] (1) -- (2);
\path[draw,thick,-] (1) -- (3);
\path[draw,thick,-] (2) -- (3);
%\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (2) -- (4);
\path[draw,thick,-] (3) -- (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja yksi sen virittävistä puista.}
\label{fig:virpuu}
\end{figure}

Jos verkko on painotettu, kiinnostava ongelma on etsiä verkon
\emph{pienin virittävä puu}.
Tämä on virittivä puu, jonka kaarten painojen summa on
mahdollisimman pieni.
Esimerkiksi kuvassa \ref{fig:pievir} on painotettu verkko ja kaksi sen virittävää puuta.
Vasemman puun paino on 12 ja oikean puun paino on 10.
Oikea puu on tämän verkon pienin virittävä puu.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=below:4] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\path[draw,thick,-] (3) -- node[font=\small,label=below:7] {} (5);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
%\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=below:4] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
%\path[draw,thick,-] (3) -- node[font=\small,label=below:7] {} (5);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
%\path[draw,thick,-] (1) -- node[font=\small,label=below:5] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
%\path[draw,thick,-] (3) -- node[font=\small,label=below:7] {} (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Vasemman virittävän puun paino on $5+1+2+4=12$
ja oikean virittävän puun paino on $1+2+2+5=10$.}
\label{fig:pievir}
\end{figure}

Seuraavaksi tutustumme kahteen algoritmiin, joiden avulla voimme
selvittää tehokkaasti verkon pienimmän virittävän puun.
Kruskalin algoritmi perustuu union-find-rakenteeseen,
ja Primin algoritmi on Dijkstran algoritmin muunnelma.

\subsection{Kruskalin algoritmi}

Kruskalin algoritmissa lähdemme liikkeelle verkosta,
jossa on valmiina kaikki solmut mutta ei vielä mitään kaaria.
Käymme läpi kaaret järjestyksessä niiden painon mukaan
keveimmästä raskaimpaan, ja jokaisen kaaren kohdalla
lisäämme sen verkkoon, jos se yhdistää kaksi eri komponenttia.
Kun kaikki komponentit on yhdistetty, pienin virittävä puu on valmis.

Kuva \ref{fig:kruesi} näyttää, kuinka Kruskalin algoritmi löytää pienimmän virittävän
puun esimerkkiverkossamme.
Algoritmi lisää ensin puuhun kaaren $(2,3)$, jonka paino on 1,
sekä kaaret $(1,2)$ ja $(2,4)$, joiden paino on 2.
Seuraavaksi vuorossa on kaari $(1,3)$, jonka paino on 4,
mutta tätä ei lisätä puuhun, koska se aiheuttaisi syklin.
Tämän jälkeen algoritmi lisää kaaren $(4,5)$ painolla 5,
jolloin pienin virittävä puu on valmis.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\small
\newcommand\verkko[1]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\path[draw,thick,-,dashed] (1) -- node[font=\small,label=below:4] {} (3);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Kruskalin algoritmin toiminnasta.}
\label{fig:kruesi}
\end{figure}

Kruskalin algoritmi on mahdollista toteuttaa tehokkaasti
käyttäen union-find-rakennetta.
Algoritmin alussa järjestämme kaaret painojärjestykseen,
missä kuluu aikaa $O(m \log m)$.
Tämän jälkeen käymme kaaret läpi, ja jokaisen kaaren
kohdalla lisäämme sen puuhun, jos se yhdistää kaksi eri komponenttia.
Tässä kuluu aikaa $O(m \log n)$ tai $O(m \alpha(n))$
riippuen rakenteen toteutuksesta.
Algoritmi vie siis yhteensä aikaa $O(m \log n)$.

\subsection{Primin algoritmi}

Primin algoritmi aloittaa virittävän puun muodostamisen
mielivaltaisesti valitusta solmusta.
Tämän jälkeen se lisää joka vaiheessa puuhun uuden solmun,
joka yhdistyy valmiina olevaan puuhun kaarella.
Lisättävä solmu valitaan niin, että kaari on kevein mahdollinen.
Kun kaikki solmut on lisätty puuhun, pienin virittävä puu on valmis.

Kuva \ref{fig:priesi} näyttää esimerkin Primin algoritmin toiminnasta.
Voimme aloittaa puun rakentamisen mistä tahansa solmusta;
tässä valitsemme solmun 1.
Lisäämme sen jälkeen puuhun kaaret järjestyksessä
$(1,2)$, $(2,3)$, $(2,4)$, $(4,5)$, ja saamme aikaan pienimmän
virittävän puun.

Primin algoritmi muistuttaa paljon Dijkstran algoritmia.
Erona on, että Dijkstran algoritmissa valitsemme joka vaiheessa
seuraavaksi solmun, jonka etäisyys alkusolmusta on pienin
mahdollinen.
Primin algoritmissa taas valitsemme solmun, jonka etäisyys
johonkin puun solmuun on pienin mahdollinen.

Voimme myös toteuttaa Primin algoritmin tehokkaasti samaan
tapaan kuin Dijkstran algoritmin.
Jotta voimme löytää tehokkaasti seuraavaksi lisät\-tävän solmun,
säilytämme solmuja keossa tai binäärihakupuussa.
Jokaisen solmun yhteydessä on tieto, kuinka painava on kaari,
jolla voi yhdistää solmun puuhun, ja solmut on järjestetty
näiden painojen mukaan.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\small
\newcommand\verkko[1]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Primin algoritmin toiminnasta.}
\label{fig:priesi}
\end{figure}

\subsection{Miksi algoritmit toimivat?}

Kruskalin ja Primin algoritmit ovat ahneita algoritmeja:
ne lisäävät joka askeleella keveimmän mahdollisen kaaren puuhun.
Miksi on varmaa, että algoritmit tuottavat pienimmän virittävän
puun joka tilanteessa?

Voimme ajatella asiaa näin: 
Jos meillä on kaksi solmua $a$ ja $b$, jotka ovat eri komponenteissa,
meidän on yhdistettävä ne jotenkin samaan komponenttiin algoritmin aikana.
Jos kevein saatavilla oleva kaari on solmujen $a$ ja $b$ välillä,
meidän kannattaa valita se, koska muuten joutuisimme yhdistämään komponentit
käyttäen raskaampaa kaarta.

Tarkastellaan esimerkkinä Kruskalin algoritmin alkua:
mitä tapahtuu, jos emme valitse puuhun keveintä kaarta?
Kuvassa \ref{fig:pietod} näkyy kuvitteellinen tilanne,
jossa katkoviivoilla esitetty pienin virittävä puu ei sisällä
keveintä kaarta $(2,3)$, jonka paino on 1.
Ei ole kuitenkaan mahdollista, että tämä olisi todellisuudessa
pienin virittävä puu, koska voisimme vaihtaa jonkin puun kaaren
kaareen $(2,3)$ ja saada pienennettyä puun painoa.

Tämä tarkoittaa, että on varmasti turvallinen ratkaisu valita
kevein kaari puuhun Kruskalin algoritmin alussa.
Vastaavasti voimme perustella, miksi seuraavaksi kannattaa
valita seuraavaksi kevein kaari jne.

TODO parempi todistus?


\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\begin{scope}
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-] (1) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=below:4] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-] (4) -- node[font=\small,label=right:5] {} (5);
\path[draw,thick,-] (2) -- node[font=\small,label=above:2] {} (4);
\path[draw,thick,-] (3) -- node[font=\small,label=below:7] {} (5);
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-,dashed] (1) -- (2);
\path[draw,thick,-,dashed] (1) -- (3);
\path[draw,thick,-,dashed] (4) -- (5);
\path[draw,thick,-,dashed] (2) -- (4);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,-,dashed] (1) -- (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:1] {} (3);
\path[draw,thick,-,dashed] (4) -- (5);
\path[draw,thick,-,dashed] (2) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Pienin virittävä puu sisältää varmasti kaaren $(2,3)$,
koska muuten voisimme pienentää puun painoa valitsemalla sen.}
\label{fig:pietod}
\end{figure}

\section{Esimerkki: Agentit}

Olet salaisen palvelun päällikkö ja palveluksessasi on $n$ agenttia.
Jokainen agentti on onnistunut hankkimaan tietoa ja haluat kerätä
kaikki tiedot itsellesi.
Agentit voivat tavata toisiaan ja voit tavata agentteja.
Ongelmana on kuitenkin, että on hankalaa järjestää tapaamisia turvallisesti.

Sinulla on lista $m$ agenttiparista, jotka voivat tavata toisensa turvallisesti.
Tapaamisessa kaksi agenttia kertoo toisilleen kaikki tietonsa,
ja tapaamiseen liittyy tietty kustannus.
Tämän jälkeen sopivasti valittu osajoukko agenteista tapaa sinut ja välittää tietonsa.
Voit tavata kenet tahansa agenteista, mutta jokaiseen tapaamiseen liittyy
kaikille sama kustannus $x$.

Mikä on pienin kokonaiskustannus, jolla saat kaikki tiedot itsellesi?

Esimerkiksi oletetaan, että $n=4$, $m=5$, $x=4$,
ja mahdolliset agenttien tapaamiset ovat seuraavat:

\begin{itemize}
\item agentit 1 ja 2 tapaavat (kustannus 5)
\item agentit 1 ja 3 tapaavat (kustannus 3)
\item agentit 2 ja 3 tapaavat (kustannus 2)
\item agentit 2 ja 4 tapaavat (kustannus 6)
\item agentit 3 ja 4 tapaavat (kustannus 7)
\end{itemize}

Optimaalinen ratkaisu on, että ensin agentit 1 ja 3 tapaavat,
sitten agentit 2 ja 3 tapaavat, ja lopuksi tapaat itse agentit 3 ja 4.
Agentti 3 on saanut kaikki tiedot agenteilta 1 ja 2.
Tämän ratkaisun kustannus on $3+2+4+4=13$, joka on pienin mahdollinen.

\subsubsection{Ratkaisu}

Voimme mallintaa ongelman verkkona, jossa on $n+1$ solmua:
jokaisella agentilla on oma solmu ja lisäksi sinulla on oma solmu.
Jos kaksi agenttia voivat tavata, niiden välillä on kaari,
jonka painona on tapaamisen kustannus.
Sinusta on kaari jokaiseen agenttiin painolla $x$.
Nyt pienin virittävä puu tässä verkossa vastaa optimaalista ratkaisua tehtävään.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=-1.5mm]
\begin{scope}
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (0,-3) {$2$};
\node[draw, circle] (3) at (3,0) {$3$};
\node[draw, circle] (4) at (3,-3) {$4$};
\node[draw, circle] (5) at (6,-1.5) {$*$};
\path[draw,thick,-] (1) -- node[font=\small,label=left:5] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=above:3] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:2] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=below:6] {} (4);
\path[draw,thick,-] (3) -- node[font=\small,label=right:7] {} (4);

\path[draw,thick,-] (1) edge [bend left=50] node[font=\small,label=above:4] {} (5);
\path[draw,thick,-] (2) edge [bend right=50] node[font=\small,label=below:4] {} (5);
\path[draw,thick,-] (3) -- node[font=\small,label=above:4] {} (5);
\path[draw,thick,-] (4) -- node[font=\small,label=below:4] {} (5);
\end{scope}
\begin{scope}[xshift=9cm]
\node[draw, circle] (1) at (0,0) {$1$};
\node[draw, circle] (2) at (0,-3) {$2$};
\node[draw, circle] (3) at (3,0) {$3$};
\node[draw, circle] (4) at (3,-3) {$4$};
\node[draw, circle] (5) at (6,-1.5) {$*$};
%\path[draw,thick,-] (1) -- node[font=\small,label=left:5] {} (2);
\path[draw,thick,-] (1) -- node[font=\small,label=above:3] {} (3);
\path[draw,thick,-] (2) -- node[font=\small,label=right:2] {} (3);
%\path[draw,thick,-] (2) -- node[font=\small,label=below:6] {} (4);
%\path[draw,thick,-] (3) -- node[font=\small,label=right:7] {} (4);

%\path[draw,thick,-] (1) edge [bend left=50] node[font=\small,label=above:4] {} (5);
%\path[draw,thick,-] (2) edge [bend right=50] node[font=\small,label=below:4] {} (5);
\path[draw,thick,-] (3) -- node[font=\small,label=above:4] {} (5);
\path[draw,thick,-] (4) -- node[font=\small,label=below:4] {} (5);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Verkko ja pienin virittävä puu agenttitehtävässä.}
\label{fig:ageesi}
\end{figure}

Kuva \ref{fig:ageesi} näyttää verkon ja pienimmän virittävän puun esimerkkitapauksessa.
Tähdellä merkitty solmu on oma solmusi, joka on yhteydessä kaikkiin
muihin solmuihin.
Puun paino on $3+2+4+4=13$, mikä vastaa optimaalista ratkaisua.